"use strict";(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[2955],{9933:A=>{A.exports="data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUFBQIAAQUBAgUIAwIDBAMFAQEBABACAhUCBQUNAwACAhECDwIBAAAAAAAAAgMNAAkAAgMCBgAEBAIBAAUEAxYAAgYEEQEJBAQAFwUAGAYEAAMDAwMBAgADDgEBAQACAgEDAQIAAAgDAgAAABkCGgAGCBsdHwQhCQEiBCMEAgUCEgABAAAABg0CAgICAgAAAAICAAIAAAAAAwMBAAQAAAAAAAIAAAACAAAAAAAAAgABAwIABQUQBQMECQJwAWhobwCAAQUDAQARBgkBfwFBgIDAAAsHVAUGbWVtb3J5AgALc29ydF9zcGxhdHMAkAEOcmF5Y2FzdF9zcGxhdHMAgwETX193YmluZGdlbl9leHBvcnRfMAEBEF9fd2JpbmRnZW5fc3RhcnQAEAmyAQEAQQELZ5EBpQGkAcgBowGfAcgBzgFfgQHJAXWiAZ8BzgFelgGgAVCNAWHNAbIBtwGRAaEBzgGRAXI9tQGaAaUBKE24AZEBcj62AYgBW4cBiAGFAY8BjgGHAYcBigGJAYsBe5MBvAGpAVJtugGRAXNBuwFmUWyoAacBqwF2qgG9AYwBY0lYyAGsAWdufL4BhgF5SL8BgAHAAcEBkQF3QMIBwwGYAZsBrQGuAYIBYCp0xQEKzdEEvgGEJAIJfwF+IwBBEGsiCCQAAn8CQAJAAkACQAJAAkAgAEH1AU8EQEEAIABBzf97Tw0HGiAAQQtqIgFBeHEhBUG80sAAKAIAIglFDQRBHyEHQQAgBWshBCAAQfT//wdNBEAgBUEGIAFBCHZnIgBrdkEBcSAAQQF0a0E+aiEHCyAHQQJ0QaDPwABqKAIAIgFFBEBBACEADAILQQAhACAFQRkgB0EBdmtBACAHQR9HG3QhAwNAAkAgASgCBEF4cSIGIAVJDQAgBiAFayIGIARPDQAgASECIAYiBA0AQQAhBCABIQAMBAsgASgCFCIGIAAgBiABIANBHXZBBHFqQRBqKAIAIgFHGyAAIAYbIQAgA0EBdCEDIAENAAsMAQtBuNLAACgCACICQRAgAEELakH4A3EgAEELSRsiBUEDdiIAdiIBQQNxBEACQCABQX9zQQFxIABqIgZBA3QiAEGw0MAAaiIDIABBuNDAAGooAgAiASgCCCIERwRAIAQgAzYCDCADIAQ2AggMAQtBuNLAACACQX4gBndxNgIACyABIABBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQgAUEIagwHCyAFQcDSwAAoAgBNDQMCQAJAIAFFBEBBvNLAACgCACIARQ0GIABoQQJ0QaDPwABqKAIAIgIoAgRBeHEgBWshBCACIQEDQAJAIAIoAhAiAA0AIAIoAhQiAA0AIAEoAhghBwJAAkAgASABKAIMIgBGBEAgAUEUQRAgASgCFCIAG2ooAgAiAg0BQQAhAAwCCyABKAIIIgIgADYCDCAAIAI2AggMAQsgAUEUaiABQRBqIAAbIQMDQCADIQYgAiIAQRRqIABBEGogACgCFCICGyEDIABBFEEQIAIbaigCACICDQALIAZBADYCAAsgB0UNBCABIAEoAhxBAnRBoM/AAGoiAigCAEcEQCAHQRBBFCAHKAIQIAFGG2ogADYCACAARQ0FDAQLIAIgADYCACAADQNBvNLAAEG80sAAKAIAQX4gASgCHHdxNgIADAQLIAAoAgRBeHEgBWsiAiAEIAIgBEkiAhshBCAAIAEgAhshASAAIQIMAAsACwJAQQIgAHQiA0EAIANrciABIAB0cWgiBkEDdCIBQbDQwABqIgMgAUG40MAAaigCACIAKAIIIgRHBEAgBCADNgIMIAMgBDYCCAwBC0G40sAAIAJBfiAGd3E2AgALIAAgBUEDcjYCBCAAIAVqIgYgASAFayIDQQFyNgIEIAAgAWogAzYCAEHA0sAAKAIAIgQEQCAEQXhxQbDQwABqIQFByNLAACgCACECAn9BuNLAACgCACIFQQEgBEEDdnQiBHFFBEBBuNLAACAEIAVyNgIAIAEMAQsgASgCCAshBCABIAI2AgggBCACNgIMIAIgATYCDCACIAQ2AggLQcjSwAAgBjYCAEHA0sAAIAM2AgAgAEEIagwICyAAIAc2AhggASgCECICBEAgACACNgIQIAIgADYCGAsgASgCFCICRQ0AIAAgAjYCFCACIAA2AhgLAkACQCAEQRBPBEAgASAFQQNyNgIEIAEgBWoiAyAEQQFyNgIEIAMgBGogBDYCAEHA0sAAKAIAIgZFDQEgBkF4cUGw0MAAaiEAQcjSwAAoAgAhAgJ/QbjSwAAoAgAiBUEBIAZBA3Z0IgZxRQRAQbjSwAAgBSAGcjYCACAADAELIAAoAggLIQYgACACNgIIIAYgAjYCDCACIAA2AgwgAiAGNgIIDAELIAEgBCAFaiIAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEDAELQcjSwAAgAzYCAEHA0sAAIAQ2AgALIAFBCGoMBgsgACACckUEQEEAIQJBAiAHdCIAQQAgAGtyIAlxIgBFDQMgAGhBAnRBoM/AAGooAgAhAAsgAEUNAQsDQCAAIAIgACgCBEF4cSIDIAVrIgYgBEkiBxshCSAAKAIQIgFFBEAgACgCFCEBCyACIAkgAyAFSSIAGyECIAQgBiAEIAcbIAAbIQQgASIADQALCyACRQ0AIAVBwNLAACgCACIATSAEIAAgBWtPcQ0AIAIoAhghBwJAAkAgAiACKAIMIgBGBEAgAkEUQRAgAigCFCIAG2ooAgAiAQ0BQQAhAAwCCyACKAIIIgEgADYCDCAAIAE2AggMAQsgAkEUaiACQRBqIAAbIQMDQCADIQYgASIAQRRqIABBEGogACgCFCIBGyEDIABBFEEQIAEbaigCACIBDQALIAZBADYCAAsgB0UNAiACIAIoAhxBAnRBoM/AAGoiASgCAEcEQCAHQRBBFCAHKAIQIAJGG2ogADYCACAARQ0DDAILIAEgADYCACAADQFBvNLAAEG80sAAKAIAQX4gAigCHHdxNgIADAILAkACQAJAAkACQCAFQcDSwAAoAgAiAUsEQCAFQcTSwAAoAgAiAE8EQCAFQa+ABGpBgIB8cSICQRB2QAAhACAIQQRqIgFBADYCCCABQQAgAkGAgHxxIABBf0YiAhs2AgQgAUEAIABBEHQgAhs2AgBBACAIKAIEIgFFDQkaIAgoAgwhBkHQ0sAAIAgoAggiBEHQ0sAAKAIAaiIANgIAQdTSwABB1NLAACgCACICIAAgACACSRs2AgACQAJAQczSwAAoAgAiAgRAQaDQwAAhAANAIAEgACgCACIDIAAoAgQiB2pGDQIgACgCCCIADQALDAILQdzSwAAoAgAiAEEAIAAgAU0bRQRAQdzSwAAgATYCAAtB4NLAAEH/HzYCAEGs0MAAIAY2AgBBpNDAACAENgIAQaDQwAAgATYCAEG80MAAQbDQwAA2AgBBxNDAAEG40MAANgIAQbjQwABBsNDAADYCAEHM0MAAQcDQwAA2AgBBwNDAAEG40MAANgIAQdTQwABByNDAADYCAEHI0MAAQcDQwAA2AgBB3NDAAEHQ0MAANgIAQdDQwABByNDAADYCAEHk0MAAQdjQwAA2AgBB2NDAAEHQ0MAANgIAQezQwABB4NDAADYCAEHg0MAAQdjQwAA2AgBB9NDAAEHo0MAANgIAQejQwABB4NDAADYCAEH80MAAQfDQwAA2AgBB8NDAAEHo0MAANgIAQfjQwABB8NDAADYCAEGE0cAAQfjQwAA2AgBBgNHAAEH40MAANgIAQYzRwABBgNHAADYCAEGI0cAAQYDRwAA2AgBBlNHAAEGI0cAANgIAQZDRwABBiNHAADYCAEGc0cAAQZDRwAA2AgBBmNHAAEGQ0cAANgIAQaTRwABBmNHAADYCAEGg0cAAQZjRwAA2AgBBrNHAAEGg0cAANgIAQajRwABBoNHAADYCAEG00cAAQajRwAA2AgBBsNHAAEGo0cAANgIAQbzRwABBsNHAADYCAEHE0cAAQbjRwAA2AgBBuNHAAEGw0cAANgIAQczRwABBwNHAADYCAEHA0cAAQbjRwAA2AgBB1NHAAEHI0cAANgIAQcjRwABBwNHAADYCAEHc0cAAQdDRwAA2AgBB0NHAAEHI0cAANgIAQeTRwABB2NHAADYCAEHY0cAAQdDRwAA2AgBB7NHAAEHg0cAANgIAQeDRwABB2NHAADYCAEH00cAAQejRwAA2AgBB6NHAAEHg0cAANgIAQfzRwABB8NHAADYCAEHw0cAAQejRwAA2AgBBhNLAAEH40cAANgIAQfjRwABB8NHAADYCAEGM0sAAQYDSwAA2AgBBgNLAAEH40cAANgIAQZTSwABBiNLAADYCAEGI0sAAQYDSwAA2AgBBnNLAAEGQ0sAANgIAQZDSwABBiNLAADYCAEGk0sAAQZjSwAA2AgBBmNLAAEGQ0sAANgIAQazSwABBoNLAADYCAEGg0sAAQZjSwAA2AgBBtNLAAEGo0sAANgIAQajSwABBoNLAADYCAEHM0sAAIAFBD2pBeHEiAEEIayICNgIAQbDSwABBqNLAADYCAEHE0sAAIARBKGsiAyABIABrakEIaiIANgIAIAIgAEEBcjYCBCABIANqQSg2AgRB2NLAAEGAgIABNgIADAgLIAIgA0kgASACTXINACAAKAIMIgNBAXENACADQQF2IAZGDQMLQdzSwABB3NLAACgCACIAIAEgACABSRs2AgAgASAEaiEDQaDQwAAhAAJAAkADQCADIAAoAgAiB0cEQCAAKAIIIgANAQwCCwsgACgCDCIDQQFxDQAgA0EBdiAGRg0BC0Gg0MAAIQADQAJAIAIgACgCACIDTwRAIAIgAyAAKAIEaiIHSQ0BCyAAKAIIIQAMAQsLQczSwAAgAUEPakF4cSIAQQhrIgM2AgBBxNLAACAEQShrIgkgASAAa2pBCGoiADYCACADIABBAXI2AgQgASAJakEoNgIEQdjSwABBgICAATYCACACIAdBIGtBeHFBCGsiACAAIAJBEGpJGyIDQRs2AgRBoNDAACkCACEKIANBEGpBqNDAACkCADcCACADIAo3AghBrNDAACAGNgIAQaTQwAAgBDYCAEGg0MAAIAE2AgBBqNDAACADQQhqNgIAIANBHGohAANAIABBBzYCACAAQQRqIgAgB0kNAAsgAiADRg0HIAMgAygCBEF+cTYCBCACIAMgAmsiAEEBcjYCBCADIAA2AgAgAEGAAk8EQCACIAAQQwwICyAAQfgBcUGw0MAAaiEBAn9BuNLAACgCACIDQQEgAEEDdnQiAHFFBEBBuNLAACAAIANyNgIAIAEMAQsgASgCCAshACABIAI2AgggACACNgIMIAIgATYCDCACIAA2AggMBwsgACABNgIAIAAgACgCBCAEajYCBCABQQ9qQXhxQQhrIgIgBUEDcjYCBCAHQQ9qQXhxQQhrIgQgAiAFaiIAayEFIARBzNLAACgCAEYNAyAEQcjSwAAoAgBGDQQgBCgCBCIBQQNxQQFGBEAgBCABQXhxIgEQOyABIAVqIQUgASAEaiIEKAIEIQELIAQgAUF+cTYCBCAAIAVBAXI2AgQgACAFaiAFNgIAIAVBgAJPBEAgACAFEEMMBgsgBUH4AXFBsNDAAGohAQJ/QbjSwAAoAgAiA0EBIAVBA3Z0IgRxRQRAQbjSwAAgAyAEcjYCACABDAELIAEoAggLIQMgASAANgIIIAMgADYCDCAAIAE2AgwgACADNgIIDAULQcTSwAAgACAFayIBNgIAQczSwABBzNLAACgCACIAIAVqIgI2AgAgAiABQQFyNgIEIAAgBUEDcjYCBCAAQQhqDAgLQcjSwAAoAgAhAAJAIAEgBWsiAkEPTQRAQcjSwABBADYCAEHA0sAAQQA2AgAgACABQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELQcDSwAAgAjYCAEHI0sAAIAAgBWoiAzYCACADIAJBAXI2AgQgACABaiACNgIAIAAgBUEDcjYCBAsgAEEIagwHCyAAIAQgB2o2AgRBzNLAAEHM0sAAKAIAIgBBD2pBeHEiAUEIayICNgIAQcTSwABBxNLAACgCACAEaiIDIAAgAWtqQQhqIgE2AgAgAiABQQFyNgIEIAAgA2pBKDYCBEHY0sAAQYCAgAE2AgAMAwtBzNLAACAANgIAQcTSwABBxNLAACgCACAFaiIBNgIAIAAgAUEBcjYCBAwBC0HI0sAAIAA2AgBBwNLAAEHA0sAAKAIAIAVqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsgAkEIagwDC0EAQcTSwAAoAgAiACAFTQ0CGkHE0sAAIAAgBWsiATYCAEHM0sAAQczSwAAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIagwCCyAAIAc2AhggAigCECIBBEAgACABNgIQIAEgADYCGAsgAigCFCIBRQ0AIAAgATYCFCABIAA2AhgLAkAgBEEQTwRAIAIgBUEDcjYCBCACIAVqIgAgBEEBcjYCBCAAIARqIAQ2AgAgBEGAAk8EQCAAIAQQQwwCCyAEQfgBcUGw0MAAaiEBAn9BuNLAACgCACIDQQEgBEEDdnQiBHFFBEBBuNLAACADIARyNgIAIAEMAQsgASgCCAshAyABIAA2AgggAyAANgIMIAAgATYCDCAAIAM2AggMAQsgAiAEIAVqIgBBA3I2AgQgACACaiIAIAAoAgRBAXI2AgQLIAJBCGoLIAhBEGokAAuCFwIKfwJ+IwBB0ABrIgUkAAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCACIIBEAgACAAKAIMQQFqIgI2AgwgAkH1A0kNASAAKAIQIgFFDQJB2KTAAEEZIAEQxgFFDQJBASEEDAsLIAAoAhAiAEUNCkHxpMAAQQEgABDGASEEDAoLIAAoAggiByAAKAIEIgZJBEBBASEEIAAgB0EBaiIDNgIIAkACQAJAAkACQAJAAkACQAJAIAcgCGotAAAiAkHCAGsOGAMCAAAAAAABAAAABwYAAAAAAAAAAAAHDQALIAAoAhAiAUUNEUHIpMAAQRAgARDGAQ0SDBELIAAgARASDREgAQ0GDA4LIAVBMGoiASAAEDYgBS0AMA0CIAUgBSkDOCIMNwMYAkAgACgCAARAIAEgABAfIAUoAjBFDQMgBUEoaiAFQThqKQIANwMAIAUgBSkCMDcDICAAKAIQIgFFDRAgBUEgaiABEBZFDQEMEgsgACgCECIARQRAQQAhBAwSC0HxpMAAQQEgABDGASEEDBELIAAoAhAiAUUgDFByDQ4gASgCHEEEcQ0OIAFB+6TAAEEBEJkBDRAgACgCECMAQYABayIDJAAgBUEYaikDACEMQQAhBgNAIAMgBmpB/wBqIAynQQ9xIgFBMHIgAUHXAGogAUEKSRs6AAAgBkEBayEGIAxCEFQgDEIEiCEMRQ0ACyAGQYABaiIBQYEBTwRAIAFBgAFBjK/AABBoAAtBnK/AAEECIAMgBmpBgAFqQQAgBmsQISADQYABaiQADRAgACgCEEH8pMAAQQEQmQFFDQ4MEAtBACEDIwBBIGsiCSQAAkACQAJAAkACfgJAAkACQCAAKAIAIgsEQCAAKAIIIgIgACgCBCIISQRAIAIgC2otAABB3wBGDQMLIAIgCCACIAhLGyEGIAIhAwNAIAMgCEkEQCADIAtqLQAAQd8ARg0DCyADIAZGDQYCQCADIAtqLQAAIgpBMGsiB0H/AXFBCkkNACAKQeEAa0H/AXFBGk8EQCAKQcEAa0H/AXFBGk8NCCAKQR1rIQcMAQsgCkHXAGshBwsgACADQQFqIgM2AgggCSANEGQgCSkDCEIAUg0GIAkpAwAiDCAHrUL/AYN8Ig0gDFoNAAsMBQsgACgCECIBRQ0HQfGkwABBASABEMYBIQMMBwsgACADQQFqNgIIIA1Cf1INAQwDCyAAIAJBAWo2AghCAAwBCyANQgF8CyEMIAwgAkEBa61aDQBBASEDIAAoAhAhAiAAKAIMQQFqIgZB9ANLDQEgAkUEQEEAIQMMBAsgCUEYaiICIABBCGoiBykCADcDACAAIAY2AgwgByAMPgIAIAkgACkCADcDECAAIAFBAXEQEiEDIAcgAikDADcCACAAIAkpAxA3AgAMAwtBACEDIAAoAhAiAUUNAUHIpMAAQRAgARDGAUUNAUEBIQMMAgsgAkUNAEHYpMAAQRkgAhDGAQ0BCyAAIAM6AARBACEDIABBADYCAAsgCUEgaiQAIAMNDwwNCyAAKAIQIQICQCAFLQA0IgFFBEAgAkUNAUHIpMAAQRAgAhDGAUUNAQwQCyACRQ0AQdikwABBGSACEMYBRQ0ADA8LIAAgAToABAwKCyAAKAIQIQICQCAFLQAxIgFFBEAgAkUNAUHIpMAAQRAgAhDGAUUNAQwPCyACRQ0AQdikwABBGSACEMYBRQ0ADA4LIAAgAToABAwJCwJAIAMgBk8NACAAIAdBAmo2AgggAyAIai0AACIDQcEAa0H/AXFBGk8EQCADQeEAa0GAgMQAIQNB/wFxQRpPDQELIAAgARASBEAMDgsCQAJAAn8CQAJAAkACQAJAIAAoAgBFBEBBACEEIAAoAhAiAUUNFkGAnsAAQQIgARDGAQRAQQEhBAwXCyAAKAIARQ0BCyAFQTBqIgEgABA2IAUtADANByAAKAIARQ0BIAUpAzghDCABIAAQHyAFKAIwRQ0GIAVByABqIAVBOGopAgA3AwAgBSAFKQIwNwNAIANBgIDEAEcNAiAFKAJEIAUoAkxyRQ0TIAAoAhAiAUUNE0GAnsAAQQIgARDGAUUNA0EBIQQMFQsgACgCECIARQ0UQfGkwABBASAAEMYBIQQMFAsgACgCECIARQRAQQAhBAwUC0HxpMAAQQEgABDGASEEDBMLQQAgACgCECIBRQ0CGkH9pMAAQQMgARDGAUUNAUEBIQQMEgsgACgCECIBRQ0PQQEhBCAFQUBrIAEQFkUNDwwRCyAAKAIQCyECAkACQCADQcMAayIBBEAgAUEQRg0BIAUgAzYCMCACRQ0CQQEhBCAFQTBqIAIQRkUNAgwSCyACRQ0BQQEhBEGApcAAQQcgAhDGAUUNAQwRCyACRQ0AQQEhBEGHpcAAQQQgAhDGAQ0QCyAAKAIQIQMgBSgCRCAFKAJMckUNCiADRQ0NQQEhBEGLpcAAQQEgAxDGAQ0PIAAoAhAiAUUNDSAFQUBrIAEQFg0PIAAoAhAhAwwKCyAAKAIQIQICQCAFLQA0IgFFBEAgAkUNAUHIpMAAQRAgAhDGAUUNAUEBIQQMEAsgAkUNAEHYpMAAQRkgAhDGAUUNAEEBIQQMDwsgACABOgAEDAoLIAAoAhAhAgJAIAUtADEiAUUEQCACRQ0BQcikwABBECACEMYBRQ0BQQEhBAwPCyACRQ0AQdikwABBGSACEMYBRQ0AQQEhBAwOCyAAIAE6AAQMCQsgACgCECIBRQ0LQcikwABBECABEMYBRQ0LDAwLIAMgBk8NBCADIAhqLQAAQfMARw0EIAAgB0ECaiIENgIIIAQgBk8NAyAEIAhqLQAAQd8ARw0DIAAgB0EDajYCCAwECyAAKAIQIgFFDQdBgJ7AAEECIAEQxgFFDQcMCgsgACgCECIBRQ0IQcikwABBECABEMYBRQ0IQQEhBAwJCyAAQQE6AAQMBAsCQANAAkAgBCAGSQRAIAQgCGotAABB3wBGDQELIAQgBkYNAgJAIAQgCGotAAAiA0EwayIBQf8BcUEKSQ0AIANB4QBrQf8BcUEaTwRAIANBwQBrQf8BcUEaTw0EIANBHWshAQwBCyADQdcAayEBCyAAIARBAWoiBDYCCCAFQQhqIA0QZCAFKQMQQgBSDQIgBSkDCCIMIAGtQv8Bg3wiDSAMWg0BDAILCyAAIARBAWo2AgggDUJ9WA0BCyAAKAIQIgFFDQZByKTAAEEQIAEQxgFFDQZBASEEDAcLIwBBEGsiAyQAIAAoAhAhASAAQQA2AhACQCAAQQAQEkUEQCAAIAE2AhAgA0EQaiQADAELQcSgwABBPSADQQ9qQbSgwABBuKTAABBlAAsLIAAoAhAiAQRAQQEhBEH8nsAAQQEgARDGAQ0GC0EBIQQgABAZDQUgAkHNAEcEQCAAKAIQIgEEQEGNpcAAQQQgARDGAQ0HCyAAQQAQEg0GCyAAKAIQIgFFDQNB+57AAEEBIAEQxgFFDQMMBQsgA0UNAkEBIQRBjKXAAEEBIAMQxgENBCAAKAIQIQEgBSAMNwMwIAFFDQIgBUEwaiABELQBDQQgACgCECIBRQ0CQb6hwABBASABEMYBRQ0CDAQLQQAhBCAAQQA2AgAMAwsgACgCECIBBEBB/J7AAEEBIAEQxgENAwsCf0EAIQMgACgCACICBEADQAJAIAAoAggiASAAKAIETw0AIAEgAmotAABBxQBHDQAgACABQQFqNgIIQQAMAwsCQCADRQ0AIAAoAhAiAUUNAEH5pMAAQQIgARDGAUUNAEEBDAMLQQEgABAxDQIaIANBAWshAyAAKAIAIgINAAsLQQALDQIgACgCECIBRQ0AQfuewABBASABEMYBDQILQQAhBCAAKAIARQ0BIAAgACgCDEEBazYCDAwBC0EAIQQgAEEAOgAEIABBADYCAAsgBUHQAGokACAEC8YbAgl/An4jAEEwayIJJAACQAJAAkACQAJAAkACQAJAAkAgACgCACIKBEAgACgCCCIHIAAoAgQiBEkNASAAKAIQIgFFDQJByKTAAEEQIAEQxgFFDQJBASEDDAkLIAAoAhAiAEUNCEHxpMAAQQEgABDGASEDDAgLIAAgB0EBaiIFNgIIIAcgCmotAAAhBiAAIAAoAgxBAWoiAjYCDCACQfQDSw0BAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBkHBAGsOOQ0EAAAAAAAAAAAAAAAAAAAKCQAOAA8AAAAAAAAAAAAAAwYHAAgAAAIDAgADAgMCAQAAAwIAAAADAgALIAAoAhAiAUUND0HIpMAAQRAgARDGAUUND0EBIQMMFgsgACgCECIBRQ0UQQEhA0Hyo8AAQQEgARDGAUUNFAwVCyAAIAYQK0UNE0EBIQMMFAsgBCAFTQ0RIAUgCmotAABB7gBGDQEMEQtBACEEIwBBIGsiAyQAAkACQAJAAkACfgJAAkACQCAAKAIAIgcEQCAAKAIIIgIgACgCBCIFSQRAIAIgB2otAABB3wBGDQMLIAIgBSACIAVLGyEKIAIhBANAIAQgBUkEQCAEIAdqLQAAQd8ARg0DCyAEIApGDQYCQCAEIAdqLQAAIghBMGsiBkH/AXFBCkkNACAIQeEAa0H/AXFBGk8EQCAIQcEAa0H/AXFBGk8NCCAIQR1rIQYMAQsgCEHXAGshBgsgACAEQQFqIgQ2AgggAyAMEGQgAykDCEIAUg0GIAMpAwAiCyAGrUL/AYN8IgwgC1oNAAsMBQsgACgCECIBRQ0HQfGkwABBASABEMYBIQQMBwsgACAEQQFqNgIIIAxCf1INAQwDCyAAIAJBAWo2AghCAAwBCyAMQgF8CyELIAsgAkEBa61aDQBBASEEIAAoAhAhAiAAKAIMQQFqIgpB9ANLDQEgAkUEQEEAIQQMBAsgA0EYaiICIABBCGoiBikCADcDACAAIAo2AgwgBiALPgIAIAMgACkCADcDECAAIAFBAXEQEyEEIAYgAikDADcCACAAIAMpAxA3AgAMAwtBACEEIAAoAhAiAUUNAUHIpMAAQRAgARDGAUUNAUEBIQQMAgsgAkUNAEHYpMAAQRkgAhDGAQ0BCyAAIAQ6AARBACEEIABBADYCAAsgA0EgaiQAIARFDRFBASEDDBILIAAgB0ECajYCCCAAKAIQIgFFDQ9BASEDQb2hwABBASABEMYBRQ0PDBELIAlBKGogABBLIAkoAigiAQRAIAkgASAJKAIsEDQCQAJAAkAgCSkDAEIBUg0AIAkpAwgiC0IBVg0AIAunQQFrDQEMAgsgACgCECIBRQ0MQcikwABBECABEMYBRQ0MQQEhAwwTCyAAKAIQIgFFDRFB0KXAAEEFIAEQxgFFDRFBASEDDBILIAAoAhAiAUUNEEHVpcAAQQQgARDGAUUNEEEBIQMMEQsgACgCECECAkAgCS0ALCIBRQRAIAJFDQFByKTAAEEQIAIQxgFFDQFBASEDDBILIAJFDQBB2KTAAEEZIAIQxgFFDQBBASEDDBELIAAgAToABAwNCyAJQShqIAAQSyAJKAIoIgEEQCAJQRBqIAEgCSgCLBA0AkACQCAJKQMQUA0AIAkpAxgiC0KAgICAEFoNACALpyIBQYCwA3NBgIDEAGtBgJC8f0kNACALQoCAxABSDQELIAAoAhAiAUUNCkHIpMAAQRAgARDGAUUNCkEBIQMMEQsgACgCECEGIwBBEGsiBSQAAn9BACAGRQ0AGgJAIAZBJxCcAQ0AIAVBCGohCgNAAkACQCABQSJHBEAgAUGAgMQARgRAIAZBJxCcAQwGCyAFIAEQIyAFLQAAQYABRw0BQYABIQIDQAJAIAJBgAFHBEAgBS0ACiIBIAUtAAtPDQUgBSABQQFqOgAKIAEgBWotAAAhAQwBC0EAIQIgCkEANgIAIAUoAgQhASAFQgA3AwALIAYgARCcAUUNAAsMBAtBgIDEACEBIAZBIhCcAUUNAgwDCyAFLQAKIgEgBS0ACyICIAEgAksbIQQDQCABIARGDQEgASAFaiECIAFBAWohASAGIAItAAAQnAFFDQALDAILQYCAxAAhAQwACwALQQELIAVBEGokAEUND0EBIQMMEAsgACgCECECAkAgCS0ALCIBRQRAIAJFDQFByKTAAEEQIAIQxgFFDQFBASEDDBELIAJFDQBB2KTAAEEZIAIQxgFFDQBBASEDDBALIAAgAToABAwMCwJAIAENACAAKAIQIgJFDQBBASEDQdmlwABBASACEMYBDQ8LIAAoAhAiAgRAQQEhA0H+nsAAQQEgAhDGAQ0PCyAAEB1FDQpBASEDDA4LIAQgBU0NACAFIApqLQAAQeUARg0BCwJAIAENACAAKAIQIgJFDQBBASEDQdmlwABBASACEMYBDQ0LIAAoAhAiAgRAQQEhA0H9nsAAQQEgAhDGAQ0NCyAGQdIARw0BDAcLIAAgB0ECajYCCCAAEB1FDQpBASEDDAsLIAAoAhAiAkUNBUGSpcAAQQQgAhDGAUUNBUEBIQMMCgsCQCABDQAgACgCECICRQ0AQQEhA0HZpcAAQQEgAhDGAQ0KCyAAKAIQIgIEQEEBIQNB+6TAAEEBIAIQxgENCgsgABBiBEBBASEDDAoLIAAoAhAiAkUNCEEBIQNB/KTAAEEBIAIQxgFFDQUMCQsCQCABDQAgACgCECICRQ0AQQEhA0HZpcAAQQEgAhDGAQ0JCyAAKAIQIgIEQEEBIQNB+p7AAEEBIAIQxgENCQsgCUEgaiEKQQAhBgJ/AkAgACgCACIERQ0AA0ACQCAAKAIIIgIgACgCBE8NACACIARqLQAAQcUARw0AIAAgAkEBajYCCAwCCwJAIAZFDQAgACgCECICRQ0AQfmkwABBAiACEMYBRQ0AQQEMAwtBASAAQQEQEw0CGiAGQQFqIQYgACgCACIEDQALC0EACyECIAogBjYCBCAKIAI2AgAgCSgCIARAQQEhAwwJCyAJKAIkQQFGBEAgACgCECICRQ0IQQEhA0H4nsAAQQEgAhDGAQ0JCyAAKAIQIgJFDQdBASEDQfmewABBASACEMYBRQ0EDAgLAkAgAQ0AIAAoAhAiAkUNAEEBIQNB2aXAAEEBIAIQxgENCAtBASEDIABBARASDQcCQAJAAkACQAJAAkAgACgCACICBEAgACgCCCIEIAAoAgRPDQYgACAEQQFqNgIIIAIgBGotAABB0wBrDgMDAgoBCyAAKAIQIgBFBEBBACEDDA4LQfGkwABBASAAEMYBIQMMDQsgACgCECIBRQ0FQcikwABBECABEMYBRQ0FDAwLIAAoAhAiAgRAQfqewABBASACEMYBDQwLIAAQYkUNAQwLCyAAKAIQIgJFDQFB2qXAAEEDIAIQxgFFDQEMCgsgACgCECICRQ0IQfmewABBASACEMYBRQ0FDAkLQQAhCiMAQTBrIgckAAJAAkAgACgCACIFRQ0AA0ACQCAAKAIIIgIgACgCBE8NACACIAVqLQAAQcUARw0AIAAgAkEBajYCCAwCCwJAAkACQAJAAkACQAJAIApFDQAgACgCECICRQ0AQfmkwABBAiACEMYBBEBBASEIDAoLIAAoAgAiBUUNAQsgACgCCCICIAAoAgQiBE8NAiACIAVqLQAAQfMARw0CIAAgAkEBaiIINgIIIAQgCE0NASAFIAhqLQAAQd8ARw0BIAAgAkECajYCCAwCCyAAKAIQIgJFDQZBASEIQfGkwABBASACEMYBDQcMBAtCACEMAkADQAJAIAQgCEsEQCAFIAhqLQAAQd8ARg0BCyAEIAhGDQICQCAFIAhqLQAAIgZBMGsiAkH/AXFBCkkNACAGQeEAa0H/AXFBGk8EQCAGQcEAa0H/AXFBGk8NBCAGQR1rIQIMAQsgBkHXAGshAgsgACAIQQFqIgg2AgggByAMEGQgBykDCEIAUg0CIAcpAwAiCyACrUL/AYN8IgwgC1oNAQwCCwsgACAIQQFqNgIIIAxCfVgNAQsgACgCECICBEBByKTAAEEQIAIQxgENAgsgAEEAOgAEIABBADYCAAwFCyAHQRBqIAAQHyAHKAIQBEAgB0EoaiAHQRhqKQIANwMAIAcgBykCEDcDICAAKAIQIgIEQCAHQSBqIAIQFg0CQd+lwABBAiACEMYBDQILQQEhCCAAQQEQE0UNAwwGCyAAKAIQIQQCQCAHLQAUIgJFBEAgBEUNA0HIpMAAQRAgBBDGAQ0BDAMLIARFDQJB2KTAAEEZIAQQxgFFDQILQQEhCAwFC0EBIQgMBAsgACACOgAEIABBADYCAAsgCkEBaiEKIAAoAgAiBQ0ACwtBACEICyAHQTBqJAAgCA0IIAAoAhAiAkUNB0HdpcAAQQIgAhDGAUUNBAwICyAAKAIQIgFFDQBByKTAAEEQIAEQxgENBwtBACEDIABBADoABCAAQQA2AgAMBgsCQCAAKAIQIgFFDQBB2KTAAEEZIAEQxgFFDQBBASEDDAYLIABBAToABAwCC0EBIQMgAEEBEBMNBAsgAQ0CIAAoAhAiAUUNAkEBIQNBvqHAAEEBIAEQxgFFDQIMAwsgAEEANgIADAILIAAgBhArRQ0AQQEhAwwBC0EAIQMgACgCAEUNACAAIAAoAgxBAWs2AgwLIAlBMGokACADC5cLAgp/AX4gBEUEQCAAQQA2AjwgACADNgI4IAAgAjYCNCAAIAE2AjAgAEEAOgAOIABBgQI7AQwgACACNgIIIABCADcDAA8LQQEhCwJAAkACQAJAAkACQAJAAkACQAJAIARBAUYEQEEBIQkMAQtBASEGQQEhBwNAIAUgCmoiCCAETw0CIAchDAJAIAMgBmotAAAiBiADIAhqLQAAIghJBEAgBSAHakEBaiIHIAprIQtBACEFDAELIAYgCEcEQEEBIQsgDEEBaiEHQQAhBSAMIQoMAQtBACAFQQFqIgcgByALRiIGGyEFIAdBACAGGyAMaiEHCyAFIAdqIgYgBEkNAAtBASEGQQAhCEEBIQdBACEFQQEhCQNAIAUgCGoiDSAETw0DIAchDAJAIAMgBmotAAAiBiADIA1qLQAAIg1LBEAgBSAHakEBaiIHIAhrIQlBACEFDAELIAYgDUcEQEEBIQkgDEEBaiEHQQAhBSAMIQgMAQtBACAFQQFqIgcgByAJRiIGGyEFIAdBACAGGyAMaiEHCyAFIAdqIgYgBEkNAAsgCiEFCyAEIAUgCCAFIAhLIgUbIgxJDQIgCyAJIAUbIgcgDGoiBSAHSQ0DIAQgBUkNBAJ/IAMgAyAHaiAMEHEEQCAMIAQgDGsiBkshCyAEQQNxIQgCQCAEQQFrQQNJBEBBACEHDAELIARBfHEhCkEAIQcDQEIBIAMgB2oiBUEDajEAAIZCASAFMQAAhiAPhEIBIAVBAWoxAACGhEIBIAVBAmoxAACGhIQhDyAKIAdBBGoiB0cNAAsLIAgEQCADIAdqIQUDQEIBIAUxAACGIA+EIQ8gBUEBaiEFIAhBAWsiCA0ACwsgDCAGIAsbQQFqIQdBfyEKIAwhC0F/DAELQQEhCEEAIQVBASEGQQAhCwNAIAQgBiIKIAVqIg1LBEAgBCAFayAGQX9zaiIGIARPDQggBUF/cyAEaiALayIJIARPDQkCQCADIAZqLQAAIgYgAyAJai0AACIJSQRAIA1BAWoiBiALayEIQQAhBQwBCyAGIAlHBEAgCkEBaiEGQQAhBUEBIQggCiELDAELQQAgBUEBaiIGIAYgCEYiCRshBSAGQQAgCRsgCmohBgsgByAIRw0BCwtBASEIQQAhBUEBIQZBACEJA0AgBCAGIgogBWoiDksEQCAEIAVrIAZBf3NqIgYgBE8NCiAFQX9zIARqIAlrIg0gBE8NCwJAIAMgBmotAAAiBiADIA1qLQAAIg1LBEAgDkEBaiIGIAlrIQhBACEFDAELIAYgDUcEQCAKQQFqIQZBACEFQQEhCCAKIQkMAQtBACAFQQFqIgYgBiAIRiINGyEFIAZBACANGyAKaiEGCyAHIAhHDQELCyAEIAsgCSAJIAtJG2shCwJAIAdFBEBBACEHQQAhCgwBCyAHQQNxIQZBACEKAkAgB0EESQRAQQAhCAwBCyAHQXxxIQlBACEIA0BCASADIAhqIgVBA2oxAACGQgEgBTEAAIYgD4RCASAFQQFqMQAAhoRCASAFQQJqMQAAhoSEIQ8gCSAIQQRqIghHDQALCyAGRQ0AIAMgCGohBQNAQgEgBTEAAIYgD4QhDyAFQQFqIQUgBkEBayIGDQALCyAECyEFIAAgBDYCPCAAIAM2AjggACACNgI0IAAgATYCMCAAIAU2AiggACAKNgIkIAAgAjYCICAAQQA2AhwgACAHNgIYIAAgCzYCFCAAIAw2AhAgACAPNwMIIABBATYCAA8LIAggBEGYtsAAEGkACyANIARBmLbAABBpAAsgDCAEQfi1wAAQagALIAcgBUGItsAAEGsACyAFIARBiLbAABBqAAsgBiAEQai2wAAQaQALIAkgBEG4tsAAEGkACyAGIARBqLbAABBpAAsgDSAEQbi2wAAQaQALlAwCB38BfiMAQfAAayIHJAAgACgCBCELIAAoAgAhCCAHQQA2AgQCfwJAIAgtABBBAUcNACAIKAIAIQkCQAJAAkAgC0UEQCAHIAhBDGqtQoCAgIDwAoQ3AwggB0EDOgBkIAdBADYCYCAHQiA3AlggB0KAgICAwAA3AlAgB0ECNgJIIAdBATYCPCAHQQI2AiwgB0G4l8AANgIoIAdBATYCNCAJQRRqKAIAIAlBGGooAgAgByAHQcgAaiIMNgI4IAcgB0EIaiINNgIwIAdBKGoQKQ0CIAgtABBBAUcNASAIKAIAIQkgB0KAgICAoAE3AxAgByAHQQRqrUKAgICA8AaENwMIIAdBAzoAZCAHQQA2AmAgB0IgNwJYIAdCgYCAgBA3AlAgB0ECNgJIIAdBATYCPCAHQQI2AiwgB0HMl8AANgIoIAdBAjYCNCAJQRRqKAIAIAlBGGooAgAgByAMNgI4IAcgDTYCMCAHQShqECkNAgwBCyAJQRRqKAIAQdyXwABBBiAJQRhqKAIAKAIMEQEADQEgCC0AEEEBRw0AIAgoAgAhCSAHQoCAgIDQATcDECAHQYyUwAA2AiggB0KMlMCAgAc3AwggB0EDOgBkIAdBADYCYCAHQiA3AlggB0KBgICAEDcCUCAHQQI2AkggB0EBNgI8IAdBATYCLCAHQQI2AjQgCUEUaigCACAJQRhqKAIAIAcgB0HIAGo2AjggByAHQQhqNgIwIAdBKGoQKQ0BCwJAIAEoAgBBA0YEQCAIKAIAIgFBFGooAgBBwJXAAEEJIAFBGGooAgAoAgwRAQBFDQEMAgtCgICAgJAHIQ4gCC0AEEUEQCAHQegAaiABQSBqKQIANwMAIAdB4ABqIAFBGGopAgA3AwAgB0HYAGogAUEQaikCADcDACAHQdAAaiABQQhqKQIANwMAIAcgASkCADcDSCAIKAIAIQEgByAOIAdByABqrYQ3AyAgB0EDOgBEIAdBBDYCQCAHQiA3AjggB0ECNgIwIAdBAjYCKCAHQQE2AhwgB0EBNgIMIAdBjJTAADYCCCAHQQE2AhQgAUEUaigCACABQRhqKAIAIAcgB0EoajYCGCAHIAdBIGo2AhAgB0EIahApDQIMAQsgB0HoAGogAUEgaikCADcDACAHQeAAaiABQRhqKQIANwMAIAdB2ABqIAFBEGopAgA3AwAgB0HQAGogAUEIaikCADcDACAHIAEpAgA3A0ggCCgCACEBIAcgDiAHQcgAaq2ENwMIIAdBATYCLCAHQYyUwAA2AiggB0IBNwI0IAFBFGooAgAgAUEYaigCACAHIAdBCGo2AjAgB0EoahApDQELIAgoAgBBoJbAAEEBEJkBDQAgA0EBcUUgAigCAEECRnINAiAHIAQ2AiAgCC0AEEEBRgRAIAgoAgAhASAHQoCAgICgATcDECAHQYyUwAA2AiggB0KMlMCAgAc3AwggB0EDOgBkIAdBADYCYCAHQiA3AlggB0KBgICAEDcCUCAHQQI2AkggB0EBNgI8IAdBATYCLCAHQQI2AjQgAUEUaigCACABQRhqKAIAIAcgB0HIAGo2AjggByAHQQhqNgIwIAdBKGoQKQ0BCyAIKAIAIgFBFGooAgBB4pfAAEEQIAFBGGooAgAoAgwRAQANACAIKAIEIAgoAgghAyAHQdQAaiACQQhqKAIANgIAIAcgCCgCACIENgJIIAcgAikCADcCTCAEIAdBzABqIAMoAhARAQANACAIKAIAIQEgB0KAgICA8AIiDiAHQSBqrYQ3AyggB0EBNgJMIAdB9JfAADYCSCAHQgE3AlQgAUEUaigCACABQRhqKAIAIAcgB0EoaiIDNgJQIAdByABqECkNACAFQQFxRQ0BIAcgBjYCCCAIKAIAIQEgByAOIAdBCGqthDcDKCAHQQE2AkwgB0H0l8AANgJIIAdCATcCVCABQRRqKAIAIAFBGGooAgAgByADNgJQIAdByABqEClFDQELQQEMAgtBASAIKAIAIgJBFGooAgBBoJbAAEEBIAJBGGooAgAoAgwRAQANARoLIAAgC0EBajYCBEEACyAHQfAAaiQAC7wJAhV/An4jAEGQBGsiCiQAIApBDGpBgAQQVxoCQCAAKAIMIhJFBEAgASAAKAIAIAAoAgQQmQEhAgwBCyAAKAIAIQ0gACgCCCIOLQAAIQsCQAJAIAAoAgQiD0UNACANIA9qIQcgCkEMaiEDIA0hAANAAn8gACwAACIEQQBOBEAgBEH/AXEhBSAAQQFqDAELIAAtAAFBP3EhBiAEQR9xIQkgBEFfTQRAIAlBBnQgBnIhBSAAQQJqDAELIAAtAAJBP3EgBkEGdHIhBiAEQXBJBEAgBiAJQQx0ciEFIABBA2oMAQsgCUESdEGAgPAAcSAALQADQT9xIAZBBnRyciIFQYCAxABGDQIgAEEEagshACACQYABRg0CIAMgBTYCACADQQRqIQMgAkEBaiECIAAgB0cNAAsLIA4gEmohEyACQQFrIRUgAkECdCIAQQRqIQwgACAKakEIaiEQIApBBGshFkG8BSEUQcgAIQcgDiEFQYABIQkCQANAIAtB4QBrIgBB/wFxQRpPBEAgC0Ewa0H/AXFBCUsNAyALQRZrIQALIAVBAWohBQJAQQFBGkEkIAdrIgNBACADQSRNGyIDIANBGk8bIAdBJE8bIgQgAEH/AXEiA00EQEEkIARrIQZByAAhAANAIAUgE0YNBSAFLQAAIgtB4QBrIgRB/wFxQRpPBEAgC0Ewa0H/AXFBCUsNBiALQRZrIQQLIAatIhcgBEH/AXEiBq1+IhhCIIinDQUgGKcgA2oiBCADSQ0FIAZBAUEaIAAgB2siA0EAIAAgA08bIgMgA0EaTxsgACAHTRsiA08EQCAFQQFqIQUgAEEkaiEAIBdBJCADa61+IhenIQYgBCEDIBdCIIhQDQEMBgsLIAVBAWohBQwBCyADIQQLIAQgCGoiACAISQ0CIAkgACACQQFqIgZuIgMgCWoiCUsgCUGAsANzQYAQa0H/78MAS3IgCUGAgMQARiACQf8AS3JyDQICQCAAIAMgBmxrIgggAkkEQCACIAhrQQNxIgcEQEEAIQMgECEAA0AgAEEEaiAAKAIANgIAIABBBGshACAHIANBAWoiA0cNAAsgAiADayECCyARIBVqIAhrQQNJDQEgFiACQQJ0aiEAA0AgAEEMaiAAQQhqKQIANwIAIABBBGogACkCADcCACAAQRBrIQAgAkEEayICIAhLDQALDAELIAhBgAFPDQILIApBDGogCEECdGogCTYCACAFIBNHBEAgBS0AACELQQAhAAJAIAQgFG4iAiAGbiACaiICQcgDSQRAIAIhBwwBCwNAIABBJGohACACQdf8AEsgAkEjbiIHIQINAAsLIAhBAWohCCAAIAdBJGxB/P8DcSAHQSZqQf//A3FuaiEHIBBBBGohECAMQQRqIQwgEUEBaiERQQIhFCAGIQIMAQsLIApBDGohAANAIAogACgCADYCjAQgCkGMBGogARBGIgINAyAAQQRqIQAgDEEEayIMDQALDAILIAhBgAFBpKHAABBpAAtBASECIAFBtKHAAEEJEJkBDQAgDwRAIAEgDSAPEJkBDQEgAUG9ocAAQQEQmQENAQsgASAOIBIQmQENACABQb6hwABBARCZASECCyAKQZAEaiQAIAIL6QoBC38jAEHQAGsiAiQAQYGAxAAhBAJAAkACQCAAKAIEIgEgACgCECIDSQ0AIAAgASADayIKNgIEIAAgACgCACIBIANqIgk2AgACQAJAAkAgA0ECRgRAIAEtAAEhBSABLQAAIgFBMGsiBkEKTwRAQX8gAUEgciIDQdcAayIBIAEgA0HhAGtJGyIGQRBPDQcLIAVBMGsiBEEKTwRAQX8gBUEgciIDQdcAayIBIAEgA0HhAGtJGyIEQRBPDQcLIAQgBkEEdCIBciEDIAHAQQBODQFBgIDEACEEIAZBDEkNBCACAn9BAiAGQQ5JDQAaIAZBD0cEQEEBIQhBAwwBCyADQf8BcUH4AU8NBUEECyILNgIIIAJBADoADyACQQA7AA0gAiADOgAMIAIgAkEMajYCBCAKQQJJDQMgACAKQQJrIgU2AgQgACAJQQJqNgIAIAktAAEhByAJLQAAIgFBMGsiBEEKTwRAQX8gAUEgciIDQdcAayIBIAEgA0HhAGtJGyIEQQ9LDQcLAkAgB0EwayIBQQpPBEBBfyAHQSByIgNB1wBrIgEgASADQeEAa0kbIgFBD0sNAQsgAiAEQQR0IAFyOgANIAZBDkkNAyAFQQJJDQQgACAKQQRrIgU2AgQgACAJQQRqNgIAIAktAAMhByAJLQACIgFBMGsiBkEKTwRAQX8gAUEgciIDQdcAayIBIAEgA0HhAGtJGyIGQQ9LDQgLIAdBMGsiBEEKTwRAQX8gB0EgciIDQdcAayIBIAEgA0HhAGtJGyIEQQ9LDQELIAIgBkEEdCAEcjoADiAIDQMgBUECSQ0EIAAgCkEGazYCBCAAIAlBBmo2AgAgCS0ABSEDIAktAAQiAEEwayIEQQpPBEBBfyAAQSByIgFB1wBrIgAgACABQeEAa0kbIgRBD0sNCAsgA0EwayIGQQpPBEBBfyADQSByIgFB1wBrIgAgACABQeEAa0kbIgZBD0sNAQsgAiAEQQR0IAZyOgAPDAMLDAYLQdChwABBKEH4ocAAEHgAC0EBIQsgAkEBNgIIIAJBADoADyACQQA7AA0gAiADOgAMIAIgAkEMajYCBAsgAkEwaiACQQxqIAsQJCACKAIwDQAgAigCNCEAIAIgAigCOCIBNgIUIAIgADYCECAAIAFqIQMgAUUNAiADAn8gACwAACIIQQBOBEAgCEH/AXEhBCAAQQFqDAELIAAtAAFBP3EhASAIQR9xIQUgCEFfTQRAIAVBBnQgAXIhBCAAQQJqDAELIAAtAAJBP3EgAUEGdHIhASAIQXBJBEAgASAFQQx0ciEEIABBA2oMAQsgBUESdEGAgPAAcSAALQADQT9xIAFBBnRyciEEIABBBGoLIgFHBEAgASwAABoMAwsgBEGAgMQARg0CDAELQYCAxAAhBAsgAkHQAGokACAEDwsCfyADIABrIgFBEE8EQCAAIAEQGwwBCwJ/QQAhCEEAIAFFDQAaIAFBA3EhBQJAIAFBBEkEQEEAIQcMAQsgAUF8cSEBQQAhBwNAIAcgACAIaiIDLAAAQb9/SmogA0EBaiwAAEG/f0pqIANBAmosAABBv39KaiADQQNqLAAAQb9/SmohByABIAhBBGoiCEcNAAsLIAUEQCAAIAhqIQADQCAHIAAsAABBv39KaiEHIABBAWohACAFQQFrIgUNAAsLIAcLCyEAIAIgAkHMAGqtQoCAgIDwAoQ3A0AgAiACQRBqrUKAgICA4AmENwM4IAIgAkEEaq1CgICAgPAJhDcDMCACIAA2AkwgAkEENgIcIAJBiKPAADYCGCACQgM3AiQgAiACQTBqNgIgIAJBGGpBqKPAABCEAQALQYiiwAAQswEAC5cKAQZ/IwBB4ABrIgEkAAJ/AkAgACgCACIDRQ0AAkAgACgCCCICIAAoAgQiBE8NACACIANqLQAAQdUARw0AQQEhBSAAIAJBAWoiAjYCCAsCQAJAAkAgAiAESQRAIAIgA2otAABBywBGDQELIAVFDQNBACEDDAELIAAgAkEBaiIGNgIIAkACQCAEIAZNDQAgAyAGai0AAEHDAEcNACAAIAJBAmo2AghBASEEQeSewAAhAwwBCyABQShqIAAQHyABKAIoIgMEQCABKAIsIgQEQCABKAI0RQ0CCwJAIAAoAhAiAkUNAEHIpMAAQRAgAhDGAUUNAEEBDAYLIABBADoABCAAQQA2AgBBAAwFCyAAKAIQIQICQCABLQAsIgNFBEAgAkUNAUHIpMAAQRAgAhDGAUUNAUEBDAYLIAJFDQBB2KTAAEEZIAIQxgFFDQBBAQwFCyAAIAM6AAQgAEEANgIAQQAMBAsgBUUNAQsCQCAAKAIQIgJFDQBBpaXAAEEHIAIQxgFFDQBBAQwDCyADRQ0BCwJAIAAoAhAiAkUNAEGspcAAQQggAhDGAUUNAEEBDAILIAFBATsBJCABIAQ2AiAgAUEANgIcIAFBAToAGCABQd8ANgIUIAEgBDYCECABQQA2AgwgASAENgIIIAEgAzYCBCABQd8ANgIAIAFBKGogARAuAn8gASgCKEUEQAJAIAEtACUNACABQQE6ACUCQCABLQAkQQFGBEAgASgCICEFIAEoAhwhBAwBCyABKAIgIgUgASgCHCIERg0BCyABKAIEIARqIQMgBSAEawwCC0G0pcAAELMBAAsgASgCHCEEIAEgASgCMDYCHCADIARqIQMgASgCLCAEawshBAJAIAIEQCADIAQgAhDGAQ0BCyABQcgAaiABQSBqKQIANwMAIAFBQGsgAUEYaikCADcDACABQThqIAFBEGopAgA3AwAgAUEwaiABQQhqKQIANwMAIAEgASkCADcDKAJAIAEtAE0NACACIQMDQCABKAIsIQUgAUHUAGogAUEoahAuAn8gASgCVEUEQCABLQBNDQMgAUEBOgBNAkAgAS0ATEEBRgRAIAEoAkghBSABKAJEIQQMAQsgASgCSCIFIAEoAkQiBEYNBAsgASgCLCAEaiEGIAUgBGsMAQsgASgCRCEEIAEgASgCXDYCRCAEIAVqIQYgASgCWCAEawshBAJAIANFBEBBACEDDAELQb2hwABBASADEMYBDQMgACgCECICRQRAQQAhAkEAIQMMAQsgAiEDIAYgBCACEMYBDQMLIAEtAE1FDQALCyACRQ0BQcSlwABBAiACEMYBRQ0BC0EBDAELAkAgACgCECICRQ0AQcalwABBAyACEMYBRQ0AQQEMAQsCQAJAAkAgACgCACIDRQRAQQAhAwwBC0EAIQIDQAJAIAAoAggiBCAAKAIETw0AIAMgBGotAABBxQBHDQAgACAEQQFqNgIIDAILAkAgAkUNACAAKAIQIgNFDQBB+aTAAEECIAMQxgFFDQBBAQwFCyAAEBkNAiACQQFrIQIgACgCACIDDQALQQAhAwsgACgCECIEBEBBAUH5nsAAQQEgBBDGAQ0DGiAAKAIAIQMLIANFDQEgACgCCCICIAAoAgRPDQEgAiADai0AAEH1AEcNASAAIAJBAWo2AghBAAwCC0EBDAELAkAgACgCECICRQ0AQcmlwABBBCACEMYBRQ0AQQEMAQsgABAZCyABQeAAaiQAC9AaAgl/An4jAEEgayIGJAACQAJAAkACQAJAAkACQAJAAkAgACgCACIDBEAgACgCCCICIAAoAgRPDQMgACACQQFqNgIIIAIgA2otAAAiAUHhAGsiBEH/AXEiBUEZS0G/9/MdIAV2QQFxRXINAiAAKAIQIgANAUEAIQMMCQsgACgCECIARQRAQQAhAwwJC0HxpMAAQQEgABDGASEDDAgLIARB/wFxQQJ0IgFB4KjAAGooAgAgAUH4p8AAaigCACAAEMYBIQMMBwsgACAAKAIMQQFqIgQ2AgwgBEH0A00EQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUHBAGsOFAIGDQUNBA0NDQ0NDQ0NAQEAAAIDDQsgACgCECICBEBBASEDQf2ewABBASACEMYBDRUgACgCACIDRQ0SCyAAKAIIIgIgACgCBE8NESACIANqLQAAQcwARw0RIAAgAkEBajYCCCAGQRBqIAAQOSAGLQAQDQcgBikDGCIKUEUNBgwRCyAAKAIQIgIEQEEBIQNB/p7AAEEBIAIQxgENFAsgACgCECEDIAFB0ABHDQcgA0UNCEGWpcAAQQYgAxDGAUUNCAwSCyAAKAIQIgIEQEEBIQNB+6TAAEEBIAIQxgENEwtBASEDIAAQGQ0SIAFBwQBGBEAgACgCECIBBEBBnKXAAEECIAEQxgENFAsgAEEBEBMNEwsgACgCECIBRQ0QQfykwABBASABEMYBRQ0QDBILIAAoAhAiAQRAQQEhA0H6nsAAQQEgARDGAQ0SCyAGQQhqIQNBACEBAn8CQCAAKAIAIgJFDQADQAJAIAAoAggiBCAAKAIETw0AIAIgBGotAABBxQBHDQAgACAEQQFqNgIIDAILAkAgAUUNACAAKAIQIgJFDQBB+aTAAEECIAIQxgFFDQBBAQwDC0EBIAAQGQ0CGiABQQFqIQEgACgCACICDQALC0EACyECIAMgATYCBCADIAI2AgAgBigCCA0QIAYoAgxBAUYEQCAAKAIQIgFFDRBBASEDQfiewABBASABEMYBDRILIAAoAhAiAUUND0EBIQNB+Z7AAEEBIAEQxgFFDQ8MEQtBACEBIwBBEGsiAyQAAkACQAJAAkAgACgCACICBEAgACgCCCIEIAAoAgQiBU8NAyACIARqLQAAQccARw0DIAAgBEEBaiIBNgIIIAEgBU8NASABIAJqLQAAQd8ARw0BIAAgBEECajYCCAwCCyAAKAIQIgJFDQNB8aTAAEEBIAIQxgEhAQwDCwNAAkACQAJAAkAgASAFSQRAIAEgAmotAABB3wBGDQELIAEgBUYNAyABIAJqLQAAIgRBMGsiB0H/AXFBCkkNAiAEQeEAa0H/AXFBGkkNASAEQcEAa0H/AXFBGk8NAyAEQR1rIQcMAgsgACABQQFqNgIIIApCfVYNAiAKQgF8IQoMBAsgBEHXAGshBwsgACABQQFqIgE2AgggAyAKEGQgAykDCEIAUg0AIAMpAwAiCyAHrUL/AYN8IgogC1oNAQsLAkAgACgCECIBRQ0AQcikwABBECABEMYBRQ0AQQEhAQwDC0EAIQEgAEEAOgAEIABBADYCAAwCCyAKQgF8IQsLAkAgACgCECIBBEAgC1ANAUHzpMAAQQQgARDGAQRAQQEhAQwDCyAAIAAoAhRBAWo2AhQgAEIBEFYEQEEBIQEMAwtCASEKA0AgCiALUQRAIAAoAhAiAkUNA0EBIQFB96TAAEECIAIQxgFFDQMMBAsCQCAKUA0AIAAoAhAiAUUNAEH5pMAAQQIgARDGAUUNAEEBIQEMBAtBASEBIAAgACgCFEEBajYCFCAKQgF8IQogAEIBEFZFDQALDAILIAAQGCEBDAELIAAQGCEBIAAgACgCFCALp2s2AhQLIANBEGokACABRQ0ODA8LIAAoAhAiAQRAQZ6lwABBBCABEMYBDQ8LQQEhA0EAIQEjAEEQayIEJAACQAJAAkACQCAAKAIAIgIEQCAAKAIIIgUgACgCBCIHTw0DIAIgBWotAABBxwBHDQMgACAFQQFqIgE2AgggASAHTw0BIAEgAmotAABB3wBHDQEgACAFQQJqNgIIDAILIAAoAhAiAkUNA0HxpMAAQQEgAhDGASEBDAMLA0ACQAJAAkACQCABIAdJBEAgASACai0AAEHfAEYNAQsgASAHRg0DIAEgAmotAAAiBUEwayIIQf8BcUEKSQ0CIAVB4QBrQf8BcUEaSQ0BIAVBwQBrQf8BcUEaTw0DIAVBHWshCAwCCyAAIAFBAWo2AgggCkJ9Vg0CIApCAXwhCgwECyAFQdcAayEICyAAIAFBAWoiATYCCCAEIAoQZCAEKQMIQgBSDQAgBCkDACILIAitQv8Bg3wiCiALWg0BCwsCQCAAKAIQIgFFDQBByKTAAEEQIAEQxgFFDQBBASEBDAMLQQAhASAAQQA6AAQgAEEANgIADAILIApCAXwhCwsgACgCECIBRQRAQQAhAQNAAkAgACgCCCIFIAAoAgRPDQAgAiAFai0AAEHFAEcNACAAIAVBAWo2AghBACEBDAMLAkAgAUUNACAAKAIQIgJFDQBBoqXAAEEDIAIQxgFFDQBBASEBDAMLIAAQJwRAQQEhAQwDCyABQQFrIQEgACgCACICDQALQQAhAQwBCwJAIAtQDQBB86TAAEEEIAEQxgEEQEEBIQEMAgsgACAAKAIUQQFqNgIUIABCARBWBEBBASEBDAILQgEhCgNAIAogC1EEQCAAKAIQIgJFDQJBASEBQfekwABBAiACEMYBRQ0CDAMLAkAgClANACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBASEBDAMLQQEhASAAIAAoAhRBAWo2AhQgCkIBfCEKIABCARBWRQ0ACwwBCwJ/QQAgACgCACICRQ0AGkEAIQECQANAAkAgACgCCCIFIAAoAgRPDQAgAiAFai0AAEHFAEcNACAAIAVBAWo2AghBAAwDCwJAIAFFDQAgACgCECICRQ0AQaKlwABBAyACEMYBDQILIAAQJw0BIAFBAWshASAAKAIAIgINAAtBAAwBC0EBCyEBIAAgACgCFCALp2s2AhQLIARBEGokACABDQ8gACgCACICRQ0FIAAoAggiASAAKAIETw0FIAEgAmotAABBzABHDQUgACABQQFqNgIIIAZBEGogABA5IAYtABANBiAGKQMYIgpQDQ0gACgCECIBBEBBoqXAAEEDIAEQxgENDwsgACAKEFZFDQ0MDgtBACEBIwBBIGsiAiQAAkACQAJAAkACfgJAAkACQCAAKAIAIgUEQCAAKAIIIgMgACgCBCIHSQRAIAMgBWotAABB3wBGDQMLIAMgByADIAdLGyEJIAMhAQNAIAEgB0kEQCABIAVqLQAAQd8ARg0DCyABIAlGDQYCQCABIAVqLQAAIgRBMGsiCEH/AXFBCkkNACAEQeEAa0H/AXFBGk8EQCAEQcEAa0H/AXFBGk8NCCAEQR1rIQgMAQsgBEHXAGshCAsgACABQQFqIgE2AgggAiAKEGQgAikDCEIAUg0GIAIpAwAiCyAIrUL/AYN8IgogC1oNAAsMBQsgACgCECIDRQ0HQfGkwABBASADEMYBIQEMBwsgACABQQFqNgIIIApCf1INAQwDCyAAIANBAWo2AghCAAwBCyAKQgF8CyEKIAogA0EBa61aDQBBASEBIAAoAhAhAyAAKAIMQQFqIgRB9ANLDQEgA0UEQEEAIQEMBAsgAkEYaiIFIABBCGoiAykCADcDACAAIAQ2AgwgAyAKPgIAIAIgACkCADcDECAAEBkhASADIAUpAwA3AgAgACACKQMQNwIADAMLQQAhASAAKAIQIgNFDQFByKTAAEEQIAMQxgFFDQFBASEBDAILIANFDQBB2KTAAEEZIAMQxgENAQsgACABOgAEQQAhASAAQQA2AgALIAJBIGokACABDQ0MDAsgACAKEFYNDCAAKAIQIgJFDQpBASEDQZGlwABBASACEMYBRQ0KDA0LIAAoAhAhAQJAIAYtABEiA0UEQCABRQ0BQcikwABBECABEMYBRQ0BDA0LIAFFDQBB2KTAAEEZIAEQxgENDAsgACADOgAEDAgLIANFDQBBkqXAAEEEIAMQxgENCgsgABAZRQ0IDAkLIAAoAhAiAUUNBEHIpMAAQRAgARDGAQ0JDAQLIAAoAhAhAQJAIAYtABEiA0UEQCABRQ0BQcikwABBECABEMYBRQ0BDAkLIAFFDQBB2KTAAEEZIAEQxgENCAsgACADOgAEDAQLIAAgAjYCCCAAQQAQEkUNBQwGCyAAKAIQIgEEQEHYpMAAQRkgARDGAQ0GCyAAQQE6AAQMAgsgACgCECIBRQ0AQcikwABBECABEMYBDQQLQQAhAyAAQQA6AAQgAEEANgIADAQLQQAhAyAAQQA2AgAMAwsCQCABQdIARg0AIAAoAhAiAUUNAEGSpcAAQQQgARDGAQ0CCyAAEBkNAQtBACEDIAAoAgBFDQEgACAAKAIMQQFrNgIMDAELQQEhAwsgBkEgaiQAIAML9gcCFH8BfgJAAkACQAJAAkAgASgCAEUEQCABLQAODQEgASABLQAMIgZBAXM6AAwgASgCNCEDIAEoAjAhBAJAIAEoAgQiAkUNACACIANJBEAgAiAEaiwAAEG/f0oNAQwHCyACIANHDQYLAkAgAiADRwRAAn8gAiAEaiIELAAAIgNBAE4EQCADQf8BcQwBCyAELQABQT9xIQcgA0EfcSEFIAVBBnQgB3IgA0FfTQ0AGiAELQACQT9xIAdBBnRyIQcgByAFQQx0ciADQXBJDQAaIAVBEnRBgIDwAHEgBC0AA0E/cSAHQQZ0cnILIQNBASEFIAZBAXENAQJAIANBgAFJDQBBAiEFIANBgBBJDQBBA0EEIANBgIAESRshBQsgACACNgIEIABBATYCACAAIAIgBWoiADYCCCABIAA2AgQPCyAGQQFxRQ0FCyAAIAI2AgggACACNgIEIABBADYCAA8LIAEoAhwiBiABKAI0IgRGDQIgASgCMCEKAkAgBCIDIAYgASgCPCIIQQFrIhBqIgJNDQAgASgCOCENIAYgCmohESAGIAhqIQcgBiABKAIQIgtrIRIgASgCGCIDIAZqIQ4gCCADayETIAEpAwghFiABKAIkIg9Bf0YhCSAPIQUgBiEDA0AgAyAGRw0BAkACQCAWIAIgCmoxAACIp0EBcUUEQCABIAc2AhwgByEDIAkNAkEAIQIMAQsgCyALIAUgBSALSRsgCRsiAyAIIAMgCEsbIQwgAyECAkACQAJAA0AgAiAMRgRAQQAgBSAJGyEMIAshAgNAIAIgDE0EQCABIAc2AhwgD0F/RwRAIAFBADYCJAsgACAHNgIIIAAgBjYCBCAAQQA2AgAPCyACQQFrIgIgCE8NBSACIAZqIgMgBE8NAyACIA1qLQAAIAMgCmotAABGDQALIAEgDjYCHCATIQIgDiEDIAlFDQUMBgsgAiAGaiAETw0CIAIgEWohFCACIA1qIAJBAWohAi0AACAULQAARg0ACyACIBJqIQMgCQ0EQQAhAgwDCyADIARBxJrAABBpAAsgBCADIAZqIgAgACAESRsgBEHUmsAAEGkACyACIAhBtJrAABBpAAsgASACNgIkIAIhBQsgAyAQaiICIARJDQALIAQhAwtBACEFIANFDQEgAyECA0ACQCACIARJBEAgAiAKaiwAAEG/f0wNASACIQUMBAsgAiAERw0AIAQhBQwDCyACQQFqIgINAAsMAQsgAEECNgIADwsgACAFNgIIIAAgBjYCBCAAQQE2AgAgASAFIAMgAyAFSRs2AhwPCyAAQQI2AgAPCyAAQQI2AgAgAUEBOgAODwsgBCADIAIgA0GcnMAAEJ0BAAvGBgEIfwJAAkAgASAAQQNqQXxxIgIgAGsiCEkNACABIAhrIgZBBEkNACAGQQNxIQdBACEBAkAgACACRiIJDQACQCAAIAJrIgRBfEsEQEEAIQIMAQtBACECA0AgASAAIAJqIgMsAABBv39KaiADQQFqLAAAQb9/SmogA0ECaiwAAEG/f0pqIANBA2osAABBv39KaiEBIAJBBGoiAg0ACwsgCQ0AIAAgAmohAwNAIAEgAywAAEG/f0pqIQEgA0EBaiEDIARBAWoiBA0ACwsgACAIaiECAkAgB0UNACACIAZBfHFqIgAsAABBv39KIQUgB0EBRg0AIAUgACwAAUG/f0pqIQUgB0ECRg0AIAUgACwAAkG/f0pqIQULIAZBAnYhBiABIAVqIQQDQCACIQAgBkUNAkHAASAGIAZBwAFPGyIFQQNxIQcgBUECdCEIQQAhAyAGQQRPBEAgACAIQfAHcWohCSAAIQEDQCABKAIAIgJBf3NBB3YgAkEGdnJBgYKECHEgA2ogASgCBCICQX9zQQd2IAJBBnZyQYGChAhxaiABKAIIIgJBf3NBB3YgAkEGdnJBgYKECHFqIAEoAgwiAkF/c0EHdiACQQZ2ckGBgoQIcWohAyABQRBqIgEgCUcNAAsLIAYgBWshBiAAIAhqIQIgA0EIdkH/gfwHcSADQf+B/AdxakGBgARsQRB2IARqIQQgB0UNAAsCfyAAIAVB/AFxQQJ0aiIAKAIAIgFBf3NBB3YgAUEGdnJBgYKECHEiASAHQQFGDQAaIAEgACgCBCIBQX9zQQd2IAFBBnZyQYGChAhxaiIBIAdBAkYNABogACgCCCIAQX9zQQd2IABBBnZyQYGChAhxIAFqCyIBQQh2Qf+BHHEgAUH/gfwHcWpBgYAEbEEQdiAEag8LIAFFBEBBAA8LIAFBA3EhAgJAIAFBBEkEQAwBCyABQXxxIQUDQCAEIAAgA2oiASwAAEG/f0pqIAFBAWosAABBv39KaiABQQJqLAAAQb9/SmogAUEDaiwAAEG/f0pqIQQgBSADQQRqIgNHDQALCyACRQ0AIAAgA2ohAQNAIAQgASwAAEG/f0pqIQQgAUEBaiEBIAJBAWsiAg0ACwsgBAvNBgEOfyMAQRBrIgYkAEEBIQwCQCACKAIUIglBIiACKAIYIg0oAhAiDhEAAA0AAkAgAUUEQEEAIQIMAQtBACABayEPIAAhByABIQMCQAJ/AkACQANAIAMgB2ohEEEAIQICQANAIAIgB2oiCi0AACIFQf8Aa0H/AXFBoQFJIAVBIkZyIAVB3ABGcg0BIAMgAkEBaiICRw0ACyADIAhqDAQLIApBAWohBwJAIAosAAAiC0EATgRAIAtB/wFxIQMMAQsgBy0AAEE/cSEDIAtBH3EhBSAKQQJqIQcgC0FfTQRAIAVBBnQgA3IhAwwBCyAHLQAAQT9xIANBBnRyIQMgCkEDaiEHIAtBcEkEQCADIAVBDHRyIQMMAQsgBUESdEGAgPAAcSAHLQAAQT9xIANBBnRyciEDIApBBGohBwsgBkEEaiADQYGABBAiAkACQCAGLQAEQYABRg0AIAYtAA8gBi0ADmtB/wFxQQFGDQAgBCACIAhqIgVLDQMCQCAERQ0AIAEgBEsEQCAAIARqLAAAQb9/Sg0BDAULIAEgBEcNBAsCQCAFRQ0AIAEgBUsEQCAAIAhqIAJqLAAAQb9/TA0FDAELIAUgD2oNBAsgCSAAIARqIAggBGsgAmogDSgCDCIFEQEADQECQCAGLQAEQYABRgRAIAkgBigCCCAOEQAARQ0BDAMLIAkgBi0ADiIEIAZBBGpqIAYtAA8gBGsgBREBAA0CCwJ/QQEgA0GAAUkNABpBAiADQYAQSQ0AGkEDQQQgA0GAgARJGwsgCGogAmohBAsCf0EBIANBgAFJDQAaQQIgA0GAEEkNABpBA0EEIANBgIAESRsLIAhqIgUgAmohCCAQIAdrIgNFDQMMAQsLDAULIAAgASAEIAVBhLHAABCdAQALIAIgBWoLIgIgBEkNAEEAIQMCQCAERQ0AIAEgBEsEQCAEIgMgAGosAABBv39MDQIMAQsgBCIDIAFHDQELIAJFBEBBACECDAILIAEgAksEQCADIQQgACACaiwAAEG/f0oNAgwBCyADIQQgASACRg0BCyAAIAEgBCACQZSxwAAQnQEACyAJIAAgA2ogAiADayANKAIMEQEADQAgCUEiIA4RAAAhDAsgBkEQaiQAIAwLlQYBCH8jAEEwayIBJAACQAJ/AkACQAJAIAAoAgAiBQRAIAAoAggiBCAEIAAoAgQiByAEIAdLG2shCCAFIQMDQCACIAhqRQ0DIAAgAiAEakEBajYCCCACQQFqIQIgAyAEaiADQQFqIQMtAAAiBkEwa0H/AXFBCkkgBkHhAGtB/wFxQQZJcg0ACyAGQd8ARw0CIAIgBGpBAWshBgJAIAQEQCAEIAdJBEAgBiAHSw0IIAQgBWosAABBQEgNCAwCCyAGIAdNDQEMBwsgBiAHSw0GCyACQQFrIgJBAXFFBEAgAUKAgICAIDcCGCABIAMgBGpBAWsiAzYCFCABIAI2AhAgASAEIAVqIgU2AgwDQCABQQxqEBciBEGAgMQASQ0ACyAEQYGAxABGDQILIAAoAhAiA0UNA0HIpMAAQRAgAxDGAUUNA0EBDAQLQQAgACgCECIARQ0DGkHxpMAAQQEgABDGAQwDC0EAIAAoAhAiAEUNAhpBASAAQSIQnAENAhogAUKAgICAIDcCGCABIAM2AhQgASACNgIQIAEgBTYCDCABQQxqEBciAkGBgMQARwRAIAFBKGohBANAAkACQAJAAkAgAkGAgMQARwRAIAJBJ0YNASABQSBqIAIQIyABLQAgQYABRw0CQYABIQMDQAJAIANBgAFHBEAgAS0AKiIFIAEtACtPDQcgASAFQQFqOgAqIAFBIGogBWotAAAhAgwBC0EAIQMgBEEANgIAIAEoAiQhAiABQgA3AyALIAAgAhCcAUUNAAsMAwtBhJvAAEErIAFBIGpB9JrAAEHUmcAAEGUACyAAQScQnAFFDQIMAQsgAS0AKiICIAEtACsiAyACIANLGyEDA0AgAiADRg0CIAFBIGogAmohBSACQQFqIQIgACAFLQAAEJwBRQ0ACwtBAQwFCyABQQxqEBciAkGBgMQARw0ACwsgAEEiEJwBDAILIAAoAhAiA0UNAEHIpMAAQRAgAxDGAUUNAEEBDAELIABBADoABCAAQQA2AgBBAAsgAUEwaiQADwsgBSAHIAQgBkH4o8AAEJ0BAAupBQEHfwJAIAAoAghBAXFFIgQgACgCACIJRXFFBEACQCAEDQAgASACaiEHAkAgACgCDCIGRQRAIAEhBAwBCyABIQQDQCAEIgMgB0YNAgJ/IANBAWogAywAACIIQQBODQAaIANBAmogCEFgSQ0AGiADQQNqIAhBcEkNABogA0EEagsiBCADayAFaiEFIAZBAWsiBg0ACwsgBCAHRg0AIAQsAAAaIAUgAgJ/AkAgBUUNACACIAVLBEAgASAFaiwAAEG/f0oNAUEADAILIAIgBUYNAEEADAELIAELIgMbIQIgAyABIAMbIQELIAlFDQEgACgCBCEHAkAgAkEQTwRAIAEgAhAbIQMMAQsgAkUEQEEAIQMMAQsgAkEDcSEGAkAgAkEESQRAQQAhA0EAIQUMAQsgAkEMcSEIQQAhA0EAIQUDQCADIAEgBWoiBCwAAEG/f0pqIARBAWosAABBv39KaiAEQQJqLAAAQb9/SmogBEEDaiwAAEG/f0pqIQMgCCAFQQRqIgVHDQALCyAGRQ0AIAEgBWohBANAIAMgBCwAAEG/f0pqIQMgBEEBaiEEIAZBAWsiBg0ACwsCQCADIAdJBEAgByADayEEQQAhAwJAAkACQCAALQAgQQFrDgIAAQILIAQhA0EAIQQMAQsgBEEBdiEDIARBAWpBAXYhBAsgA0EBaiEDIAAoAhAhBiAAKAIYIQUgACgCFCEAA0AgA0EBayIDRQ0CIAAgBiAFKAIQEQAARQ0AC0EBDwsMAgsgACABIAIgBSgCDBEBAARAQQEPC0EAIQMDQCADIARGBEBBAA8LIANBAWohAyAAIAYgBSgCEBEAAEUNAAsgA0EBayAESQ8LIAAoAhQgASACIAAoAhgoAgwRAQAPCyAAKAIUIAEgAiAAKAIYKAIMEQEAC7gFAgh/AX4CQCABKAIIIgIgASgCBCIETw0AIAEoAgAgAmotAABB9QBHDQBBASEHIAEgAkEBaiICNgIICwJAAkAgAiAETw0BIAEoAgAiBSACai0AAEEwayIDQf8BcSIGQQlLDQEgASACQQFqIgI2AgggBkUEQEEAIQMMAQsgAiAEIAIgBEsbIQYgA0H/AXEhAwNAIAIgBkYNASACIAVqLQAAQTBrQf8BcSIIQQlLDQEgASACQQFqIgI2AgggA61CCn4iCkIgiFAEQCAIIAqnIghqIgMgCE8NAQsLDAELAkAgAiAETw0AIAIgBWotAABB3wBHDQAgASACQQFqIgI2AggLAkACQAJAAkAgAiACIANqIgZNBEAgASAGNgIIIAQgBkkNBSACRQ0CIAIgBEkNAQwCCwwECyACIAVqLAAAQb9/TA0BCyAGRSAEIAZNckUEQCAFIAZqLAAAQb9/TA0BCyACIAVqIQQgBw0BIABCATcCCCAAIAM2AgQgACAENgIADwsgBSAEIAIgBkGIpMAAEJ0BAAtBACEHQQAgA2shASAFIAZqIgZBAWshCEEAIQICQAJAAn8DQCABIAJGBEAgBCEBQQEMAgsgAiAIaiACQQFrIgUhAi0AAEHfAEcNAAsgAyAFaiEHAkACQEEAIANrIAVGDQAgAyAHSwRAIAUgBmosAABBv39KDQEMBQsgBQ0EQQAhAiADQX9zIAVGDQELIAMgB0EBaiIBSwRAIAUgBmpBAWosAABBv39MDQMgASECDAELIAMhAiAFQX9HDQILIAIgBGohASADIAJrIQMgBAshAiADRQRADAMLIAAgAzYCDCAAIAE2AgggACAHNgIEIAAgAjYCAA8LIAQgAyABIANBqKTAABCdAQALIAQgA0EAIAdBmKTAABCdAQALIABBADYCACAAQQA6AAQL4QUCB38CfiMAQSBrIgQkAAJ/AkACQCAAKAIAIgNFDQAgACgCCCICIAAoAgQiBU8NACACIANqIgEtAABBwgBGBEAgACACQQFqIgE2AggCQAJAAkACQAJAIAKtAn4CQCABIAVJBEAgASADai0AAEHfAEYNAQsgASAFIAEgBUsbIQcDQAJAIAEgBUkEQCABIANqLQAAQd8ARg0BCyABIAdGDQQCQCABIANqLQAAIgJBMGsiBkH/AXFBCkkNACACQeEAa0H/AXFBGk8EQCACQcEAa0H/AXFBGk8NBiACQR1rIQYMAQsgAkHXAGshBgsgACABQQFqIgE2AgggBCAIEGQgBCkDCEIAUg0EIAQpAwAiCSAGrUL/AYN8IgggCVoNAQwECwsgACABQQFqNgIIIAhCf1ENAiAIQgF8DAELIAAgAkECajYCCEIACyIIWA0AQQEhASAAKAIQIQIgACgCDEEBaiIDQfQDSw0BIAJFDQQgBEEYaiICIABBCGoiASkCADcDACAAIAM2AgwgASAIPgIAIAQgACkCADcDECAAECAgASACKQMANwIAIAAgBCkDEDcCAEH/AXEMCAtBACEBIAAoAhAiAkUNAkHIpMAAQRAgAhDGAQ0BDAILIAJFDQFB2KTAAEEZIAIQxgFFDQELQQIMBQsgACABOgAEIABBADYCAAtBAAwDCyABLQAAQckARw0AIAAgAkEBajYCCCAAQQAQEkUNAUECDAILQQJBACAAQQAQEhsMAQsCQCAAKAIQIgFFDQBB/J7AAEEBIAEQxgFFDQBBAgwBC0EBIAAoAgAiAUUNABpBACECAkADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIQQEMAwsCQCACRQ0AIAAoAhAiA0UNAEECQfmkwABBAiADEMYBDQMaCyAAEDENASACQQFrIQIgACgCACIBDQALQQEMAQtBAgsgBEEgaiQAC78FAQh/QStBgIDEACAAKAIcIghBAXEiBhshDCAEIAZqIQYCQCAIQQRxRQRAQQAhAQwBCwJAIAJBEE8EQCABIAIQGyEFDAELIAJFBEAMAQsgAkEDcSEJAkAgAkEESQRADAELIAJBDHEhCgNAIAUgASAHaiILLAAAQb9/SmogC0EBaiwAAEG/f0pqIAtBAmosAABBv39KaiALQQNqLAAAQb9/SmohBSAKIAdBBGoiB0cNAAsLIAlFDQAgASAHaiEHA0AgBSAHLAAAQb9/SmohBSAHQQFqIQcgCUEBayIJDQALCyAFIAZqIQYLIAAoAgBFBEAgACgCFCIGIAAoAhgiACAMIAEgAhB9BEBBAQ8LIAYgAyAEIAAoAgwRAQAPCwJAAkACQCAGIAAoAgQiB08EQCAAKAIUIgYgACgCGCIAIAwgASACEH1FDQFBAQ8LIAhBCHFFDQEgACgCECEIIABBMDYCECAALQAgIQpBASEFIABBAToAICAAKAIUIgkgACgCGCILIAwgASACEH0NAiAHIAZrQQFqIQUCQANAIAVBAWsiBUUNASAJQTAgCygCEBEAAEUNAAtBAQ8LIAkgAyAEIAsoAgwRAQAEQEEBDwsgACAKOgAgIAAgCDYCEEEADwsgBiADIAQgACgCDBEBACEFDAELIAcgBmshBgJAAkACQCAALQAgIgVBAWsOAwABAAILIAYhBUEAIQYMAQsgBkEBdiEFIAZBAWpBAXYhBgsgBUEBaiEFIAAoAhAhCiAAKAIYIQggACgCFCEAAkADQCAFQQFrIgVFDQEgACAKIAgoAhARAABFDQALQQEPC0EBIQUgACAIIAwgASACEH0NACAAIAMgBCAIKAIMEQEADQBBACEFA0AgBSAGRgRAQQAPCyAFQQFqIQUgACAKIAgoAhARAABFDQALIAVBAWsgBkkPCyAFC84GAQN/IwBBIGsiAyQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEOKAYBAQEBAQEBAQIEAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEIAQEBAQcACyABQdwARg0ECyACQQFxRSABQYAGSXINByABEDJFDQcgA0EAOgAKIANBADsBCCADIAFBFHZB9qvAAGotAAA6AAsgAyABQQR2QQ9xQfarwABqLQAAOgAPIAMgAUEIdkEPcUH2q8AAai0AADoADiADIAFBDHZBD3FB9qvAAGotAAA6AA0gAyABQRB2QQ9xQfarwABqLQAAOgAMIAFBAXJnQQJ2IgIgA0EIaiIFaiIEQfsAOgAAIARBAWtB9QA6AAAgBSACQQJrIgJqQdwAOgAAIANBEGoiBCABQQ9xQfarwABqLQAAOgAAIABBCjoACyAAIAI6AAogACADKQIINwIAIANB/QA6ABEgAEEIaiAELwEAOwEADAkLIABBgAQ7AQogAEIANwECIABB3OgBOwEADAgLIABBgAQ7AQogAEIANwECIABB3OQBOwEADAcLIABBgAQ7AQogAEIANwECIABB3NwBOwEADAYLIABBgAQ7AQogAEIANwECIABB3LgBOwEADAULIABBgAQ7AQogAEIANwECIABB3OAAOwEADAQLIAJBgAJxRQ0BIABBgAQ7AQogAEIANwECIABB3M4AOwEADAMLIAJBgIAEcQ0BCyABEFNFBEAgA0EAOgAWIANBADsBFCADIAFBFHZB9qvAAGotAAA6ABcgAyABQQR2QQ9xQfarwABqLQAAOgAbIAMgAUEIdkEPcUH2q8AAai0AADoAGiADIAFBDHZBD3FB9qvAAGotAAA6ABkgAyABQRB2QQ9xQfarwABqLQAAOgAYIAFBAXJnQQJ2IgIgA0EUaiIFaiIEQfsAOgAAIARBAWtB9QA6AAAgBSACQQJrIgJqQdwAOgAAIANBHGoiBCABQQ9xQfarwABqLQAAOgAAIABBCjoACyAAIAI6AAogACADKQIUNwIAIANB/QA6AB0gAEEIaiAELwEAOwEADAILIAAgATYCBCAAQYABOgAADAELIABBgAQ7AQogAEIANwECIABB3MQAOwEACyADQSBqJAALsgYBBH8jAEEgayICJAACQAJAAkACQAJAAkACQAJAAkACQCABDigABwcHBwcHBwcBAwcHAgcHBwcHBwcHBwcHBwcHBwcHBwcHBAcHBwcFBgsgAEGABDsBCiAAQgA3AQIgAEHc4AA7AQAMCAsgAEGABDsBCiAAQgA3AQIgAEHc6AE7AQAMBwsgAEGABDsBCiAAQgA3AQIgAEHc5AE7AQAMBgsgAEGABDsBCiAAQgA3AQIgAEHc3AE7AQAMBQsgAEGABDsBCiAAQgA3AQIgAEHcxAA7AQAMBAsgAEGABDsBCiAAQgA3AQIgAEHczgA7AQAMAwsgAUHcAEYNAQsCQCABQf8FTQ0AIAEQMkUNACACQQA6AAogAkEAOwEIIAIgAUEUdkHkmsAAai0AADoACyACIAFBBHZBD3FB5JrAAGotAAA6AA8gAiABQQh2QQ9xQeSawABqLQAAOgAOIAIgAUEMdkEPcUHkmsAAai0AADoADSACIAFBEHZBD3FB5JrAAGotAAA6AAwgAUEBcmdBAnYiAyACQQhqIgVqIgRB+wA6AAAgBEEBa0H1ADoAACAFIANBAmsiA2pB3AA6AAAgAkEQaiIEIAFBD3FB5JrAAGotAAA6AAAgAEEKOgALIAAgAzoACiAAIAIpAgg3AgAgAkH9ADoAESAAQQhqIAQvAQA7AQAMAgsgARBTRQRAIAJBADoAFiACQQA7ARQgAiABQRR2QeSawABqLQAAOgAXIAIgAUEEdkEPcUHkmsAAai0AADoAGyACIAFBCHZBD3FB5JrAAGotAAA6ABogAiABQQx2QQ9xQeSawABqLQAAOgAZIAIgAUEQdkEPcUHkmsAAai0AADoAGCABQQFyZ0ECdiIDIAJBFGoiBWoiBEH7ADoAACAEQQFrQfUAOgAAIAUgA0ECayIDakHcADoAACACQRxqIgQgAUEPcUHkmsAAai0AADoAACAAQQo6AAsgACADOgAKIAAgAikCFDcCACACQf0AOgAdIABBCGogBC8BADsBAAwCCyAAIAE2AgQgAEGAAToAAAwBCyAAQYAEOwEKIABCADcBAiAAQdy4ATsBAAsgAkEgaiQAC84FAgZ/An4CQCACRQ0AIAJBB2siA0EAIAIgA08bIQcgAUEDakF8cSABayEIQQAhAwNAAkACQAJAIAEgA2otAAAiBcAiBkEATgRAIAggA2tBA3ENASADIAdPDQIDQCABIANqIgQoAgQgBCgCAHJBgIGChHhxDQMgA0EIaiIDIAdJDQALDAILQoCAgICAICEKQoCAgIAQIQkCQAJAAn4CQAJAAkACQAJAAkACQAJAAkAgBUHgs8AAai0AAEECaw4DAAECCgsgA0EBaiIEIAJJDQJCACEKQgAhCQwJC0IAIQogA0EBaiIEIAJJDQJCACEJDAgLQgAhCiADQQFqIgQgAkkNAkIAIQkMBwsgASAEaiwAAEG/f0oNBgwHCyABIARqLAAAIQQCQAJAIAVB4AFrIgUEQCAFQQ1GBEAMAgUMAwsACyAEQWBxQaB/Rg0EDAMLIARBn39KDQIMAwsgBkEfakH/AXFBDE8EQCAGQX5xQW5HDQIgBEFASA0DDAILIARBQEgNAgwBCyABIARqLAAAIQQCQAJAAkACQCAFQfABaw4FAQAAAAIACyAGQQ9qQf8BcUECSyAEQUBOcg0DDAILIARB8ABqQf8BcUEwTw0CDAELIARBj39KDQELIAIgA0ECaiIETQRAQgAhCQwFCyABIARqLAAAQb9/Sg0CQgAhCSADQQNqIgQgAk8NBCABIARqLAAAQb9/TA0FQoCAgICA4AAMAwtCgICAgIAgDAILQgAhCSADQQJqIgQgAk8NAiABIARqLAAAQb9/TA0DC0KAgICAgMAACyEKQoCAgIAQIQkLIAAgCiADrYQgCYQ3AgQgAEEBNgIADwsgBEEBaiEDDAILIANBAWohAwwBCyACIANNDQADQCABIANqLAAAQQBIDQEgAiADQQFqIgNHDQALDAILIAIgA0sNAAsLIAAgAjYCCCAAIAE2AgQgAEEANgIAC/4FAQV/IABBCGsiASAAQQRrKAIAIgNBeHEiAGohAgJAAkAgA0EBcQ0AIANBAnFFDQEgASgCACIDIABqIQAgASADayIBQcjSwAAoAgBGBEAgAigCBEEDcUEDRw0BQcDSwAAgADYCACACIAIoAgRBfnE2AgQgASAAQQFyNgIEIAIgADYCAA8LIAEgAxA7CwJAAkACQAJAAkAgAigCBCIDQQJxRQRAIAJBzNLAACgCAEYNAiACQcjSwAAoAgBGDQMgAiADQXhxIgIQOyABIAAgAmoiAEEBcjYCBCAAIAFqIAA2AgAgAUHI0sAAKAIARw0BQcDSwAAgADYCAA8LIAIgA0F+cTYCBCABIABBAXI2AgQgACABaiAANgIACyAAQYACSQ0CIAEgABBDQQAhAUHg0sAAQeDSwAAoAgBBAWsiADYCACAADQRBqNDAACgCACIABEADQCABQQFqIQEgACgCCCIADQALC0Hg0sAAQf8fIAEgAUH/H00bNgIADwtBzNLAACABNgIAQcTSwABBxNLAACgCACAAaiIANgIAIAEgAEEBcjYCBEHI0sAAKAIAIAFGBEBBwNLAAEEANgIAQcjSwABBADYCAAsgAEHY0sAAKAIAIgNNDQNBzNLAACgCACICRQ0DQQAhAEHE0sAAKAIAIgRBKUkNAkGg0MAAIQEDQCACIAEoAgAiBU8EQCACIAUgASgCBGpJDQQLIAEoAgghAQwACwALQcjSwAAgATYCAEHA0sAAQcDSwAAoAgAgAGoiADYCACABIABBAXI2AgQgACABaiAANgIADwsgAEH4AXFBsNDAAGohAgJ/QbjSwAAoAgAiA0EBIABBA3Z0IgBxRQRAQbjSwAAgACADcjYCACACDAELIAIoAggLIQAgAiABNgIIIAAgATYCDCABIAI2AgwgASAANgIIDwtBqNDAACgCACIBBEADQCAAQQFqIQAgASgCCCIBDQALC0Hg0sAAQf8fIAAgAEH/H00bNgIAIAMgBE8NAEHY0sAAQX82AgALC+kEAQV/An8CQCACQQJPBEAgASgCBCIEQf//AXFFBEAgBEEQdAwDCyAEQf8HcSEFIARBgIACcSEDIARBgPgBcSIGQYD4AUYEQCADQRB0IQMgA0GAgID8B3IgBUUNAxogAyAFQQ10ckGAgID+B3IMAwsgA0EQdCEDIAZFDQEgBkENdEGAgID8AHEgBUENdHJBgICAwANqIANyDAILQQFBAUH8gsAAEGkACyAFIAVnQRBrIgVB//8DcUEIanRB////A3EgA0GAgIDYA3IgBUEXdGtyCyEFAn8gBEGAgHxxIARBEHYiA0H//wFxRQ0AGiADQf8HcSEEIANBgIACcSEGIANBgPgBcSIHQYD4AUYEQCAGQRB0IQYgBkGAgID8B3IgBEUNARogBiADQQ10ckGAgID+B3IMAQsgBkEQdCEDIAdBDXRBgICA/ABxIARBDXRyQYCAgMADaiADciAHDQAaIAQgBGdBEGsiBEH//wNxQQhqdEH///8DcSADQYCAgNgDciAEQRd0a3ILIQQgAAJ/AkAgAkECRwRAIAEoAggiAkH//wFxRQRAIAJBEHQMAwsgAkH/B3EhASACQYCAAnEhAyACQYD4AXEiAkGA+AFGBEAgA0EQdCECIAJBgICA/AdyIAFFDQMaIAIgAUENdHJBgICA/gdyDAMLIANBEHQhAyACRQ0BIAJBDXRBgICA/ABxIAFBDXRyQYCAgMADaiADcgwCC0ECQQJBjIPAABBpAAsgASABZ0EQayIBQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAFBF3Rrcgs2AgggACAENgIEIAAgBTYCAAuLBQEEfyMAQSBrIgMkAAJAIAAQIEH/AXEiAUECRgRAQQEhAQwBCwJAAkACQAJAIAAoAgAiBEUNACAAKAIIIgIgACgCBE8NACACIARqLQAAQfAARw0AIAAgAkEBajYCCCAAKAIQIQIgAUEBcUUEQCACRQ0CQQEhAUH8nsAAQQEgAhDGAQ0FDAILIAJFDQFB+aTAAEECIAIQxgFFDQFBASEBDAQLIAFBAXFFDQIMAQsCQAJAIAAoAgBFDQAgAyAAEB8gAygCAEUNASADQRhqIANBCGopAgA3AwAgAyADKQIANwMQAkAgACgCECICRQ0AQQEhASADQRBqIAIQFg0FIAAoAhAiAkUNAEHNpcAAQQMgAhDGAQ0FCyAAEBkEQEEBIQEMBQsDQCAAKAIAIgJFDQMgACgCCCIBIAAoAgRPDQMgASACai0AAEHwAEcNAyAAIAFBAWo2AgggACgCECIBBEBB+aTAAEECIAEQxgEEQEEBIQEMBwsgACgCAEUNAgsgAyAAEB8gAygCAEUNAiADQRhqIANBCGopAgA3AwAgAyADKQIANwMQAkAgACgCECICRQ0AQQEhASADQRBqIAIQFg0GIAAoAhAiAkUNAEHNpcAAQQMgAhDGAQ0GC0EBIQEgABAZRQ0ACwwECyAAKAIQIgBFDQJB8aTAAEEBIAAQxgEhAQwDCyAAKAIQIQECQCADLQAEIgJFBEAgAUUNAUHIpMAAQRAgARDGAUUNAUEBIQEMBAsgAUUNAEHYpMAAQRkgARDGAUUNAEEBIQEMAwsgACACOgAEQQAhASAAQQA2AgAMAgsgACgCECIARQ0AQQEhAUH7nsAAQQEgABDGAQ0BC0EAIQELIANBIGokACABC8oEAg9/AX4jAEHQAGsiAyQAIANBDGqtQoCAgIDwAoQhEiAALQAMIQsgACgCBCEPIAAoAgAhDiAAKAIIIgdBFGohECAHQRhqIREDQAJAIAgiDUEBcQ0AIAYhCUEBIQgCQCACIAVPBEADQCABIAVqIQYCQAJAAkAgAiAFayIKQQdNBEAgAiAFRgRAIAkhBiACIQUgAiEEDAcLQQAhBANAIAQgBmotAABBCkYNAiAKIARBAWoiBEcNAAsgCSEGIAIhBSACIQQMBgsgA0EKIAYgChBHIAMoAgAiCkEBRw0BIAMoAgQhBAsgBCAFaiIEQQFqIQUgAiAETQ0BIAEgBGotAABBCkcNASAFIQYgDSEIDAQLIAkhBiACIQUgAiEEIApBAXFFDQMgDSEIDAMLIAIgBU8NAAsLIAkhBiACIQQLAkAgC0EBcUUEQCAAQQE6AAwgDkEBcUUEQCAHQfyNwABBBBCZAUUNAgwDCyADIA82AgwgAyASNwMoIANBAToATCADQQA2AkggA0IgNwJAIANCgICAgNAANwI4IANBAjYCMCADQQE2AiQgA0ECNgIUIANBhI7AADYCECADQQE2AhwgECgCACARKAIAIAMgA0EwajYCICADIANBKGo2AhggA0EQahApDQIMAQsgDEUNACAHQQoQnAENASAOQQFxBEAgB0GUjsAAQQcQmQENAgwBCyAHQfyNwABBBBCZAQ0BCyAMQQFqIQxBASELIAcgASAJaiAEIAlrEJkBRQ0BCwsgA0HQAGokACANQX9zQQFxC+sEAQp/IwBBMGsiAyQAIANBAzoALCADQSA2AhwgA0EANgIoIAMgATYCJCADIAA2AiAgA0EANgIUIANBADYCDAJ/AkACQAJAIAIoAhAiCkUEQCACKAIMIgBFDQEgAigCCCIBIABBA3RqIQQgAEEBa0H/////AXFBAWohByACKAIAIQADQCAAQQRqKAIAIgUEQCADKAIgIAAoAgAgBSADKAIkKAIMEQEADQQLIAEoAgAgA0EMaiABKAIEEQAADQMgAEEIaiEAIAFBCGoiASAERw0ACwwBCyACKAIUIgBFDQAgAEEFdCELIABBAWtB////P3FBAWohByACKAIIIQUgAigCACEAA0AgAEEEaigCACIBBEAgAygCICAAKAIAIAEgAygCJCgCDBEBAA0DCyADIAggCmoiAUEQaigCADYCHCADIAFBHGotAAA6ACwgAyABQRhqKAIANgIoIAFBDGooAgAhBEEAIQlBACEGAkACQAJAIAFBCGooAgBBAWsOAgACAQsgBEEDdCAFaiIMKAIADQEgDCgCBCEEC0EBIQYLIAMgBDYCECADIAY2AgwgAUEEaigCACEEAkACQAJAIAEoAgBBAWsOAgACAQsgBEEDdCAFaiIGKAIADQEgBigCBCEEC0EBIQkLIAMgBDYCGCADIAk2AhQgBSABQRRqKAIAQQN0aiIBKAIAIANBDGogASgCBBEAAA0CIABBCGohACALIAhBIGoiCEcNAAsLIAcgAigCBE8NASADKAIgIAIoAgAgB0EDdGoiACgCACAAKAIEIAMoAiQoAgwRAQBFDQELQQEMAQtBAAsgA0EwaiQAC48EAQ1/IAFBAWshDyAAKAIEIQogACgCACELIAAoAgghDAJAA0AgDg0BAkACQCACIARJDQADQCABIARqIQUCQAJAAkAgAiAEayIGQQdNBEAgAiAERw0BIAIhBAwFCwJAIAVBA2pBfHEiCCAFayIDBEBBACEAA0AgACAFai0AAEEKRg0FIAMgAEEBaiIARw0ACyADIAZBCGsiAE0NAQwDCyAGQQhrIQALA0BBgIKECCAIKAIAIglBipSo0ABzayAJckGAgoQIIAhBBGooAgAiCUGKlKjQAHNrIAlycUGAgYKEeHFBgIGChHhHDQIgCEEIaiEIIANBCGoiAyAATQ0ACwwBC0EAIQADQCAAIAVqLQAAQQpGDQIgBiAAQQFqIgBHDQALIAIhBAwDCyADIAZGBEAgAiEEDAMLA0AgAyAFai0AAEEKRgRAIAMhAAwCCyAGIANBAWoiA0cNAAsgAiEEDAILIAAgBGoiA0EBaiEEAkAgAiADTQ0AIAAgBWotAABBCkcNACAEIQUgBCEADAMLIAIgBE8NAAsLQQEhDiACIgAgByIFRg0CCwJAIAwtAAAEQCALQeSuwABBBCAKKAIMEQEADQELQQAhAyAAIAdHBEAgACAPai0AAEEKRiEDCyAAIAdrIQAgASAHaiEGIAwgAzoAACAFIQcgCyAGIAAgCigCDBEBAEUNAQsLQQEhDQsgDQuZBAEJfyMAQSBrIgQkAAJAAkACQAJAAkACQAJAIAAoAgAiBgRAIAAoAggiAyAAKAIEIgUgAyAFSxshCUF/IQcgAyECA0AgAiAJRg0EIAAgAkEBaiIINgIIIAdBAWohByACIAZqIAghAi0AACIIQTBrQf8BcUEKSSAIQeEAa0H/AXFBBklyDQALIAhB3wBHDQMgAkEBayECAkAgAwRAIAMgBUkEQCACIAVLDQogAyAGaiwAAEFASA0KDAILIAIgBU0NAQwJCyACIAVLDQgLIARBCGogAyAGaiIDIAcQNCAEKQMIUEUNAiAAKAIQIgANAUEAIQIMBQsgACgCECIARQRADAULQfGkwABBASAAEMYBIQIMBAtBASECQeGlwABBAiAAEMYBDQMgAyAHIAAQxgENAwwCCyAAKAIQIQAgBCAEKQMQNwMYIABFBEBBACECDAMLIARBGGogABC0AUUNAUEBIQIMAgsCQCAAKAIQIgFFDQBByKTAAEEQIAEQxgFFDQBBASECDAILQQAhAiAAQQA6AAQgAEEANgIADAELIAAtABxBBHEEQEEAIQIMAQsgAUHhAGsiAUH/AXEiAkEaT0G/9/MdIAJ2QQFxRXINASABQQJ0QfwHcSIBQeCowABqKAIAIAFB+KfAAGooAgAgABDGASECCyAEQSBqJAAgAg8LQeSlwAAQswEACyAGIAUgAyACQfijwAAQnQEAC7IEAgJ9BH8jAEEQayEEIAC8IgVBH3YhBgJAAn0gAAJ/AkACQAJAAkAgBUH/////B3EiA0HQ2LqVBE8EQCADQYCAgPwHSwRAIAAPCyAFQQBIIgVFIANBl+TFlQRLcQ0CIAVFDQEgBEMAAICAIACVOAIIIAQqAggaIANBtOO/lgRNDQEMBwsgA0GY5MX1A00EQCADQYCAgMgDTQ0DQQAhAyAADAYLIANBkquU/ANNDQMLIABDO6q4P5QgBkECdEGYzsAAaioCAJIiAUMAAADPYCEEQf////8HAn8gAYtDAAAAT10EQCABqAwBC0GAgICAeAtBgICAgHggBBsgAUP///9OXhtBACABIAFbGwwDCyAAQwAAAH+UDwsgBCAAQwAAAH+SOAIMIAQqAgwaIABDAACAP5IPCyAGRSAGawsiA7IiAUMAcjG/lJIiACABQ46+vzWUIgKTCyEBIAAgASABIAEgAZQiACAAQxVSNbuUQ4+qKj6SlJMiAJRDAAAAQCAAk5UgApOSQwAAgD+SIQEgA0UNAAJAAkACQCADQf8ATARAIANBgn9ODQMgAUMAAIAMlCEBIANBm35NDQEgA0HmAGohAwwDCyABQwAAAH+UIQEgA0H+AUsNASADQf8AayEDDAILIAFDAACADJQhAUG2fSADIANBtn1NG0HMAWohAwwBCyABQwAAAH+UIQFB/QIgAyADQf0CTxtB/gFrIQMLIAEgA0EXdEGAgID8A2q+lCEBCyABC4gEAQh/IAEoAgQiBQRAIAEoAgAhBANAAkAgA0EBaiECAn8gAiADIARqLQAAIgjAIglBAE4NABoCQAJAAkACQAJAAkACQAJAAkACQAJAIAhB4LPAAGotAABBAmsOAwABAgwLQci2wAAgAiAEaiACIAVPGy0AAEHAAXFBgAFHDQsgA0ECagwKC0HItsAAIAIgBGogAiAFTxssAAAhByAIQeABayIGRQ0BIAZBDUYNAgwDC0HItsAAIAIgBGogAiAFTxssAAAhBiAIQfABaw4FBAMDAwUDCyAHQWBxQaB/Rw0IDAYLIAdBn39KDQcMBQsgCUEfakH/AXFBDE8EQCAJQX5xQW5HIAdBQE5yDQcMBQsgB0FATg0GDAQLIAlBD2pB/wFxQQJLIAZBQE5yDQUMAgsgBkHwAGpB/wFxQTBPDQQMAQsgBkGPf0oNAwtByLbAACAEIANBAmoiAmogAiAFTxstAABBwAFxQYABRw0CQci2wAAgBCADQQNqIgJqIAIgBU8bLQAAQcABcUGAAUcNAiADQQRqDAELQci2wAAgBCADQQJqIgJqIAIgBU8bLQAAQcABcUGAAUcNASADQQNqCyIDIgIgBUkNAQsLIAAgAzYCBCAAIAQ2AgAgASAFIAJrNgIEIAEgAiAEajYCACAAIAIgA2s2AgwgACADIARqNgIIDwsgAEEANgIAC8cDAQt/IwBBEGsiBSQAAkAgASgCECIEIAEoAgwiA0kEQAwBCyABKAIIIgsgBEkEQAwBCyABQRRqIgwgAS0AGCIGakEBay0AACEJIAEoAgQhCgJAAkAgBkEETQRAA0AgAyAKaiEHAkAgBCADayIIQQdNBEAgAyAERg0EQQAhAgNAIAIgB2otAAAgCUYNAiAIIAJBAWoiAkcNAAsMBAsgBUEIaiAJIAcgCBBHIAUoAggiAkEBRw0EIAUoAgwhAgsgASACIANqQQFqIgM2AgwCQCADIAZJIAMgC0tyDQAgCiADIAZrIgJqIAwgBhBxDQAgACADNgIIIAAgAjYCBEEBIQIMBQsgAyAETQ0AC0EAIQIMAwsCQANAIAMgCmohBwJAIAQgA2siCEEITwRAIAUgCSAHIAgQRyAFKAIAIgJBAUcNBSAFKAIEIQIMAQsgAyAERg0DQQAhAgNAIAIgB2otAAAgCUYNASACQQFqIgIgCEcNAAsMAwsgASACIANqQQFqIgM2AgwgAyALTSADIAZPcQ0BIAMgBE0NAAtBACECDAMLIAZBBEGsnMAAEGoAC0EAIQILIAEgBDYCDAsgACACNgIAIAVBEGokAAvGAwINfwF+IAMgBUEBayINIAEoAhQiCGoiB0sEQEEAIAEoAggiCmshDiAFIAEoAhAiD2shECABKAIcIQsgASkDACEUA0ACQCABAn8CQCAUIAIgB2oxAACIQgGDUARAIAEgBSAIaiIINgIUIAYNAwwBCyAKIAogCyAKIAtLGyAGGyIJIAUgBSAJSRshDCACIAhqIREgCSEHAkACQAJAA0AgByAMRgRAQQAgCyAGGyEMIAohBwNAIAcgDE0EQCABIAUgCGoiAjYCFCAGRQRAIAFBADYCHAsgACACNgIIIAAgCDYCBCAAQQE2AgAPCyAHQQFrIgcgBU8NBSAHIAhqIgkgA08NAyAEIAdqLQAAIAIgCWotAABGDQALIAEgCCAPaiIINgIUIBAgBkUNBhoMBwsgByAIaiADTw0CIAcgEWohEiAEIAdqIAdBAWohBy0AACASLQAARg0ACyAIIA5qIAdqIQggBkUNAwwFCyAJIANBxJrAABBpAAsgAyAIIAlqIgAgACADSRsgA0HUmsAAEGkACyAHIAVBtJrAABBpAAtBAAsiBzYCHCAHIQsLIAggDWoiByADSQ0ACwsgASADNgIUIABBADYCAAv5AwECfyAAIAFqIQICQAJAIAAoAgQiA0EBcQ0AIANBAnFFDQEgACgCACIDIAFqIQEgACADayIAQcjSwAAoAgBGBEAgAigCBEEDcUEDRw0BQcDSwAAgATYCACACIAIoAgRBfnE2AgQgACABQQFyNgIEIAIgATYCAAwCCyAAIAMQOwsCQAJAAkAgAigCBCIDQQJxRQRAIAJBzNLAACgCAEYNAiACQcjSwAAoAgBGDQMgAiADQXhxIgIQOyAAIAEgAmoiAUEBcjYCBCAAIAFqIAE2AgAgAEHI0sAAKAIARw0BQcDSwAAgATYCAA8LIAIgA0F+cTYCBCAAIAFBAXI2AgQgACABaiABNgIACyABQYACTwRAIAAgARBDDwsgAUH4AXFBsNDAAGohAgJ/QbjSwAAoAgAiA0EBIAFBA3Z0IgFxRQRAQbjSwAAgASADcjYCACACDAELIAIoAggLIQEgAiAANgIIIAEgADYCDCAAIAI2AgwgACABNgIIDwtBzNLAACAANgIAQcTSwABBxNLAACgCACABaiIBNgIAIAAgAUEBcjYCBCAAQcjSwAAoAgBHDQFBwNLAAEEANgIAQcjSwABBADYCAA8LQcjSwAAgADYCAEHA0sAAQcDSwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgACABaiABNgIACwucAwIHfwJ+IwBBEGsiBCQAAn8CQCAAKAIAIgNFDQAgACgCCCICIAAoAgQiBU8NACACIANqIgEtAABBzABGBEAgACACQQFqIgE2AgggAAJ+AkAgASAFSQRAIAEgA2otAABB3wBGDQELIAEgBSABIAVLGyEHAkACQANAAkAgASAFSQRAIAEgA2otAABB3wBGDQELIAEgB0YNAgJAIAEgA2otAAAiAkEwayIGQf8BcUEKSQ0AIAJB4QBrQf8BcUEaTwRAIAJBwQBrQf8BcUEaTw0EIAJBHWshBgwBCyACQdcAayEGCyAAIAFBAWoiATYCCCAEIAgQZCAEKQMIQgBSDQIgBCkDACIJIAatQv8Bg3wiCCAJWg0BDAILCyAAIAFBAWo2AgggCEJ/Ug0BCyAAKAIQIgMEQEEBQcikwABBECADEMYBDQYaCyAAQQA6AAQgAEEANgIAQQAMBQsgCEIBfAwBCyAAIAJBAmo2AghCAAsQVgwCCyABLQAAQcsARw0AIAAgAkEBajYCCCAAQQAQEwwBCyAAEBkLIARBEGokAAugAwEFfwJAQRFBACAAQa+wBE8bIgIgAkEIciIBIABBC3QiAiABQQJ0QaDFwABqKAIAQQt0SRsiASABQQRyIgEgAUECdEGgxcAAaigCAEELdCACSxsiASABQQJyIgEgAUECdEGgxcAAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGgxcAAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGgxcAAaigCAEELdCACSxsiAUECdEGgxcAAaigCAEELdCIDIAJGIAIgA0tqIAFqIgFBIU0EQCABQQJ0QaDFwABqIgQoAgBBFXYhAkHvBSEDAn8CQCABQSFGDQAgBCgCBEEVdiEDIAENAEEADAELIAFBAnRBnMXAAGooAgBB////AHELIQECQCADIAJBf3NqRQ0AIAAgAWshBUHvBSACIAJB7wVNGyEEIANBAWshAEEAIQEDQCACIARGDQMgASACQajGwABqLQAAaiIBIAVLDQEgACACQQFqIgJHDQALIAAhAgsgAkEBcQ8LIAFBIkHcxMAAEGkACyAEQe8FQezEwAAQaQALhQMBCX8jAEEgayIEJAAQRSIAKAIQIQUgACgCDCEIIABCADcCDCAAKAIEIQYgACgCCCEDIABCBDcCBCAAKAIAIQIgAEEANgIAAkAgAyAIRgRAAkAgAiADRgRA0G9BgAEgAiACQYABTRsiB/wPASIBQX9GDQMCQCAFRQRAIAEhBQwBCyACIAVqIAFHDQQLIAIgB2oiByACSSAHQf////8DS3INAyAHQQJ0IgFB/P///wdLDQMgBCACBH8gBCAGNgIUIAQgAkECdDYCHEEEBUEACzYCGCAEQQhqQQQgASAEQRRqEF0gBCgCCEEBRg0DIAQoAgwhBiACIQEgByECDAELIAIgAyIBTQ0CCyAGIAFBAnRqIANBAWo2AgAgAUEBaiEDCyADIAhNDQAgBiAIQQJ0aigCACEBIAAgBTYCECAAIAE2AgwgACADNgIIIAAoAgQhAyAAIAY2AgQgACgCACEBIAAgAjYCACABBEAgAyABQQJ0QQQQsAELIARBIGokACAFIAhqDwsAC+4CAgR/An4jAEHQAGsiBCQAIAQgASACQb+hwABBARAUA0AgBEHEAGogBBAaIAQoAkQiA0UNAAsCQCACAn8gA0ECRwRAIAQoAkgMAQsgAgsiA2tBEEsEQAwBC0IBIQggAiADRg0AIAEgAmohBiABIANqIQMDQAJ/IAMsAAAiAUEATgRAIAFB/wFxIQIgA0EBagwBCyADLQABQT9xIQUgAUEfcSECIAFBX00EQCACQQZ0IAVyIQIgA0ECagwBCyADLQACQT9xIAVBBnRyIQUgAUFwSQRAIAUgAkEMdHIhAiADQQNqDAELIAJBEnRBgIDwAHEgAy0AA0E/cSAFQQZ0cnIhAiADQQRqCyEDAkAgAkEwayIBQQpPBEBBfyACQSByIgFB1wBrIgIgAiABQeEAa0kbIgFBEE8NAQsgAa0gB0IEhoQhByADIAZGDQIMAQsLQcChwAAQswEACyAAIAc3AwggACAINwMAIARB0ABqJAAL5wIBBX8CQEHN/3tBECAAIABBEE0bIgBrIAFNDQAgAEEQIAFBC2pBeHEgAUELSRsiBGpBDGoQESICRQ0AIAJBCGshAQJAIABBAWsiAyACcUUEQCABIQAMAQsgAkEEayIFKAIAIgZBeHEgAiADakEAIABrcUEIayICIABBACACIAFrQRBNG2oiACABayICayEDIAZBA3EEQCAAIAMgACgCBEEBcXJBAnI2AgQgACADaiIDIAMoAgRBAXI2AgQgBSACIAUoAgBBAXFyQQJyNgIAIAEgAmoiAyADKAIEQQFyNgIEIAEgAhAwDAELIAEoAgAhASAAIAM2AgQgACABIAJqNgIACwJAIAAoAgQiAUEDcUUNACABQXhxIgIgBEEQak0NACAAIAQgAUEBcXJBAnI2AgQgACAEaiIBIAIgBGsiBEEDcjYCBCAAIAJqIgIgAigCBEEBcjYCBCABIAQQMAsgAEEIaiEDCyADC/ECAgZ/An4jAEEQayIEJAAgAAJ/AkACQCABKAIIIgMgASgCBCIFSQRAIAEoAgAiBiADai0AAEHzAEYNAQsgAEIANwMIDAELIAEgA0EBaiICNgIIAkACQAJAIAIgBU8NACACIAZqLQAAQd8ARw0AIAEgA0ECajYCCAwBCwJAAkADQAJAIAIgBUkEQCACIAZqLQAAQd8ARg0BCyACIAVGDQICQCACIAZqLQAAIgNBMGsiB0H/AXFBCkkNACADQeEAa0H/AXFBGk8EQCADQcEAa0H/AXFBGk8NBCADQR1rIQcMAQsgA0HXAGshBwsgASACQQFqIgI2AgggBCAIEGQgBCkDCEIAUg0CIAQpAwAiCSAHrUL/AYN8IgggCVoNAQwCCwsgASACQQFqNgIIIAhCf1INAQsgAEEAOgABQQEMBAsgCEIBfCIIQn9RDQELIAAgCEIBfDcDCAwBCyAAQQA6AAFBAQwBC0EACzoAACAEQRBqJAAL/QIBB38jAEEQayIEJAACQAJAAkACQAJAIAEoAgQiAkUNACABKAIAIQcgAkEDcSEFAkAgAkEESQRAQQAhAgwBCyAHQRxqIQMgAkF8cSEIQQAhAgNAIAMoAgAgA0EIaygCACADQRBrKAIAIANBGGsoAgAgAmpqamohAiADQSBqIQMgCCAGQQRqIgZHDQALCyAFBEAgBkEDdCAHakEEaiEDA0AgAygCACACaiECIANBCGohAyAFQQFrIgUNAAsLIAEoAgwEQCACQQBIDQEgBygCBEUgAkEQSXENASACQQF0IQILQQAhBSACQQBIDQMgAg0BC0EBIQNBACECDAELQf3OwAAtAAAaQQEhBSACQQEQpgEiA0UNAQsgBEEANgIIIAQgAzYCBCAEIAI2AgAgBEHQqcAAIAEQKUUNAUG4qsAAQdYAIARBD2pBqKrAAEGgq8AAEGUACyAFIAIQlAEACyAAIAQpAgA3AgAgAEEIaiAEQQhqKAIANgIAIARBEGokAAurAgEBfyMAQfAAayIGJAAgBiABNgIMIAYgADYCCCAGIAM2AhQgBiACNgIQIAZBqK3AADYCGCAGQQI2AhwCQCAEKAIARQRAIAZBAzYCXCAGQeStwAA2AlggBkIDNwJkIAYgBkEQaq1CgICAgIAMhDcDSCAGIAZBCGqtQoCAgICADIQ3A0AMAQsgBkEwaiAEQRBqKQIANwMAIAZBKGogBEEIaikCADcDACAGIAQpAgA3AyAgBkEENgJcIAZBmK7AADYCWCAGQgQ3AmQgBiAGQRBqrUKAgICAgAyENwNQIAYgBkEIaq1CgICAgIAMhDcDSCAGIAZBIGqtQoCAgICgDIQ3A0ALIAYgBkEYaq1CgICAgJAMhDcDOCAGIAZBOGo2AmAgBkHYAGogBRCEAQALygICB38CfiMAQRBrIgQkACABKAIAIQYCQAJAAkACQCABKAIIIgIgASgCBCIHSQRAIAIgBmotAABB3wBGDQELIAIgByACIAdLGyEIAkADQCACIAdJBEAgAiAGai0AAEHfAEYNAgsgAiAIRg0EAkAgAiAGai0AACIFQTBrIgNB/wFxQQpJDQAgBUHhAGtB/wFxQRpPBEAgBUHBAGtB/wFxQRpPDQYgBUEdayEDDAELIAVB1wBrIQMLIAEgAkEBaiICNgIIIAQgCRBkIAQpAwhCAFINBCAEKQMAIgogA61C/wGDfCIJIApaDQALDAMLQQEhAyABIAJBAWo2AgggCUJ/UQ0BIAAgCUIBfDcDCEEAIQMMAwsgAEIANwMIIAEgAkEBajYCCAwCCyAAQQA6AAEMAQsgAEEAOgABQQEhAwsgACADOgAAIARBEGokAAvQAgEHf0EBIQkCQAJAIAJFDQAgASACQQF0aiEKIABBgP4DcUEIdiELIABB/wFxIQ0DQCABQQJqIQwgByABLQABIgJqIQggCyABLQAAIgFHBEAgASALSw0CIAghByAMIgEgCkYNAgwBCwJAAkAgByAITQRAIAQgCEkNASADIAdqIQEDQCACRQ0DIAJBAWshAiABLQAAIAFBAWohASANRw0AC0EAIQkMBQsgByAIQYC5wAAQawALIAggBEGAucAAEGoACyAIIQcgDCIBIApHDQALCyAGRQ0AIAUgBmohAyAAQf//A3EhAQNAIAVBAWohAAJAIAUsAAAiAkEATgRAIAAhBQwBCyAAIANHBEAgBS0AASACQf8AcUEIdHIhAiAFQQJqIQUMAQtB8LjAABCzAQALIAEgAmsiAUEASA0BIAlBAXMhCSADIAVHDQALCyAJQQFxC/ECAQR/IAAoAgwhAgJAAkAgAUGAAk8EQCAAKAIYIQMCQAJAIAAgAkYEQCAAQRRBECAAKAIUIgIbaigCACIBDQFBACECDAILIAAoAggiASACNgIMIAIgATYCCAwBCyAAQRRqIABBEGogAhshBANAIAQhBSABIgJBFGogAkEQaiACKAIUIgEbIQQgAkEUQRAgARtqKAIAIgENAAsgBUEANgIACyADRQ0CIAAgACgCHEECdEGgz8AAaiIBKAIARwRAIANBEEEUIAMoAhAgAEYbaiACNgIAIAJFDQMMAgsgASACNgIAIAINAUG80sAAQbzSwAAoAgBBfiAAKAIcd3E2AgAMAgsgACgCCCIAIAJHBEAgACACNgIMIAIgADYCCA8LQbjSwABBuNLAACgCAEF+IAFBA3Z3cTYCAA8LIAIgAzYCGCAAKAIQIgEEQCACIAE2AhAgASACNgIYCyAAKAIUIgBFDQAgAiAANgIUIAAgAjYCGAsLtgIBB38CQCACQRBJBEAgACEDDAELIABBACAAa0EDcSIEaiEFIAQEQCAAIQMgASEGA0AgAyAGLQAAOgAAIAZBAWohBiADQQFqIgMgBUkNAAsLIAUgAiAEayIIQXxxIgdqIQMCQCABIARqIgRBA3EEQCAHQQBMDQEgBEEDdCICQRhxIQkgBEF8cSIGQQRqIQFBACACa0EYcSECIAYoAgAhBgNAIAUgBiAJdiABKAIAIgYgAnRyNgIAIAFBBGohASAFQQRqIgUgA0kNAAsMAQsgB0EATA0AIAQhAQNAIAUgASgCADYCACABQQRqIQEgBUEEaiIFIANJDQALCyAIQQNxIQIgBCAHaiEBCyACBEAgAiADaiECA0AgAyABLQAAOgAAIAFBAWohASADQQFqIgMgAkkNAAsLIAALvwIBA38jAEEQayICJAACQCABQYABTwRAIAJBADYCDAJ/IAFBgBBPBEAgAUGAgARPBEAgAkEMakEDciEEIAIgAUESdkHwAXI6AAwgAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANQQQMAgsgAkEMakECciEEIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAELIAJBDGpBAXIhBCACIAFBBnZBwAFyOgAMQQILIQMgBCABQT9xQYABcjoAACADIAAoAgAgACgCCCIBa0sEQCAAIAEgAxBEIAAoAgghAQsgACgCBCABaiACQQxqIAMQPBogACABIANqNgIIDAELIAAoAggiAyAAKAIARgRAIAAQVAsgACADQQFqNgIIIAAoAgQgA2ogAToAAAsgAkEQaiQAQQALvwIBA38jAEEQayICJAACQCABQYABTwRAIAJBADYCDAJ/IAFBgBBPBEAgAUGAgARPBEAgAkEMakEDciEEIAIgAUESdkHwAXI6AAwgAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANQQQMAgsgAkEMakECciEEIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAELIAJBDGpBAXIhBCACIAFBBnZBwAFyOgAMQQILIQMgBCABQT9xQYABcjoAACADIAAoAgAgACgCCCIBa0sEQCAAIAEgAxBEIAAoAgghAQsgACgCBCABaiACQQxqIAMQPBogACABIANqNgIIDAELIAAoAggiAyAAKAIARgRAIAAQVAsgACgCBCADaiABOgAAIAAgA0EBajYCCAsgAkEQaiQAQQALuAIBA38jAEGAAWsiBCQAAn8CQAJAIAEoAhwiAkEQcUUEQCACQSBxDQEgACgCACABEEIMAwsgACgCACEAQQAhAgNAIAIgBGpB/wBqIABBD3EiA0EwciADQdcAaiADQQpJGzoAACACQQFrIQIgAEEQSSAAQQR2IQBFDQALDAELIAAoAgAhAEEAIQIDQCACIARqQf8AaiAAQQ9xIgNBMHIgA0E3aiADQQpJGzoAACACQQFrIQIgAEEQSSAAQQR2IQBFDQALIAJBgAFqIgBBgQFPBEAgAEGAAUGMr8AAEGgACyABQZyvwABBAiACIARqQYABakEAIAJrECEMAQsgAkGAAWoiAEGBAU8EQCAAQYABQYyvwAAQaAALIAFBnK/AAEECIAIgBGpBgAFqQQAgAmsQIQsgBEGAAWokAAu/AgEDfyMAQRBrIgIkAAJAIAFBgAFPBEAgAkEANgIMAn8gAUGAEE8EQCABQYCABE8EQCACQQxqQQNyIQQgAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAwCCyACQQxqQQJyIQQgAiABQQx2QeABcjoADCACIAFBBnZBP3FBgAFyOgANQQMMAQsgAkEMakEBciEEIAIgAUEGdkHAAXI6AAxBAgshAyAEIAFBP3FBgAFyOgAAIAMgACgCACAAKAIIIgFrSwRAIAAgASADEFUgACgCCCEBCyAAKAIEIAFqIAJBDGogAxA8GiAAIAEgA2o2AggMAQsgACgCCCIDIAAoAgBGBEAgABBUCyAAIANBAWo2AgggACgCBCADaiABOgAACyACQRBqJABBAAu9AgECfyMAQRBrIgIkAAJAIAFBgAFPBEAgAkEANgIMAn8gAUGAEE8EQCABQYCABE8EQCACIAFBP3FBgAFyOgAPIAIgAUESdkHwAXI6AAwgAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANQQQMAgsgAiABQT9xQYABcjoADiACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwwBCyACIAFBP3FBgAFyOgANIAIgAUEGdkHAAXI6AAxBAgshASABIAAoAgAgACgCCCIDa0sEQCAAIAMgARBKIAAoAgghAwsgACgCBCADaiACQQxqIAEQPBogACABIANqNgIIDAELIAAoAggiAyAAKAIARgRAIAAQVAsgACADQQFqNgIIIAAoAgQgA2ogAToAAAsgAkEQaiQAQQALuwIBBn8jAEEQayIDJABBCiECAkAgAEGQzgBJBEAgACEEDAELA0AgA0EGaiACaiIFQQRrIAAgAEGQzgBuIgRBkM4AbGsiBkH//wNxQeQAbiIHQQF0QZ6vwABqLwAAOwAAIAVBAmsgBiAHQeQAbGtB//8DcUEBdEGer8AAai8AADsAACACQQRrIQIgAEH/wdcvSyAEIQANAAsLAkAgBEHjAE0EQCAEIQAMAQsgAkECayICIANBBmpqIAQgBEH//wNxQeQAbiIAQeQAbGtB//8DcUEBdEGer8AAai8AADsAAAsCQCAAQQpPBEAgAkECayICIANBBmpqIABBAXRBnq/AAGovAAA7AAAMAQsgAkEBayICIANBBmpqIABBMHI6AAALIAFBAUEAIANBBmogAmpBCiACaxAhIANBEGokAAvEAgEEfyAAQgA3AhAgAAJ/QQAgAUGAAkkNABpBHyABQf///wdLDQAaIAFBBiABQQh2ZyIDa3ZBAXEgA0EBdGtBPmoLIgI2AhwgAkECdEGgz8AAaiEEQQEgAnQiA0G80sAAKAIAcUUEQCAEIAA2AgAgACAENgIYIAAgADYCDCAAIAA2AghBvNLAAEG80sAAKAIAIANyNgIADwsCQAJAIAEgBCgCACIDKAIEQXhxRgRAIAMhAgwBCyABQRkgAkEBdmtBACACQR9HG3QhBQNAIAMgBUEddkEEcWpBEGoiBCgCACICRQ0CIAVBAXQhBSACIQMgAigCBEF4cSABRw0ACwsgAigCCCIBIAA2AgwgAiAANgIIIABBADYCGCAAIAI2AgwgACABNgIIDwsgBCAANgIAIAAgAzYCGCAAIAA2AgwgACAANgIIC88BAgR/AX4jAEEgayIDJAACQCABIAEgAmoiAksNAEEIIAAoAgAiBEEBdCIBIAIgASACSxsiAiACQQhJGyICrSIHQiCIUEUNAAJAIAenIgVB/////wdNBEAgAyAEBH8gAyAENgIcIAMgACgCBDYCFEEBBUEACzYCGCADQQhqQQEgBSADQRRqEF0gAygCCEEBRw0BIAMoAgwhBiADKAIQIQELIAYgARCUAQALIAMoAgwhASAAIAI2AgAgACABNgIEIANBIGokAA8LQQBBABCUAQAL+wIBBH8jAEEwayIAJAACQAJAQaDOwAAoAgBFBEBBuM7AACgCACEBQbjOwABBADYCACABRQ0BIABBGGogAREEACAAQRBqIgIgAEEkaikCADcDACAAIAApAhw3AwggACgCGCEBQaDOwAAoAgAiAw0CAkAgA0UNAEGkzsAAKAIAIgJFDQBBqM7AACgCACACQQJ0QQQQsAELQaTOwAAgATYCAEGgzsAAQQE2AgBBqM7AACAAKQMINwIAQbDOwAAgAEEQaikDADcCAAsgAEEwaiQAQaTOwAAPCyAAQQA2AiggAEEBNgIcIABB9I/AADYCGCAAQgQ3AiAgAEEYakHckMAAEIQBAAsgAEEoaiACKQMANwIAIAAgACkDCDcCICAAIAE2AhwgAEEBNgIYAkAgAEEYaiIBKAIARQ0AIAEoAgQiAkUNACABKAIIIAJBAnRBBBCwAQsgAEEANgIoIABBATYCHCAAQfyQwAA2AhggAEIENwIgIAFBhJHAABCEAQALlgIBAX8jAEEQayICJAACfwJAIAEoAgBFBEAgASgCCEEBRw0BCyAAKAIAIQAgAkEANgIMIAEgAkEMagJ/IABBgAFPBEAgAEGAEE8EQCAAQYCABE8EQCACIABBP3FBgAFyOgAPIAIgAEESdkHwAXI6AAwgAiAAQQZ2QT9xQYABcjoADiACIABBDHZBP3FBgAFyOgANQQQMAwsgAiAAQT9xQYABcjoADiACIABBDHZB4AFyOgAMIAIgAEEGdkE/cUGAAXI6AA1BAwwCCyACIABBP3FBgAFyOgANIAIgAEEGdkHAAXI6AAxBAgwBCyACIAA6AAxBAQsQHgwBCyABKAIUIAAoAgAgASgCGCgCEBEAAAsgAkEQaiQAC50CAQV/AkACQAJAAkAgAkEDakF8cSIEIAJGDQAgBCACayIEIAMgAyAESxsiBUUNAEEAIQQgAUH/AXEhBkEBIQcDQCACIARqLQAAIAZGDQQgBSAEQQFqIgRHDQALIAUgA0EIayIISw0CDAELIANBCGshCEEAIQULIAFB/wFxQYGChAhsIQQDQEGAgoQIIAIgBWoiBygCACAEcyIGayAGckGAgoQIIAdBBGooAgAgBHMiBmsgBnJxQYCBgoR4cUGAgYKEeEcNASAFQQhqIgUgCE0NAAsLIAMgBUcEQCABQf8BcSEEQQEhBwNAIAQgAiAFai0AAEYEQCAFIQQMAwsgAyAFQQFqIgVHDQALC0EAIQcLIAAgBDYCBCAAIAc2AgALlgIBA38jAEEQayICJAAgAkEANgIMAn8gAUGAAU8EQCABQYAQTwRAIAFBgIAETwRAIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAwDCyACIAFBP3FBgAFyOgAOIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAILIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECDAELIAIgAToADEEBCyEBIAAgACgCBCIDIAFrNgIEIAAgACgCACABIANLciIENgIAQQEhAyAERQRAIAAoAgggAkEMaiABEJkBIQMLIAJBEGokACADC6oCAgN/AX4jAEFAaiICJAAgASgCAEGAgICAeEYEQCABKAIMIQMgAkEkaiIEQQA2AgAgAkKAgICAEDcCHCACQTBqIAMoAgAiA0EIaikCADcDACACQThqIANBEGopAgA3AwAgAiADKQIANwMoIAJBHGpBrJHAACACQShqECkaIAJBGGogBCgCACIDNgIAIAIgAikCHCIFNwMQIAFBCGogAzYCACABIAU3AgALIAEpAgAhBSABQoCAgIAQNwIAIAJBCGoiAyABQQhqIgEoAgA2AgAgAUEANgIAQf3OwAAtAAAaIAIgBTcDAEEMQQQQpgEiAUUEQEEEQQwQxAEACyABIAIpAwA3AgAgAUEIaiADKAIANgIAIABBpJbAADYCBCAAIAE2AgAgAkFAayQAC9UBAgR/AX4jAEEgayIDJAAgASABIAJqIgJLBEBBAEEAEJQBAAtBCCAAKAIAIgRBAXQiASACIAEgAksbIgIgAkEISRsiAq0iB0IgiFBFBEBBAEEAEJQBAAsCQCAHpyIFQf////8HTQRAIAMgBAR/IAMgBDYCHCADIAAoAgQ2AhRBAQVBAAs2AhggA0EIakEBIAUgA0EUahBdIAMoAghBAUcNASADKAIMIQYgAygCECEBCyAGIAEQlAEACyADKAIMIQEgACACNgIAIAAgATYCBCADQSBqJAAL9gEBCH8gASgCCCICIAEoAgQiAyACIANLGyEIIAEoAgAhBUF/IQcgAiEEAkACQANAIAQgCEYNASABIARBAWoiBjYCCCAHQQFqIQcgBCAFaiAGIQQtAAAiBkEwa0H/AXFBCkkgBkHhAGtB/wFxQQZJcg0ACyAGQd8ARw0AIAIgBEEBayIBSw0BAkAgAgRAIAIgA0kEQCACIAVqLAAAQUBIIAEgA0tyDQQMAgsgAiADRw0DIAEgA00NAQwDCyABIANLDQILIAAgBzYCBCAAIAIgBWo2AgAPCyAAQQA2AgAgAEEAOgAEDwsgBSADIAIgAUH4o8AAEJ0BAAvuAQIEfwF+IwBBIGsiBSQAIAEgASACaiICSwRAQQBBABCUAQALQQAhASADIARqQQFrQQAgA2txrUEEIAAoAgAiB0EBdCIGIAIgAiAGSRsiAiACQQRNGyICrX4iCUIgiFBFBEBBAEEAEJQBAAsCQCAJpyIGQYCAgIB4IANrTQR/IAUgBwR/IAUgBCAHbDYCHCAFIAAoAgQ2AhQgAwVBAAs2AhggBUEIaiADIAYgBUEUahBdIAUoAghBAUcNASAFKAIQIQggBSgCDAUgAQsgCBCUAQALIAUoAgwhASAAIAI2AgAgACABNgIEIAVBIGokAAvfAQEBfyMAQRBrIgIkACACQQA2AgwgACACQQxqAn8gAUGAAU8EQCABQYAQTwRAIAFBgIAETwRAIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAwDCyACIAFBP3FBgAFyOgAOIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAILIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECDAELIAIgAToADEEBCxAoIAJBEGokAAvjAQEIfyAAKAIIIgYEQCAAKAIEIQcDQCAHIAJBDGxqIgMoAgQhBCADKAIIIgUEQCAEQSRqIQADQCAAQQRrKAIAIgFBgICAgHhyQYCAgIB4RwRAIAAoAgAgAUEBELABCwJAIABBFGsoAgAiCEECRg0AIABBEGsoAgAhASAIRQRAIAFFDQEgAEEMaygCACABQQEQsAEMAQsgAUUNACAAQQxrKAIAIAFBAXRBAhCwAQsgAEEsaiEAIAVBAWsiBQ0ACwsgAygCACIABEAgBCAAQSxsQQQQsAELIAJBAWoiAiAGRw0ACwsL1gEBBX8jAEEgayIBJAAgACgCACICQX9GBEBBAEEAEJQBAAsgAkEBdCIDIAJBAWoiBSADIAVLGyIDQf////8DSwRAQQBBABCUAQALAkBBBCADIANBBE0bIgNBAnQiBUH8////B00EfyABIAIEfyABIAJBAnQ2AhwgASAAKAIENgIUQQQFQQALNgIYIAFBCGpBBCAFIAFBFGoQXSABKAIIQQFHDQEgASgCECEEIAEoAgwFIAQLIAQQlAEACyABKAIMIQIgACADNgIAIAAgAjYCBCABQSBqJAAL9AEBA38jAEEgayICJAAgAkEIaiIDIAFBJGooAgA2AgBB/c7AAC0AABogAiABKQIcNwMAQQxBBBCmASIEBEAgBCACKQMANwIAIARBCGogAygCADYCAAJAIAEoAgQiA0EDRiADQQJJcg0AAkACQCABLQAYQQFrDgICAAELIAJBATYCBCACQayFwAA2AgAgAkIANwIMIAIgAkEcajYCCCACQZCGwAAQhAEACyABQQhqEE4gASgCCCIDRQ0AIAEoAgwgA0EMbEEEELABCyABQShBBBCwASAAQcSEwAA2AgQgACAENgIAIAJBIGokAA8LQQRBDBDEAQAL2wEBA38jAEEQayIDJAACfyACKAIAQQFxBEBBwJXAACEEQQkMAQsgA0EEaiACKAIEIAIoAggQJEHAlcAAIAMoAgggAygCBCICGyEEQQkgAygCDCACGwshAiAEIAIgARBcAkAgACgCACIBQYCAgIB4RwRAIAFFDQEgACgCBCABQQEQsAEMAQsgAC0ABEEDRw0AIAAoAggiACgCACEBIABBBGooAgAiAigCACIFBEAgASAFEQQACyACKAIEIgUEQCABIAUgAigCCBCwAQsgAEEMQQQQsAELIANBEGokAAvDBAIGfwF+IwBBEGsiBCQAAkACQCAAKAIAQQJHBEAjAEHgAGsiAiQAAn8CQCAAKAIARQRAQQEgASAAKAIQIAAoAhQQmQENAhoMAQsgAiAAQQRqNgIIIAEoAhwhAyACIAE2AhQgAkKAgICAgMjQBzcCDCACQQhqrUKAgICAgAqEIQgCQAJ/IANBBHEEQCACIAg3AzAgAkEBNgIsIAJBATYCHCACQcimwAA2AhggAkEBNgIkIAJBAzoAWCACQQQ2AlQgAkIgNwJMIAJBAjYCRCACQQI2AjwgAiACQTxqNgIoIAIgAkEwajYCICACQQxqQYScwAAgAkEYahApDAELIAJBATYCQCACQcimwAA2AjwgAkIBNwJIIAIgCDcDGCACIAJBGGo2AkQgAkEMakGEnMAAIAJBPGoQKQsiA0EAIAIoAgwiBRtFBEAgAw0BIAVFDQJB9KbAAEE3IAJB3wBqQeSmwABBrKfAABBlAAsgAUHQpsAAQRQQmQFFDQELQQEMAQsgASAAKAIYIAAoAhwQmQELIAJB4ABqJAAhBQwBCyAAKAIkIgJFDQAgACgCICEAA0AgBEEEaiAAIAIQJAJAAkAgBCgCBEUEQCAEKAIIIAQoAgwgARDGAQ0BDAQLIAQtAA0hAyAELQAMIQYgBCgCCCEHQcmVwABBAyABEMYBRQ0BC0EBIQUMAgsgBkEBcUUNASACIAMgB2oiA0kNAiAAIANqIQAgAiADayICDQALCyAEQRBqJAAgBQ8LIAMgAkGol8AAEGgAC9kBACAAQSBJBEBBAA8LIABB/wBJBEBBAQ8LIABBgIAETwRAIABBgIAITwRAIABB4P//AHFB4M0KRyAAQf7//wBxQZ7wCkdxIABBwO4Ka0F6SXEgAEGwnQtrQXJJcSAAQfDXC2tBcUlxIABBgPALa0HebElxIABBgIAMa0GedElxIABB0KYMa0F7SXEgAEGAgjhrQbDFVElxIABB8IM4SXEPCyAAQZC5wABBLEHoucAAQdABQbi7wABB5gMQOg8LIABBnr/AAEEoQe6/wABBogJBkMLAAEGpAhA6C7UBAQR/IwBBIGsiASQAIAAoAgAiAkF/RgRAQQBBABCUAQALQQggAkEBdCIDIAJBAWoiBCADIARLGyIDIANBCE0bIgNBAEgEQEEAQQAQlAEACyABIAIEfyABIAI2AhwgASAAKAIENgIUQQEFQQALNgIYIAFBCGpBASADIAFBFGoQXSABKAIIQQFGBEAgASgCDCABKAIQEJQBAAsgASgCDCECIAAgAzYCACAAIAI2AgQgAUEgaiQAC7UBAQJ/IwBBIGsiAyQAIAEgASACaiICSwRAQQBBABCUAQALQQggACgCACIBQQF0IgQgAiACIARJGyICIAJBCE0bIgRBAEgEQEEAQQAQlAEACyADIAEEfyADIAE2AhwgAyAAKAIENgIUQQEFQQALNgIYIANBCGpBASAEIANBFGoQXSADKAIIQQFGBEAgAygCDCADKAIQEJQBAAsgAygCDCEBIAAgBDYCACAAIAE2AgQgA0EgaiQAC8gBAgN/AX4jAEEQayIEJAACQCAAKAIQIgNFBEAMAQtBASECQfKkwABBASADEMYBDQAgAVAEQEHyo8AAQQEgAxDGASECDAELAkAgASAANQIUIgVYBEAgBSABfSIBQhpUDQFB8qPAAEEBIAMQxgENAiAEIAE3AwggBEEIaiADELQBIQIMAgtByKTAAEEQIAMQxgENAUEAIQIgAEEAOgAEIABBADYCAAwBCyAEIAGnQeEAajYCBCAEQQRqIAMQRiECCyAEQRBqJAAgAgudAQEDfwJAIAFBEEkEQCAAIQIMAQsgAEEAIABrQQNxIgRqIQMgBARAIAAhAgNAIAJBADoAACACQQFqIgIgA0kNAAsLIAMgASAEayIBQXxxIgRqIQIgBEEASgRAA0AgA0EANgIAIANBBGoiAyACSQ0ACwsgAUEDcSEBCyABBEAgASACaiEBA0AgAkEAOgAAIAJBAWoiAiABSQ0ACwsgAAvBAQIDfwF+IwBBMGsiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBFGoiBEEANgIAIAJCgICAgBA3AgwgAkEgaiADKAIAIgNBCGopAgA3AwAgAkEoaiADQRBqKQIANwMAIAIgAykCADcDGCACQQxqQayRwAAgAkEYahApGiACQQhqIAQoAgAiAzYCACACIAIpAgwiBTcDACABQQhqIAM2AgAgASAFNwIACyAAQaSWwAA2AgQgACABNgIAIAJBMGokAAuWAgECfyMAQSBrIgUkAEGcz8AAQZzPwAAoAgAiBkEBajYCAAJAAn9BACAGQQBIDQAaQQFB6NLAAC0AAA0AGkHo0sAAQQE6AABB5NLAAEHk0sAAKAIAQQFqNgIAQQILQf8BcSIGQQJHBEAgBkEBcUUNASAFQQhqIAAgASgCGBECAAALQZDPwAAoAgAiBkEASA0AQZDPwAAgBkEBajYCAEGQz8AAQZTPwAAoAgAEfyAFIAAgASgCFBECACAFIAQ6AB0gBSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIMIANB+LHAADYCCCADQgI3AhQgA0KAgICA8AIiBCADQQRqrYQ3AyggAyAEIAOthDcDICADIANBIGo2AhAgA0EIaiACEIQBAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0GsssAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2MBAX8jAEEQayIAJAACfyACKAIABEBBwJXAACEDQQkMAQsgAEEEaiACKAIEIAIoAggQJEHAlcAAIAAoAgggACgCBCICGyEDQQkgACgCDCACGwshAiADIAIgARBcIABBEGokAAtnACMAQTBrIgAkAEH8zsAALQAABEAgAEECNgIMIABB8JXAADYCCCAAQgE3AhQgACABNgIsIAAgAEEsaq1CgICAgPAChDcDICAAIABBIGo2AhAgAEEIakGQlsAAEIQBAAsgAEEwaiQAC+caAhJ/AX4jAEEgayIPJAACfyAAKAIAIgAoAgAEQAJ/IAEhDCMAQTBrIgYkACAAKAIIIREgACgCBCEIIAAoAgAhDgJAAkACQAJAAkADQAJAIBEgECIJRgRAQQAhAgwBCyAIRQ0GIAkgEUchEiAJQQFqIRAgCEEBayEHIA4iBC0AACEBQQAhAAJAAkACQAJAA0ACQCABwEEASARAIAFBH3EhAiAAIARqIgVBAWotAABBP3EhAyABQf8BcSIOQd8BTQRAIAJBBnQgA3IhAQwCCyAFQQJqLQAAQT9xIANBBnRyIQEgDkHwAUkEQCABIAJBDHRyIQEMAgsgAkESdEGAgPAAcSAFQQNqLQAAQT9xIAFBBnRyciIBQYCAxABHDQEMDQsgAUH/AXEhAQsCQAJAIAFBMGtBCU0EQCAAIAdGDQ4gACAEaiICQQFqLAAAIgFBv39KDQEgAiAIIABrIgBBASAAQcCdwAAQnQEACyAABEAgACAEaiwAAEG/f0wNAgsgBkEUaiEHIAQhAkEAIQMCQAJAAkACQAJAAkACQCAAIgEOAgQAAQtBASEDIAItAABBK2sOAwMBAwELIAItAABBK0YEQCACQQFqIQIgAUEKSSABQQFrIgMhAQ0BDAILIAEhAyABQQhLDQELQQAhBQNAIAItAABBMGsiAUEJSwRAQQEhAwwDCyACQQFqIQIgASAFQQpsaiEFIANBAWsiAw0ACwwCC0EAIQUDQCABRQ0CIAItAABBMGsiDkEJSwRAQQEhAwwCC0ECIQMgBa1CCn4iFEIgiKcNASACQQFqIQIgAUEBayEBIA4gFKciCmoiBSAKTw0ACwsgByADOgABIAdBAToAAAwBCyAHIAU2AgQgB0EAOgAACyAGLQAUDQMgCCAGKAIYIgVrIQoCQCAFRQ0AIAggAGsiASAFSwRAIAQgBWogAGoiAiwAAEG/f0wNBiACLAAAQb9/Sg0BIAAgBGogAUEAIAVB8J3AABCdAQALIAAgCkcNBQsgACAEaiIBIQcgBCAFaiAAaiEOIAVFIBAgEUdyDQYgDCgCHEEEcUUNBiAHLQAAQegARw0GIAVBAUcEQCABQQFqLAAAQb9/TA0GCyAAIARqQQFqIQEDQEEAIQIgASAORg0IAn8gASwAACIDQQBOBEAgA0H/AXEhCCABQQFqDAELIAEtAAFBP3EhDSADQR9xIQggA0FfTQRAIAhBBnQgDXIhCCABQQJqDAELIAEtAAJBP3EgDUEGdHIhDSADQXBJBEAgDSAIQQx0ciEIIAFBA2oMAQsgCEESdEGAgPAAcSABLQADQT9xIA1BBnRyciIIQYCAxABGDQkgAUEEagshASAIQTBrQQpJIAhBIHJB4QBrQQZJcg0ACwwGCyAAQQFqIQAMAQsLIAQgCEEAIABB0J3AABCdAQALIAYgBi0AFToACEGEm8AAQSsgBkEIakG0n8AAQcSfwAAQZQALIAAgBGogASAFIAFB4J3AABCdAQALIAEgBUEBIAVBoJ3AABCdAQALAkAgCUUNACAMQYCewABBAhCZAUUNACASIQIMAQsCQCAFQQJJDQAgBy8AAEHfyABHDQAgACAEaiIBQQFqIgcsAABBv39MDQMgBUEBayEFCyAKIABrIQgDQCAHIQQCQAJAAkACQAJAAkACQAJAAkACQCAFIgNFDQACQCAELQAAQSRrDgsCAQEBAQEBAQEBAAELIANBAUYNBSAELAABQb9/Sg0EIAQgA0EBIANBgJ/AABCdAQALIAMgBGohCUEAIQAgBCEBA0AgACECIAEiACAJRg0IAn8gACwAACIFQQBOBEAgBUH/AXEhBSAAQQFqDAELIAAtAAFBP3EhByAFQR9xIQEgBUFfTQRAIAFBBnQgB3IhBSAAQQJqDAELIAAtAAJBP3EgB0EGdHIhByAFQXBJBEAgByABQQx0ciEFIABBA2oMAQsgAUESdEGAgPAAcSAALQADQT9xIAdBBnRyciEFIABBBGoLIgEgAiAAa2ohACAFQSRrDgsCAAAAAAAAAAAAAgALAAsgA0EBRg0BIAQsAAFBv39KDQEgBCADQQEgA0G0nsAAEJ0BAAsCQAJAAkAgAgRAAkAgAiADTyIARQRAIAIgBGosAABBv39MDQEgDCAEIAIQmQFFDQRBASECDA4LIAIgA0YNAgsgBCADQQAgAkGUnsAAEJ0BAAsgDCAEIAIQmQFFDQJBASECDAsLIAwgBCACEJkBRQ0AQQEhAgwKCyAARQRAIAIgBGosAABBv39KDQEMDwsgAiADRw0OCyACIARqIQcgAyACayEFDAcLIAYgA0EBayIANgIkIAZBADYCICAGIAA2AhwgBkEkNgIUIAZBJDYCKCAGQQE6ACwgBiAEQQFqIgA2AhggBkEIaiAGQRRqEC4gBigCCEEBRw0EAkAgBigCDCICQX9HBEAgAkEBaiEBIANBAUcNAQwFCyMAQSBrIgAkACAAQQA2AhggAEEBNgIMIABB2LPAADYCCCAAQgQ3AhAgAEEIakHEnsAAEIQBAAsgACwAAEG/f0oNAwwLCwJAAn8gBCwAASIAQQBOBEAgAEH/AXEMAQsgBC0AAkE/cSICIABBH3EiAUEGdHIgAEFfTQ0AGiAELQADQT9xIAJBBnRyIgIgAUEMdHIgAEFwSQ0AGiABQRJ0QYCA8ABxIAQtAARBP3EgAkEGdHJyC0EuRwRAQQEhAiAMQaCfwABBARCZAQ0IIAQsAAFBQEgNAQwDCyAMQYCewABBAhCZAQRAQQEhAgwICwJAIANBA08EQCAELAACQUBIDQELIARBAmohByADQQJrIQUMBwsgBCADQQIgA0GQn8AAEJ0BAAsgBCADQQEgA0Gkn8AAEJ0BAAtBASECIAxBoJ/AAEEBEJkBDQULIARBAWohByADQQFrIQUMAwsCQAJAAkACQCABIANJBEAgASAEaiwAAEFASA0MIAJBAmohAQwBCyABIANHDQsgAkECaiIBRQ0BCwJAIAEgA0kEQCABIARqLAAAQb9/Sg0BDAsLIAEgA0cNCgsgASAEaiEHIAMgAWshBQJAAkAgAg4DBQEAAgsgAC8AAEHToAFGBEBB/57AACEADAYLIAAvAABBwqABRgRAQf6ewAAhAAwGCyAALwAAQdKMAUYEQEH9nsAAIQAMBgsgAC8AAEHMqAFGBEBB/J7AACEADAYLIAAvAABBx6gBRgRAQfuewAAhAAwGCyAALwAAQcygAUYEQEH6nsAAIQAMBgsgAC8AAEHSoAFHDQFB+Z7AACEADAULIAAtAABBwwBGBEBB+J7AACEADAULIAAtAABB9QBGDQEMAwsgBC0AAUH1AEcNAiACQQJJDQEgBCwAAkG/f0wNAQsgACACaiETIAJBAWshCSAEQQJqIgIhAAJAA0BBASENIAAgE0YNAQJ/IAAsAAAiAUEATgRAIAFB/wFxIQEgAEEBagwBCyAALQABQT9xIQsgAUEfcSEKIAFBX00EQCAKQQZ0IAtyIQEgAEECagwBCyAALQACQT9xIAtBBnRyIQsgAUFwSQRAIAsgCkEMdHIhASAAQQNqDAELIApBEnRBgIDwAHEgAC0AA0E/cSALQQZ0cnIiAUGAgMQARg0CIABBBGoLIQAgAUEwa0EKSSABQeEAa0EGSXINAAtBACENCyAGQRRqIQoCQAJAAkACQAJAAkACQCAJIgAOAgABAgsgCkEAOgABDAQLIAItAAAiAUEraw4DAgECAQsgAi0AACEBCwJAAkACQCABQf8BcUErRgRAIABBAWshASACQQFqIQIgAEEJSwRAIAEhAAwCCyABIgANAkEAIQEMAwsgAEEISw0ADAELQQAhAQJAA0AgAEUNAyACLQAAIgtBMGsiCUEKTwRAQX8gC0EgciIJQdcAayILIAsgCUHhAGtJGyIJQRBPDQULIAGtQgSGIhRCIIinDQEgAkEBaiECIABBAWshACAJIBSnIgtqIgEgC08NAAsgCkECOgABDAQLIApBAjoAAQwDC0EAIQEDQCACLQAAIgtBMGsiCUEKTwRAQX8gC0EgciIJQdcAayILIAsgCUHhAGtJGyIJQRBPDQMLIAJBAWohAiAJIAFBBHRqIQEgAEEBayIADQALCyAKIAE2AgQgCkEAOgAADAILIApBAToAASAKQQE6AAAMAQsgCkEBOgAACyAGLQAUDQEgDUVBgIDEACAGKAIYIgAgAEGAsANzQYCAxABrQYCQvH9JGyIAQYCAxABGcg0BIAYgADYCBCAAQSBJIABB/wBrQSFJcg0BIAZBBGogDBBGRQ0DQQEhAgwECyAAIAJBASACQeiewAAQnQEACyASIQIgDCAEIAMQmQFFDQMMAgtBASECIAwgAEEBEJkBRQ0ACwsLIAZBMGokACACDAULIAEgBUEBIAVBhJ7AABCdAQALIAQgAyABIANB1J7AABCdAQALIAQgA0EBIAFBxJ7AABCdAQALIAQgAyACIANBpJ7AABCdAQALQbCdwAAQswEACwwBCyAPQQA2AhwgDyABNgIYIA9CADcCECAPIAApAgQ3AgggD0EIakEBEBILIA9BIGokAAuYAQIDfwFvIwBBIGsiAyQAIAMgACgCABDLASIENgIAIAMgAjYCBCACIARHBEAgA0EANgIIIAMgA0EEaiADQQhqEH4ACxCeASIEEJUBIgUlARAFIQYQMyICIAYmASAFQYQBTwRAIAUQWgsgAiAAKAIAIAFBAnYQrwEgAkGEAU8EQCACEFoLIARBhAFPBEAgBBBaCyADQSBqJAALUAEBfyMAQTBrIgAkACAAQQE2AgwgAEGorMAANgIIIABCATcCFCAAIABBL2qtQoCAgIDwC4Q3AyAgACAAQSBqNgIQIABBCGpB/IPAABCEAQALQwEDfwJAIAJFDQADQCAALQAAIgQgAS0AACIFRgRAIABBAWohACABQQFqIQEgAkEBayICDQEMAgsLIAQgBWshAwsgAwtBAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEEQgACgCCCEDCyAAKAIEIANqIAEgAhA8GiAAIAIgA2o2AghBAAtBAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEEogACgCCCEDCyAAKAIEIANqIAEgAhA8GiAAIAIgA2o2AghBAAtPAQJ/IAAoAgQhAiAAKAIAIQMCQCAAKAIIIgAtAABFDQAgA0HkrsAAQQQgAigCDBEBAEUNAEEBDwsgACABQQpGOgAAIAMgASACKAIQEQAAC0cBAX8jAEEQayICJAAgAkEIaiABEHogAiACKAIIIAIoAgwoAhgRAgAgAigCBCEBIAAgAigCADYCACAAIAE2AgQgAkEQaiQAC08BAn9B/c7AAC0AABogASgCBCECIAEoAgAhA0EIQQQQpgEiAUUEQEEEQQgQxAEACyABIAI2AgQgASADNgIAIABBtJbAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhBVIAAoAgghAwsgACgCBCADaiABIAIQPBogACACIANqNgIIQQALQgEBfyMAQSBrIgMkACADQQA2AhAgA0EBNgIEIANCBDcCCCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQhAEACz0BAn8gACAAKAIEIgMgAms2AgQgACAAKAIAIAIgA0tyIgQ2AgBBASEDIAQEfyADBSAAKAIIIAEgAhCZAQsLPgEBfyMAQRBrIgIkACACQQhqIAEgASgCACgCBBECACACKAIMIQEgACACKAIINgIAIAAgATYCBCACQRBqJAALxAIBA38gACgCACECIAEoAhwiAEEQcUUEQCAAQSBxRQRAIAIgARCyAQ8LQQAhACMAQYABayIEJAAgAigCACECA0AgACAEakH/AGogAkEPcSIDQTByIANBN2ogA0EKSRs6AAAgAEEBayEAIAJBEEkgAkEEdiECRQ0ACyAAQYABaiICQYEBTwRAIAJBgAFBjK/AABBoAAsgAUGcr8AAQQIgACAEakGAAWpBACAAaxAhIARBgAFqJAAPC0EAIQAjAEGAAWsiBCQAIAIoAgAhAgNAIAAgBGpB/wBqIAJBD3EiA0EwciADQdcAaiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAkGAAUGMr8AAEGgACyABQZyvwABBAiAAIARqQYABakEAIABrECEgBEGAAWokAAvNAwEDfyAAKAIAIQAgASgCHCIDQRBxRQRAIANBIHFFBEAjAEEQayIDJAACQAJAAkAgAC0AACIAQeQATwRAIAMgACAAQeQAbiIAQeQAbGtB/wFxQQF0QZ6vwABqLwAAOwAODAELQQIhAiAAQQpPDQELIANBDWogAmogAEEwcjoAAAwBC0EBIQIgAyAAQQF0QZ6vwABqLwAAOwAOCyABQQFBACADQQ1qIAJqIAJBA3MQISADQRBqJAAPCyMAQYABayIEJAAgAC0AACEAA0AgAiAEakH/AGogAEEPcSIDQTByIANBN2ogA0EKSRs6AAAgAkEBayECIAAiA0EEdiEAIANBEE8NAAsgAkGAAWoiAEGBAU8EQCAAQYABQYyvwAAQaAALIAFBnK/AAEECIAIgBGpBgAFqQQAgAmsQISAEQYABaiQADwsjAEGAAWsiBCQAIAAtAAAhAANAIAIgBGpB/wBqIABBD3EiA0EwciADQdcAaiADQQpJGzoAACACQQFrIQIgACIDQQR2IQAgA0EQTw0ACyACQYABaiIAQYEBTwRAIABBgAFBjK/AABBoAAsgAUGcr8AAQQIgAiAEakGAAWpBACACaxAhIARBgAFqJAALOAACQCACQYCAxABGDQAgACACIAEoAhARAABFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAQALOQEBfyMAQRBrIgMkACADIAE2AgwgAyAANgIIIANBCGpBiI/AACADQQxqQYiPwAAgAkH4jsAAEDgACzwBAX8jAEEQayICJAAgAkGUkcAANgIMIAIgADYCCCACQQhqQZiRwAAgAkEMakGYkcAAIAFBjJXAABA4AAvcBAIHfwF+IwBBEGsiBiQAIAYgADYCDCAGQQxqIQgjAEEQayICJAAgASgCFEHwm8AAQQ0gASgCGCgCDBEBACEAIAJBADoADSACIAA6AAwgAiABNgIIIwBBQGoiACQAQQEhAwJAIAJBCGoiBC0ABA0AIAQtAAUhBSAEKAIAIgEoAhwiB0EEcUUEQCABKAIUQeuuwABB6K7AACAFQQFxIgUbQQJBAyAFGyABKAIYKAIMEQEADQEgASgCFEH9m8AAQQQgASgCGCgCDBEBAA0BIAEoAhRBuK7AAEECIAEoAhgoAgwRAQANASAIIAFB7JvAACgCABEAACEDDAELIAVBAXFFBEAgASgCFEHtrsAAQQMgASgCGCgCDBEBAA0BIAEoAhwhBwsgAEEBOgAbIAAgASkCFDcCDCAAQcyuwAA2AjQgACAAQRtqNgIUIAAgASkCCDcCJCABKQIAIQkgACAHNgI4IAAgASgCEDYCLCAAIAEtACA6ADwgACAJNwIcIAAgAEEMaiIBNgIwIAFB/ZvAAEEEECoNACABQbiuwABBAhAqDQAgCCAAQRxqQeybwAAoAgARAAANACAAKAIwQfCuwABBAiAAKAI0KAIMEQEAIQMLIARBAToABSAEIAM6AAQgAEFAayQAIAItAA0iASACLQAMIgNyIQACQCADQQFxIAFBAUdyDQAgBCgCACIALQAcQQRxRQRAIAAoAhRB867AAEECIAAoAhgoAgwRAQAhAAwBCyAAKAIUQfKuwABBASAAKAIYKAIMEQEAIQALIAJBEGokACAAQQFxIAZBEGokAAsvAQF/IwBBEGsiAiQAIAJBCGogABB6IAIoAgggASACKAIMKAIQEQAAIAJBEGokAAs5AQF/QQEhAgJAIAAgARA/DQAgASgCFEH0q8AAQQIgASgCGCgCDBEBAA0AIABBBGogARA/IQILIAIL1hMCF30LfxAzIiMgCSYBAn8gCCEqIwBBMGsiIiQAICIgIzYCBCAiQoCAgIDAADcCCCAiQQA2AhBB7M7AACErQejOwAAoAgBFBEACf0H9zsAALQAAGgJAQYCAwAAQESIIRQ0AIAhBBGstAABBA3FFDQAgCEGAgMAAEFcaCyAIBEBB+M7AAEGAgBA2AgBB7M7AAEEANgIAQfTOwAAoAgAhI0H0zsAAIAg2AgBB8M7AACgCACEmQfDOwABBgIAQNgIAQejOwAAoAgBB6M7AAEEBNgIARSAmRXJFBEAgIyAmQQJ0QQQQsAELQezOwAAMAQtBBEGAgMAAEJQBAAshKwsgKygCAEUEQCArQX82AgACQCArAn8gKkUEQEEAISNBAAwBCyArQQxqKAIAISwgK0EIaigCACEIAkAgCgRAQQAhIwNAICIgIkEEaiAjQQJ0ICNBgIAEICogI2siCiAKQYCABE8bIgpqIiZBAnQQsQE2AhQgCkECdCIjICxLDQQgIkEUaiAIICMQbyAiIAI4AiAgIiABOAIcICIgADgCGCAiIAU4AiwgIiAEOAIoICIgAzgCJCAIIQojAEEQayInJAAgIwRAICJBCGohKCAiQSRqIiQqAgAhFSAkKgIEIRggJCoCCCEZICJBGGoiJCoCCCEfICQqAgQhICAkKgIAISEDQCAjQQQgI0EESSIkGyEpAkAgCi0AA7NDAAB/Q5VDzczMPV0NACAnQQRqIAogKRAmAn0CQCAkRQRAICcqAgwhDiAnKgIIIQwgJyoCBCELQwAAAAAhFkMAAAAAIRcgCigCDCIlQf8BcQRAICVBAWtB/wFxs0NFIpE9lEMAABDBkhAsIRcLICVBCHYiJEH/AXEEQCAkQQFrQf8BcbNDRSKRPZRDAAAQwZIQLCEWCyAfIA6TIQ8gICAMkyESICEgC5MhESAlQRB2IiRB/wFxDQFDAAAAAAwCC0EDIClBnIPAABBpAAsgJEEBa0H/AXGzQ0UikT2UQwAAEMGSECwLIRogGSAKKAIIIiRBGHWyQwAA/kKVIhMgGCAlQRh1skMAAP5ClSIUlCAZIBOUkyIQlCAkQRB2wLJDAAD+QpUiDSAZIA2UIBUgFJSTIg6UkyAVIBOUIBggDZSTIgxDAACAPyANIA2UkyATIBOUkyAUIBSUk0MAAAAAEJIBkSIblJIiCyALkpIhHCAYIA0gDJQgFCAQlJMgDiAblJIiCyALkpIhHSAVIBQgDpQgEyAMlJMgECAblJIiCyALkpIhHiAPIBMgEiAUlCAPIBOUkyIQlCANIA8gDZQgESAUlJMiDpSTIBEgE5QgEiANlJMiDCAblJIiCyALkpIhDyASIA0gDJQgFCAQlJMgDiAblJIiCyALkpIhDSARIBQgDpQgEyAMlJMgECAblJIiCyALkpIhDAJAIBogFyAWEJIBIBoQkgFDCtcjPJQiC11FBEAgCyAWXkUEQCALIBdeRQRAQwAAgD8gGpUiCyAPlCIPIAsgHJQiEpRDAACAPyAXlSILIAyUIhEgCyAelCIMlEMAAIA/IBaVIgsgDZQiECALIB2UIguUkpIiDiAOlCASIBKUIAwgDJQgCyALlJKSIgwgDyAPlCARIBGUIBAgEJSSkkMAAIC/kpSTIgtDAAAAAF0NBCAOjCALkZMgDJUhDAwDCyAei0O9N4Y1XQ0DIA0gHSAMjCAelSIMlJIgFpUiCyALlCAPIBwgDJSSIBqVIgsgC5SSQwAAgD9eRQ0CDAMLIB2LQ703hjVdDQIgDCAeIA2MIB2VIgyUkiAXlSILIAuUIA8gHCAMlJIgGpUiCyALlJJDAACAP14NAgwBCyAci0O9N4Y1XQ0BIAwgHiAPjCAclSIMlJIgF5UiCyALlCANIB0gDJSSIBaVIgsgC5SSQwAAgD9eDQELIAYgDF9FIAcgDGBFcg0AICgoAggiJCAoKAIARgRAICgQTwsgKCgCBCAkQQJ0aiAMOAIAICggJEEBajYCCAsgCiApQQJ0aiEKICMgKWsiIw0ACwsgJ0EQaiQAICIoAhQiCkGEAU8EQCAKEFoLICYiIyAqSQ0ACwwBC0EAISMDQCAiICJBBGogI0ECdCAjQYCABCAqICNrIgogCkGAgARPGyIKaiImQQJ0ELEBNgIUIApBAnQiIyAsSw0DICJBFGogCCAjEG8gIiACOAIgICIgATgCHCAiIAA4AhggIiAFOAIsICIgBDgCKCAiIAM4AiQgCCEKIwBBEGsiJyQAICMEQCAiQQhqISggIkEkaiIkKgIAIhggGJQgJCoCBCIZIBmUkiAkKgIIIg8gD5SSIRIgIkEYaiIkKgIIIR8gJCoCBCEgICQqAgAhIQNAICNBBCAjQQRJIiQbISkCQCAKLQADs0MAAH9DlUPNzMw9XQ0AICdBBGogCiApECYCfQJAICRFBEAgJyoCDCEOICcqAgghDCAnKgIEIQtDAAAAACERQwAAAAAhECAKKAIMIiVB/wFxBEAgJUEBa0H/AXGzQ0UikT2UQwAAEMGSEMwBIRALICVBCHYiJEH/AXEEQCAkQQFrQf8BcbNDRSKRPZRDAAAQwZIQzAEhEQsgHyAOkyENICAgDJMhFSAhIAuTIQ4gJUEQdiIkQf8BcQ0BQwAAAAAMAgtBAyApQZyDwAAQaQALICRBAWtB/wFxs0NFIpE9lEMAABDBkhDMAQshCyAYIA6UIBkgFZSSIA8gDZSSIgwgDJQgEiAOIA6UIBUgFZSSIA0gDZSSIBAgEZIgC5JDAABAQJUiCyALlJOUkyILQwAAAABdDQAgDIwgC5GTIBKVIgsgBmBFIAcgC2BFcg0AICgoAggiJCAoKAIARgRAICgQTwsgKCgCBCAkQQJ0aiALOAIAICggJEEBajYCCAsgCiApQQJ0aiEKICMgKWsiIw0ACwsgJ0EQaiQAICIoAhQiCkGEAU8EQCAKEFoLICYiIyAqSQ0ACwsgIigCECEjICsoAgBBAWoLNgIAICMQDSEJEDMiCCAJJgEgIiAINgIkICIoAgwhIyAiKAIQISQjAEEgayIlJAAgIkEkaigCACIKJQEQCiEmICUgJDYCBCAlICY2AgACQCAkICZGBEAQngEiKhCVASImJQEgIyAkEAghCRAzIiMgCSYBICpBhAFPBEAgKhBaCyAmQYQBTwRAICYQWgsgCiUBICMlAUEAEAkgI0GEAU8EQCAjEFoLICVBIGokAAwBCyAlQQA2AgggJSAlQQRqICVBCGoQfgALICIoAggiCgRAICIoAgwgCkECdEEEELABCyAiKAIEIgpBhAFPBEAgChBaCyAiQTBqJAAgCAwCCyAjICxB5IbAABBqAAsQcAALIgglASAIEFoL+gECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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"},42955:(A,n,t)=>{t.r(n),t.d(n,{FINGER_TIPS:()=>fo,FpsMovement:()=>Fo,HANDS:()=>wo,Hand:()=>mo,HandMovement:()=>xo,JOINT_IDS:()=>Qo,JOINT_INDEX:()=>Co,JOINT_RADIUS:()=>Eo,JOINT_SEGMENTS:()=>ho,JOINT_SEGMENT_STEPS:()=>po,JOINT_TIPS:()=>yo,JointEnum:()=>Bo,NUM_JOINTS:()=>uo,PackedSplats:()=>fr,PlyReader:()=>Vi,PointerControls:()=>No,Readback:()=>fi,Sint8ToFloat:()=>ot,SparkControls:()=>vo,SparkRenderer:()=>_r,SparkViewpoint:()=>br,SplatAccumulator:()=>vr,SplatEdit:()=>Ni,SplatEditRgbaBlendMode:()=>ki,SplatEditSdf:()=>vi,SplatEditSdfType:()=>Si,SplatEdits:()=>Ri,SplatFileType:()=>Qr,SplatGenerator:()=>Ji,SplatLoader:()=>lr,SplatMesh:()=>qi,SplatModifier:()=>_i,SplatSkinning:()=>Zr,SplatTransformer:()=>Yi,SpzReader:()=>Kr,SpzWriter:()=>Vr,Uint8ToFloat:()=>rt,VRButton:()=>lo,XrHands:()=>Do,constructAxes:()=>no,constructGrid:()=>Ao,constructSpherePoints:()=>to,dyno:()=>di,flipPixels:()=>ht,floatToSint8:()=>it,floatToUint8:()=>at,fromHalf:()=>st,generators:()=>ro,getSplatFileType:()=>ur,imageSplats:()=>so,isAndroid:()=>Ct,isMobile:()=>ut,isOculus:()=>Et,isPcSogs:()=>Er,modifiers:()=>co,pixelsToPngUrl:()=>pt,setPackedSplat:()=>It,textSplats:()=>eo,toHalf:()=>et,transcodeSpz:()=>jr,unpackSplat:()=>Bt,unpackSplats:()=>pr,utils:()=>Ft});var e=t(68909),s=Uint8Array,a=Uint16Array,i=Int32Array,r=new s([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),o=new s([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),g=new s([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),c=function(A,n){for(var t=new a(31),e=0;e<31;++e)t[e]=n+=1<<A[e-1];var s=new i(t[30]);for(e=1;e<30;++e)for(var r=t[e];r<t[e+1];++r)s[r]=r-t[e]<<5|e;return{b:t,r:s}},I=c(r,2),l=I.b,B=I.r;l[28]=258,B[258]=28;for(var Q=c(o,0).b,u=new a(32768),C=0;C<32768;++C){var E=(43690&C)>>1|(21845&C)<<1;E=(61680&(E=(52428&E)>>2|(13107&E)<<2))>>4|(3855&E)<<4,u[C]=((65280&E)>>8|(255&E)<<8)>>1}var h=function(A,n,t){for(var e=A.length,s=0,i=new a(n);s<e;++s)A[s]&&++i[A[s]-1];var r,o=new a(n);for(s=1;s<n;++s)o[s]=o[s-1]+i[s-1]<<1;if(t){r=new a(1<<n);var g=15-n;for(s=0;s<e;++s)if(A[s])for(var c=s<<4|A[s],I=n-A[s],l=o[A[s]-1]++<<I,B=l|(1<<I)-1;l<=B;++l)r[u[l]>>g]=c}else for(r=new a(e),s=0;s<e;++s)A[s]&&(r[s]=u[o[A[s]-1]++]>>15-A[s]);return r},p=new s(288);for(C=0;C<144;++C)p[C]=8;for(C=144;C<256;++C)p[C]=9;for(C=256;C<280;++C)p[C]=7;for(C=280;C<288;++C)p[C]=8;var d=new s(32);for(C=0;C<32;++C)d[C]=5;var y=h(p,9,1),f=h(d,5,1),m=function(A){for(var n=A[0],t=1;t<A.length;++t)A[t]>n&&(n=A[t]);return n},w=function(A,n,t){var e=n/8|0;return(A[e]|A[e+1]<<8)>>(7&n)&t},D=function(A,n){var t=n/8|0;return(A[t]|A[t+1]<<8|A[t+2]<<16)>>(7&n)},x=function(A){return(A+7)/8|0},S=function(A,n,t){return(null==n||n<0)&&(n=0),(null==t||t>A.length)&&(t=A.length),new s(A.subarray(n,t))},b=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],k=function(A,n,t){var e=new Error(n||b[A]);if(e.code=A,Error.captureStackTrace&&Error.captureStackTrace(e,k),!t)throw e;return e},M=function(A,n,t,e){var a=A.length,i=e?e.length:0;if(!a||n.f&&!n.l)return t||new s(0);var c=!t,I=c||2!=n.i,B=n.i;c&&(t=new s(3*a));var u=function(A){var n=t.length;if(A>n){var e=new s(Math.max(2*n,A));e.set(t),t=e}},C=n.f||0,E=n.p||0,p=n.b||0,d=n.l,b=n.d,M=n.m,v=n.n,F=8*a;do{if(!d){C=w(A,E,1);var N=w(A,E+1,3);if(E+=3,!N){var R=A[(K=x(E)+4)-4]|A[K-3]<<8,G=K+R;if(G>a){B&&k(0);break}I&&u(p+R),t.set(A.subarray(K,G),p),n.b=p+=R,n.p=E=8*G,n.f=C;continue}if(1==N)d=y,b=f,M=9,v=5;else if(2==N){var U=w(A,E,31)+257,L=w(A,E+10,15)+4,T=U+w(A,E+5,31)+1;E+=14;for(var _=new s(T),Y=new s(19),J=0;J<L;++J)Y[g[J]]=w(A,E+3*J,7);E+=3*L;var H=m(Y),q=(1<<H)-1,z=h(Y,H,1);for(J=0;J<T;){var K,P=z[w(A,E,q)];if(E+=15&P,(K=P>>4)<16)_[J++]=K;else{var O=0,V=0;for(16==K?(V=3+w(A,E,3),E+=2,O=_[J-1]):17==K?(V=3+w(A,E,7),E+=3):18==K&&(V=11+w(A,E,127),E+=7);V--;)_[J++]=O}}var j=_.subarray(0,U),Z=_.subarray(U);M=m(j),v=m(Z),d=h(j,M,1),b=h(Z,v,1)}else k(1);if(E>F){B&&k(0);break}}I&&u(p+131072);for(var $=(1<<M)-1,W=(1<<v)-1,X=E;;X=E){var AA=(O=d[D(A,E)&$])>>4;if((E+=15&O)>F){B&&k(0);break}if(O||k(2),AA<256)t[p++]=AA;else{if(256==AA){X=E,d=null;break}var nA=AA-254;if(AA>264){var tA=r[J=AA-257];nA=w(A,E,(1<<tA)-1)+l[J],E+=tA}var eA=b[D(A,E)&W],sA=eA>>4;eA||k(3),E+=15&eA;Z=Q[sA];if(sA>3){tA=o[sA];Z+=D(A,E)&(1<<tA)-1,E+=tA}if(E>F){B&&k(0);break}I&&u(p+131072);var aA=p+nA;if(p<Z){var iA=i-Z,rA=Math.min(Z,aA);for(iA+p<0&&k(3);p<rA;++p)t[p]=e[iA+p]}for(;p<aA;++p)t[p]=t[p-Z]}}n.l=d,n.p=X,n.b=p,n.f=C,d&&(C=1,n.m=M,n.d=b,n.n=v)}while(!C);return p!=t.length&&c?S(t,0,p):t.subarray(0,p)},v=new s(0),F=function(A,n){return A[n]|A[n+1]<<8},N=function(A,n){return(A[n]|A[n+1]<<8|A[n+2]<<16|A[n+3]<<24)>>>0},R=function(A,n){return N(A,n)+4294967296*N(A,n+4)},G=function(){function A(A,n){"function"==typeof A&&(n=A,A={}),this.ondata=n;var t=A&&A.dictionary&&A.dictionary.subarray(-32768);this.s={i:0,b:t?t.length:0},this.o=new s(32768),this.p=new s(0),t&&this.o.set(t)}return A.prototype.e=function(A){if(this.ondata||k(5),this.d&&k(4),this.p.length){if(A.length){var n=new s(this.p.length+A.length);n.set(this.p),n.set(A,this.p.length),this.p=n}}else this.p=A},A.prototype.c=function(A){this.s.i=+(this.d=A||!1);var n=this.s.b,t=M(this.p,this.s,this.o);this.ondata(S(t,n,this.s.b),this.d),this.o=S(t,this.s.b-32768),this.s.b=this.o.length,this.p=S(this.p,this.s.p/8|0),this.s.p&=7},A.prototype.push=function(A,n){this.e(A),this.c(n)},A}();function U(A,n){return M(A,{i:2},n&&n.out,n&&n.dictionary)}var L=function(){function A(A,n){this.v=1,this.r=0,G.call(this,A,n)}return A.prototype.push=function(A,n){if(G.prototype.e.call(this,A),this.r+=A.length,this.v){var t=this.p.subarray(this.v-1),e=t.length>3?function(A){31==A[0]&&139==A[1]&&8==A[2]||k(6,"invalid gzip data");var n=A[3],t=10;4&n&&(t+=2+(A[10]|A[11]<<8));for(var e=(n>>3&1)+(n>>4&1);e>0;e-=!A[t++]);return t+(2&n)}(t):4;if(e>t.length){if(!n)return}else this.v>1&&this.onmember&&this.onmember(this.r-t.length);this.p=t.subarray(e),this.v=0}G.prototype.c.call(this,n),!this.s.f||this.s.l||n||(this.v=x(this.s.p)+9,this.s={i:0},this.o=new s(0),this.push(new s(0),n))},A}(),T="undefined"!=typeof TextDecoder&&new TextDecoder;try{T.decode(v,{stream:!0})}catch(A){}function _(A,n){if(n){for(var t="",e=0;e<A.length;e+=16384)t+=String.fromCharCode.apply(null,A.subarray(e,e+16384));return t}if(T)return T.decode(A);var s=function(A){for(var n="",t=0;;){var e=A[t++],s=(e>127)+(e>223)+(e>239);if(t+s>A.length)return{s:n,r:S(A,t-1)};s?3==s?(e=((15&e)<<18|(63&A[t++])<<12|(63&A[t++])<<6|63&A[t++])-65536,n+=String.fromCharCode(55296|e>>10,56320|1023&e)):n+=1&s?String.fromCharCode((31&e)<<6|63&A[t++]):String.fromCharCode((15&e)<<12|(63&A[t++])<<6|63&A[t++]):n+=String.fromCharCode(e)}}(A),a=s.s;return(t=s.r).length&&k(8),a}var Y=function(A,n){return n+30+F(A,n+26)+F(A,n+28)},J=function(A,n,t){var e=F(A,n+28),s=_(A.subarray(n+46,n+46+e),!(2048&F(A,n+8))),a=n+46+e,i=N(A,n+20),r=t&&4294967295==i?H(A,a):[i,N(A,n+24),N(A,n+42)],o=r[0],g=r[1],c=r[2];return[F(A,n+10),o,g,s,a+F(A,n+30)+F(A,n+32),c]},H=function(A,n){for(;1!=F(A,n);n+=4+F(A,n+2));return[R(A,n+12),R(A,n+4),R(A,n+20)]};let q;const z="undefined"!=typeof TextDecoder?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};"undefined"!=typeof TextDecoder&&z.decode();let K=null;function P(A,n){return A>>>=0,z.decode((null!==K&&0!==K.byteLength||(K=new Uint8Array(q.memory.buffer)),K).subarray(A,A+n))}async function O(A){if(void 0!==q)return q;void 0!==A&&(Object.getPrototypeOf(A)===Object.prototype?({module_or_path:A}=A):console.warn("using deprecated parameters for the initialization function; pass a single object instead")),void 0===A&&(A=new URL(t(9933),t.b));const n=function(){const A={wbg:{}};return A.wbg.__wbg_buffer_609cc3eee51ed158=function(A){return A.buffer},A.wbg.__wbg_length_3b4f022188ae8db6=function(A){return A.length},A.wbg.__wbg_length_6ca527665d89694d=function(A){return A.length},A.wbg.__wbg_length_8cfd2c6409af88ad=function(A){return A.length},A.wbg.__wbg_new_9fee97a409b32b68=function(A){return new Uint16Array(A)},A.wbg.__wbg_new_e3b321dcfef89fc7=function(A){return new Uint32Array(A)},A.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(A,n,t){return new Float32Array(A,n>>>0,t>>>0)},A.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(A,n,t){return new Uint32Array(A,n>>>0,t>>>0)},A.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(A){return new Float32Array(A>>>0)},A.wbg.__wbg_set_10bad9bee0e9c58b=function(A,n,t){A.set(n,t>>>0)},A.wbg.__wbg_set_d23661d19148b229=function(A,n,t){A.set(n,t>>>0)},A.wbg.__wbg_set_f4f1f0daa30696fc=function(A,n,t){A.set(n,t>>>0)},A.wbg.__wbg_subarray_3aaeec89bb2544f0=function(A,n,t){return A.subarray(n>>>0,t>>>0)},A.wbg.__wbg_subarray_769e1e0f81bb259b=function(A,n,t){return A.subarray(n>>>0,t>>>0)},A.wbg.__wbindgen_init_externref_table=function(){const A=q.__wbindgen_export_0,n=A.grow(4);A.set(0,void 0),A.set(n+0,void 0),A.set(n+1,null),A.set(n+2,!0),A.set(n+3,!1)},A.wbg.__wbindgen_memory=function(){return q.memory},A.wbg.__wbindgen_throw=function(A,n){throw new Error(P(A,n))},A}();("string"==typeof A||"function"==typeof Request&&A instanceof Request||"function"==typeof URL&&A instanceof URL)&&(A=fetch(A));const{instance:e,module:s}=await async function(A,n){if("function"==typeof Response&&A instanceof Response){if("function"==typeof WebAssembly.instantiateStreaming)try{return await WebAssembly.instantiateStreaming(A,n)}catch(n){if("application/wasm"==A.headers.get("Content-Type"))throw n;console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",n)}const t=await A.arrayBuffer();return await WebAssembly.instantiate(t,n)}{const t=await WebAssembly.instantiate(A,n);return t instanceof WebAssembly.Instance?{instance:t,module:A}:t}}(await A,n);return function(A,n){return q=A.exports,O.__wbindgen_wasm_module=n,K=null,q.__wbindgen_start(),q}(e,s)}const V=-12,j=(9-V)/254,Z=Math.exp(-30),$=2048,W=2048,X=1;function AA(A){return"bool"===A||"bvec2"===A||"bvec3"===A||"bvec4"===A}function nA(A){return"int"===A||"uint"===A||"float"===A}function tA(A){return"int"===A||"ivec2"===A||"ivec3"===A||"ivec4"===A}function eA(A){return"uint"===A||"uvec2"===A||"uvec3"===A||"uvec4"===A}function sA(A){return"float"===A||"vec2"===A||"vec3"===A||"vec4"===A}function aA(A){return"mat2"===A||"mat2x2"===A||"mat2x3"===A||"mat2x4"===A||"mat3"===A||"mat3x2"===A||"mat3x3"===A||"mat3x4"===A||"mat4"===A||"mat4x2"===A||"mat4x3"===A||"mat4x4"===A}function iA(A){return sA(A)||aA(A)}function rA(A){return"vec2"===A||"ivec2"===A||"uvec2"===A}function oA(A){return"vec3"===A||"ivec3"===A||"uvec3"===A}function gA(A){return"vec4"===A||"ivec4"===A||"uvec4"===A}function cA(A){return"mat2"===A||"mat2x2"===A}function IA(A){return"mat3"===A||"mat3x3"===A}function lA(A){return"mat4"===A||"mat4x4"===A}function BA(A){switch(A){case"vec2":case"vec3":case"vec4":return"float";case"ivec2":case"ivec3":case"ivec4":return"int";case"uvec2":case"uvec3":case"uvec4":return"uint";default:throw new Error(`Invalid vector type: ${A}`)}}function QA(A){switch(A){case"vec2":case"ivec2":case"uvec2":return 2;case"vec3":case"ivec3":case"uvec3":return 3;case"vec4":case"ivec4":case"uvec4":return 4;default:throw new Error(`Invalid vector type: ${A}`)}}function uA(A){if(nA(A))return"uint";if(rA(A))return"uvec2";if(oA(A))return"uvec3";if(gA(A))return"uvec4";throw new Error(`Invalid vector type: ${A}`)}function CA(A){if("string"==typeof A)return A;if("object"==typeof A&&A.type)return A.type;throw new Error(`Invalid DynoType: ${String(A)}`)}function EA(A){return Math.trunc(A).toString()}function hA(A){return`${Math.max(0,Math.trunc(A)).toString()}u`}function pA(A){return A===Number.POSITIVE_INFINITY?"INFINITY":A===Number.NEGATIVE_INFINITY?"-INFINITY":Number.isInteger(A)?A.toFixed(1):A.toString()}function dA(A){if(A instanceof yA)return A.type;return A.dynoOut().type}class yA{constructor(A){this.__isDynoValue=!0,this.type=A}}class fA extends yA{constructor(A,n){super(A.outTypes[n]),this.dyno=A,this.key=n}}class mA extends yA{constructor(A,n){super(A),this.literal=n}getLiteral(){return this.literal}}function wA(A,n){return new mA(A,n)}class DA extends mA{constructor(A,n){super(A,""),this.value=n}getLiteral(){const{type:A,value:n}=this;switch(A){case"bool":return n?"true":"false";case"uint":return hA(n);case"int":return EA(n);case"float":return pA(n);case"bvec2":{const A=n;return`bvec2(${A[0]}, ${A[1]})`}case"uvec2":{if(n instanceof e.Vector2)return`uvec2(${hA(n.x)}, ${hA(n.y)})`;const A=n;return`uvec2(${hA(A[0])}, ${hA(A[1])})`}case"ivec2":{if(n instanceof e.Vector2)return`ivec2(${EA(n.x)}, ${EA(n.y)})`;const A=n;return`ivec2(${EA(A[0])}, ${EA(A[1])})`}case"vec2":{if(n instanceof e.Vector2)return`vec2(${pA(n.x)}, ${pA(n.y)})`;const A=n;return`vec2(${pA(A[0])}, ${pA(A[1])})`}case"bvec3":{const A=n;return`bvec3(${A[0]}, ${A[1]}, ${A[2]})`}case"uvec3":{if(n instanceof e.Vector3)return`uvec3(${hA(n.x)}, ${hA(n.y)}, ${hA(n.z)})`;const A=n;return`uvec3(${hA(A[0])}, ${hA(A[1])}, ${hA(A[2])})`}case"ivec3":{if(n instanceof e.Vector3)return`ivec3(${EA(n.x)}, ${EA(n.y)}, ${EA(n.z)})`;const A=n;return`ivec3(${EA(A[0])}, ${EA(A[1])}, ${EA(A[2])})`}case"vec3":{if(n instanceof e.Vector3)return`vec3(${pA(n.x)}, ${pA(n.y)}, ${pA(n.z)})`;const A=n;return`vec3(${pA(A[0])}, ${pA(A[1])}, ${pA(A[2])})`}case"bvec4":{const A=n;return`bvec4(${A[0]}, ${A[1]}, ${A[2]}, ${A[3]})`}case"uvec4":{if(n instanceof e.Vector4)return`uvec4(${hA(n.x)}, ${hA(n.y)}, ${hA(n.z)}, ${hA(n.w)})`;const A=n;return`uvec4(${hA(A[0])}, ${hA(A[1])}, ${hA(A[2])}, ${hA(A[3])})`}case"ivec4":{if(n instanceof e.Vector4)return`ivec4(${EA(n.x)}, ${EA(n.y)}, ${EA(n.z)}, ${EA(n.w)})`;const A=n;return`ivec4(${EA(A[0])}, ${EA(A[1])}, ${EA(A[2])}, ${EA(A[3])})`}case"vec4":{if(n instanceof e.Vector4)return`vec4(${pA(n.x)}, ${pA(n.y)}, ${pA(n.z)}, ${pA(n.w)})`;if(n instanceof e.Quaternion)return`vec4(${pA(n.x)}, ${pA(n.y)}, ${pA(n.z)}, ${pA(n.w)})`;const A=n;return`vec4(${pA(A[0])}, ${pA(A[1])}, ${pA(A[2])}, ${pA(A[3])})`}case"mat2":case"mat2x2":{const t=n,s=t instanceof e.Matrix2?t.elements:n,a=new Array(4).fill(0).map(((A,n)=>pA(s[n])));return`${A}(${a.join(", ")})`}case"mat2x3":{const t=n,e=new Array(6).fill(0).map(((A,n)=>pA(t[n])));return`${A}(${e.join(", ")})`}case"mat2x4":{const t=n,e=new Array(8).fill(0).map(((A,n)=>pA(t[n])));return`${A}(${e.join(", ")})`}case"mat3":case"mat3x3":{const t=n,s=t instanceof e.Matrix3?t.elements:n,a=new Array(9).fill(0).map(((A,n)=>pA(s[n])));return`${A}(${a.join(", ")})`}case"mat3x2":{const t=n,e=new Array(6).fill(0).map(((A,n)=>pA(t[n])));return`${A}(${e.join(", ")})`}case"mat3x4":{const t=n,e=new Array(12).fill(0).map(((A,n)=>pA(t[n])));return`${A}(${e.join(", ")})`}case"mat4":case"mat4x4":{const t=n,s=t instanceof e.Matrix4?t.elements:n,a=new Array(16).fill(0).map(((A,n)=>pA(s[n])));return`${A}(${a.join(", ")})`}case"mat4x2":{const t=n,e=new Array(8).fill(0).map(((A,n)=>pA(t[n])));return`${A}(${e.join(", ")})`}case"mat4x3":{const t=n,e=new Array(12).fill(0).map(((A,n)=>pA(t[n])));return`${A}(${e.join(", ")})`}default:throw new Error(`Type not implemented: ${String(A)}`)}}}function xA(A,n){return new DA(A,n)}function SA(A){const n=String(A);if(AA(A))return`${n}(false)`;if(iA(A))return`${n}(0.0)`;if(tA(A))return`${n}(0)`;if(eA(A))return`${n}(0u)`;throw new Error(`Type not implemented: ${n}`)}const bA="    ";class kA{constructor({indent:A}={}){this.globals=new Set,this.statements=[],this.uniforms={},this.declares=new Set,this.updaters=[],this.sequence=0,this.indent=bA,this.indent=A??bA}nextSequence(){return this.sequence++}}class MA{constructor({inTypes:A,outTypes:n,inputs:t,update:e,globals:s,statements:a,generate:i}){this.inTypes=A??{},this.outTypes=n??{},this.inputs=t??{},this.update=e,this.globals=s,this.statements=a,this.generate=i??(({inputs:A,outputs:n,compile:t})=>{var e,s;return{globals:null==(e=this.globals)?void 0:e.call(this,{inputs:A,outputs:n,compile:t}),statements:null==(s=this.statements)?void 0:s.call(this,{inputs:A,outputs:n,compile:t})}})}get outputs(){const A={};for(const n in this.outTypes)A[n]=new fA(this,n);return A}apply(A){return Object.assign(this.inputs,A),this.outputs}compile({inputs:A,outputs:n,compile:t}){const e=[`// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(n).join(", ")})`],s=[];for(const A in n){const e=n[A];e&&!t.declares.has(e)&&(t.declares.add(e),s.push(A))}const{globals:a,statements:i,uniforms:r}=this.generate({inputs:A,outputs:n,compile:t});for(const A of a??[])t.globals.add(A);for(const A in r)t.uniforms[A]=r[A];this.update&&t.updaters.push(this.update);for(const A of s){const s=n[A];s&&(t.uniforms[s]||e.push(`${RA(s,this.outTypes[A])};`))}return(null==i?void 0:i.length)&&(e.push("{"),e.push(...i.map((A=>t.indent+A))),e.push("}")),e}}class vA extends MA{constructor({inTypes:A,outTypes:n,inputs:t,update:e,globals:s,construct:a}){super({inTypes:A,outTypes:n,inputs:t,update:e,globals:s,generate:A=>this.generateBlock(A)}),this.construct=a}generateBlock({inputs:A,outputs:n,compile:t}){var e,s;const a={},i={};for(const n in A)null!=A[n]&&(a[n]=new mA(this.inTypes[n],A[n]));for(const A in n)null!=n[A]&&(i[A]=new yA(this.outTypes[A]));const r={roots:[]},o=this.construct(a,i,r);for(const s of(null==(e=this.globals)?void 0:e.call(this,{inputs:A,outputs:n,compile:t}))??[])t.globals.add(s);const g=[],c=new Map;function I(A,n,e){let s=c.get(A);if(!s){s={sequence:t.nextSequence(),outNames:new Map,newOuts:new Set},c.set(A,s);for(const n in A.inputs){let t=A.inputs[n];for(;t;){if(t instanceof yA){t instanceof fA&&I(t.dyno,t.key);break}t=t.dynoOut()}}g.push(A)}n&&(e||s.newOuts.add(n),s.outNames.set(n,e??`${n}_${s.sequence}`))}for(const A of r.roots)I(A);for(const A in i){let t=(null==o?void 0:o[A])??i[A];for(;t;){if(t instanceof yA){t instanceof fA&&I(t.dyno,t.key,n[A]);break}t=t.dynoOut()}i[A]=t}const l=[];for(const A of g){const n={},e={};for(const t in A.inputs){let e=A.inputs[t];for(;e;){if(e instanceof yA){if(e instanceof mA)n[t]=e.getLiteral();else if(e instanceof fA){const A=null==(s=c.get(e.dyno))?void 0:s.outNames.get(e.key);if(!A)throw new Error(`Source not found for ${e.dyno.constructor.name}.${e.key}`);n[t]=A}break}e=e.dynoOut()}}const a=c.get(A)??{outNames:new Map};for(const[A,n]of a.outNames.entries())e[A]=n;const i=A.compile({inputs:n,outputs:e,compile:t});l.push(i)}const B=[];for(const A in n)i[A]instanceof mA&&B.push(`${n[A]} = ${i[A].getLiteral()};`);B.length>0&&l.push(B);return{statements:l.flatMap(((A,n)=>0===n?A:["",...A]))}}}function FA(A,n,t,{update:e,globals:s}={}){return new vA({inTypes:A,outTypes:n,construct:t,update:e,globals:s})}function NA({inTypes:A,outTypes:n,inputs:t,update:e,globals:s,statements:a,generate:i}){return new MA({inTypes:A,outTypes:n,inputs:t,update:e,globals:s,statements:a,generate:i})}function RA(A,n,t){const e="string"==typeof n?n:n.type;if(!e)throw new Error(`Invalid DynoType: ${String(n)}`);return`${e} ${A}${null!=t?`[${t}]`:""}`}function GA(A){var n;let t=!1;const e=A.split("\n").map((A=>{const n=A.trimEnd();return t?n:n.length>0?(t=!0,n):null})).filter((A=>null!=A));for(;e.length>0&&0===e[e.length-1].length;)e.pop();if(0===e.length)return[];const s=null==(n=e[0].match(/^\s*/))?void 0:n[0];if(!s)return e;const a=new RegExp(`^${s}`);return e.map((A=>A.replace(a,"")))}function UA(A){return GA(A).join("\n")}class LA extends MA{constructor({a:A,outKey:n,outTypeFunc:t}){const e={a:dA(A)},s=t(dA(A));super({inTypes:e,outTypes:{[n]:s},inputs:{a:A}}),this.outKey=n}dynoOut(){return new fA(this,this.outKey)}}class TA extends MA{constructor({a:A,b:n,outKey:t,outTypeFunc:e}){const s={a:dA(A),b:dA(n)},a=e(dA(A),dA(n));super({inTypes:s,outTypes:{[t]:a},inputs:{a:A,b:n}}),this.outKey=t}dynoOut(){return new fA(this,this.outKey)}}class _A extends MA{constructor({a:A,b:n,c:t,outKey:e,outTypeFunc:s}){const a={a:dA(A),b:dA(n),c:dA(t)},i=s(dA(A),dA(n),dA(t));super({inTypes:a,outTypes:{[e]:i},inputs:{a:A,b:n,c:t}}),this.outKey=e}dynoOut(){return new fA(this,this.outKey)}}const YA={type:"Gsplat"},JA={type:"PackedSplats"},HA=(A,n)=>new WA({packedSplats:A,index:n}),qA=(A,n,t,e)=>new XA({packedSplats:A,index:n,base:t,count:e}),zA=A=>new An({gsplat:A}),KA=({gsplat:A,flags:n,index:t,center:e,scales:s,quaternion:a,rgba:i,rgb:r,opacity:o,x:g,y:c,z:I,r:l,g:B,b:Q})=>new nn({gsplat:A,flags:n,index:t,center:e,scales:s,quaternion:a,rgba:i,rgb:r,opacity:o,x:g,y:c,z:I,r:l,g:B,b:Q}),PA=A=>new en({gsplat:A}),OA=(A,{scale:n,rotate:t,translate:e,recolor:s})=>new sn({gsplat:A,scale:n,rotate:t,translate:e,recolor:s}),VA=UA("\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n"),jA=UA("\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n");class ZA extends LA{constructor({packedSplats:A}){super({a:A,outKey:"numSplats",outTypeFunc:()=>"int"}),this.statements=({inputs:A,outputs:n})=>[`${n.numSplats} = ${A.a}.numSplats;`]}}const $A=UA("\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n");class WA extends MA{constructor({packedSplats:A,index:n}){super({inTypes:{packedSplats:JA,index:"int"},outTypes:{gsplat:YA},inputs:{packedSplats:A,index:n},globals:()=>[VA,jA,$A],statements:({inputs:A,outputs:n})=>{const{gsplat:t}=n;if(!t)return[];const{packedSplats:e,index:s}=A;let a;return a=e&&s?GA(`\n            if (readPackedSplat(${e}.texture, ${e}.numSplats, ${s}, ${t})) {\n              bool zeroSize = all(equal(${t}.scales, vec3(0.0, 0.0, 0.0)));\n              ${t}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${t}.flags = 0u;\n            }\n          `):[`${t}.flags = 0u;`],a.push(`${t}.index = ${s??"0"};`),a}})}dynoOut(){return new fA(this,"gsplat")}}class XA extends MA{constructor({packedSplats:A,index:n,base:t,count:e}){super({inTypes:{packedSplats:JA,index:"int",base:"int",count:"int"},outTypes:{gsplat:YA},inputs:{packedSplats:A,index:n,base:t,count:e},globals:()=>[VA,jA,$A],statements:({inputs:A,outputs:n})=>{const{gsplat:t}=n;if(!t)return[];const{packedSplats:e,index:s,base:a,count:i}=A;let r;return r=e&&s&&a&&i?GA(`\n            ${t}.flags = 0u;\n            if ((${s} >= ${a}) && (${s} < (${a} + ${i}))) {\n              if (readPackedSplat(${e}.texture, ${e}.numSplats, ${s}, ${t})) {\n                bool zeroSize = all(equal(${t}.scales, vec3(0.0, 0.0, 0.0)));\n                ${t}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `):[`${t}.flags = 0u;`],r.push(`${t}.index = ${s??"0"};`),r}})}dynoOut(){return new fA(this,"gsplat")}}class An extends MA{constructor({gsplat:A}){super({inTypes:{gsplat:YA},outTypes:{flags:"uint",active:"bool",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},inputs:{gsplat:A},globals:()=>[VA],statements:({inputs:A,outputs:n})=>{const{gsplat:t}=A,{flags:e,active:s,index:a,center:i,scales:r,quaternion:o,rgba:g,rgb:c,opacity:I,x:l,y:B,z:Q,r:u,g:C,b:E}=n;return[e?`${e} = ${t?`${t}.flags`:"0u"};`:null,s?`${s} = isGsplatActive(${t?`${t}.flags`:"0u"});`:null,a?`${a} = ${t?`${t}.index`:"0"};`:null,i?`${i} = ${t?`${t}.center`:"vec3(0.0, 0.0, 0.0)"};`:null,r?`${r} = ${t?`${t}.scales`:"vec3(0.0, 0.0, 0.0)"};`:null,o?`${o} = ${t?`${t}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)"};`:null,g?`${g} = ${t?`${t}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)"};`:null,c?`${c} = ${t?`${t}.rgba.rgb`:"vec3(0.0, 0.0, 0.0)"};`:null,I?`${I} = ${t?`${t}.rgba.a`:"0.0"};`:null,l?`${l} = ${t?`${t}.center.x`:"0.0"};`:null,B?`${B} = ${t?`${t}.center.y`:"0.0"};`:null,Q?`${Q} = ${t?`${t}.center.z`:"0.0"};`:null,u?`${u} = ${t?`${t}.rgba.r`:"0.0"};`:null,C?`${C} = ${t?`${t}.rgba.g`:"0.0"};`:null,E?`${E} = ${t?`${t}.rgba.b`:"0.0"};`:null].filter(Boolean)}})}}class nn extends MA{constructor({gsplat:A,flags:n,index:t,center:e,scales:s,quaternion:a,rgba:i,rgb:r,opacity:o,x:g,y:c,z:I,r:l,g:B,b:Q}){super({inTypes:{gsplat:YA,flags:"uint",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},outTypes:{gsplat:YA},inputs:{gsplat:A,flags:n,index:t,center:e,scales:s,quaternion:a,rgba:i,rgb:r,opacity:o,x:g,y:c,z:I,r:l,g:B,b:Q},globals:()=>[VA],statements:({inputs:A,outputs:n})=>{const{gsplat:t}=n;if(!t)return[];const{gsplat:e,flags:s,index:a,center:i,scales:r,quaternion:o,rgba:g,rgb:c,opacity:I,x:l,y:B,z:Q,r:u,g:C,b:E}=A;return[`${t}.flags = ${s??(e?`${e}.flags`:"0u")};`,`${t}.index = ${a??(e?`${e}.index`:"0")};`,`${t}.center = ${i??(e?`${e}.center`:"vec3(0.0, 0.0, 0.0)")};`,`${t}.scales = ${r??(e?`${e}.scales`:"vec3(0.0, 0.0, 0.0)")};`,`${t}.quaternion = ${o??(e?`${e}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)")};`,`${t}.rgba = ${g??(e?`${e}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)")};`,c?`${t}.rgba.rgb = ${c};`:null,I?`${t}.rgba.a = ${I};`:null,l?`${t}.center.x = ${l};`:null,B?`${t}.center.y = ${B};`:null,Q?`${t}.center.z = ${Q};`:null,u?`${t}.rgba.r = ${u};`:null,C?`${t}.rgba.g = ${C};`:null,E?`${t}.rgba.b = ${E};`:null].filter(Boolean)}})}dynoOut(){return new fA(this,"gsplat")}}const tn=UA("\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n");class en extends LA{constructor({gsplat:A}){super({a:A,outKey:"normal",outTypeFunc:()=>"vec3"}),this.globals=()=>[VA,tn],this.statements=({inputs:A,outputs:n})=>[`${n.normal} = gsplatNormal(${A.a}.scales, ${A.a}.quaternion);`]}}class sn extends MA{constructor({gsplat:A,scale:n,rotate:t,translate:e,recolor:s}){super({inTypes:{gsplat:YA,scale:"float",rotate:"vec4",translate:"vec3",recolor:"vec4"},outTypes:{gsplat:YA},inputs:{gsplat:A,scale:n,rotate:t,translate:e,recolor:s},globals:()=>[VA],statements:({inputs:A,outputs:n,compile:t})=>{const{gsplat:e}=n;if(!e||!A.gsplat)return[];const{scale:s,rotate:a,translate:i,recolor:r}=A,o=t.indent;return[`${e} = ${A.gsplat};`,`if (isGsplatActive(${e}.flags)) {`,s?`${o}${e}.center *= ${s};`:null,a?`${o}${e}.center = quatVec(${a}, ${e}.center);`:null,i?`${o}${e}.center += ${i};`:null,s?`${o}${e}.scales *= ${s};`:null,a?`${o}${e}.quaternion = quatQuat(${a}, ${e}.quaternion);`:null,r?`${o}${e}.rgba *= ${r};`:null,"}"].filter(Boolean)}})}dynoOut(){return new fA(this,"gsplat")}}const an=A=>new rn({gsplat:A});class rn extends MA{constructor({gsplat:A}){super({inTypes:{gsplat:YA},inputs:{gsplat:A},globals:()=>[VA],statements:({inputs:A,outputs:n})=>{const{output:t}=n;if(!t)return[];const{gsplat:e}=A;return e?GA(`\n            if (isGsplatActive(${e}.flags)) {\n              ${t} = packSplat(${e}.center, ${e}.scales, ${e}.quaternion, ${e}.rgba);\n            } else {\n              ${t} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `):[`${t} = uvec4(0u, 0u, 0u, 0u);`]}})}dynoOut(){return new fA(this,"output")}}class on extends MA{constructor({rgba8:A}){super({inTypes:{rgba8:"vec4"},inputs:{rgba8:A},statements:({inputs:A,outputs:n})=>[`target = ${A.rgba8??"vec4(0.0, 0.0, 0.0, 0.0)"};`]})}dynoOut(){return new fA(this,"rgba8")}}const gn=(A=0,n)=>new un({key:n,value:A}),cn=(A,n)=>new mn({key:n,value:A});class In extends MA{constructor({key:A,type:n,count:t,value:e,update:s,globals:a}){A=A??"value",super({outTypes:{[A]:n},update:()=>{if(s){const A=s(this.value);void 0!==A&&(this.value=A)}this.uniform.value=this.value},generate:({inputs:e,outputs:s})=>{const i=(null==a?void 0:a({inputs:e,outputs:s}))??[],r={},o=s[A];return o&&(i.push(`uniform ${RA(o,n,t)};`),r[o]=this.uniform),{globals:i,uniforms:r}}}),this.type=n,this.count=t,this.value=e,this.uniform={value:e},this.outKey=A}dynoOut(){return new fA(this,this.outKey)}}class ln extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"bool",value:n,update:t})}}class Bn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"uint",value:n,update:t})}}class Qn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"int",value:n,update:t})}}class un extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"float",value:n,update:t})}}class Cn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"bvec2",value:n,update:t})}}class En extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"uvec2",value:n,update:t})}}class hn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"ivec2",value:n,update:t})}}class pn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"vec2",value:n,update:t})}}class dn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"bvec3",value:n,update:t})}}class yn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"uvec3",value:n,update:t})}}class fn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"ivec3",value:n,update:t})}}class mn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"vec3",value:n,update:t})}}class wn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"bvec4",value:n,update:t})}}class Dn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"uvec4",value:n,update:t})}}class xn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"ivec4",value:n,update:t})}}class Sn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"vec4",value:n,update:t})}}class bn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat2",value:n,update:t})}}class kn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat2x2",value:n,update:t})}}class Mn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat2x3",value:n,update:t})}}class vn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat2x4",value:n,update:t})}}class Fn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat3",value:n,update:t})}}class Nn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat3x2",value:n,update:t})}}class Rn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat3x3",value:n,update:t})}}class Gn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat3x4",value:n,update:t})}}class Un extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat4",value:n,update:t})}}class Ln extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat4x2",value:n,update:t})}}class Tn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat4x3",value:n,update:t})}}class _n extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"mat4x4",value:n,update:t})}}class Yn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"usampler2D",value:n,update:t})}}class Jn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"isampler2D",value:n,update:t})}}class Hn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"sampler2D",value:n,update:t})}}class qn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"usampler2DArray",value:n,update:t})}}class zn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"isampler2DArray",value:n,update:t})}}class Kn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"sampler2DArray",value:n,update:t})}}class Pn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"usampler3D",value:n,update:t})}}class On extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"isampler3D",value:n,update:t})}}class Vn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"sampler3D",value:n,update:t})}}class jn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"usamplerCube",value:n,update:t})}}class Zn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"isamplerCube",value:n,update:t})}}class $n extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"samplerCube",value:n,update:t})}}class Wn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"sampler2DShadow",value:n,update:t})}}class Xn extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"sampler2DArrayShadow",value:n,update:t})}}class At extends In{constructor({key:A,value:n,update:t}){super({key:A,type:"samplerCubeShadow",value:n,update:t})}}const nt=new Float32Array(1),tt=new Uint32Array(nt.buffer);function et(A){nt[0]=A;const n=tt[0],t=n>>23&255,e=8388607&n,s=(n>>31&1)<<15;if(255===t)return 0!==e?32767|s:31744|s;const a=t-127+15;if(a>=31)return 31744|s;if(a<=0){if(a<-10)return s;return s|(8388608|e)>>1-a+13}return s|a<<10|e>>13}function st(A){const n=A>>15&1,t=A>>10&31,e=1023&A;let s;if(0===t)if(0===e)s=n<<31;else{let A=e,t=-14;for(;!(1024&A);)A<<=1,t--;A&=1023;s=n<<31|t+127<<23|A<<13}else if(31===t)s=0===e?n<<31|2139095040:n<<31|2143289344;else{s=n<<31|t-15+127<<23|e<<13}return tt[0]=s,nt[0]}function at(A){return Math.max(0,Math.min(255,Math.round(255*A)))}function it(A){return Math.max(-127,Math.min(127,Math.round(127*A)))}function rt(A){return A/255}function ot(A){return A/127}function gt(A){const n=[],t=new Set;return function A(e){e&&"object"==typeof e&&!t.has(e)&&(t.add(e),e instanceof ArrayBuffer?n.push(e):ArrayBuffer.isView(e)?n.push(e.buffer):Array.isArray(e)?e.forEach(A):Object.values(e).forEach(A))}(A),n}class ct{constructor({allocate:A,dispose:n,valid:t}){this.items=[],this.allocate=A,this.dispose=n,this.valid=t}alloc(A){for(;;){const n=this.items.pop();if(!n)break;if(this.valid(n,A))return n;this.dispose&&this.dispose(n)}return this.allocate(A)}free(A){this.items.push(A)}disposeAll(){let A;for(A=this.items.pop();A;)this.dispose&&this.dispose(A),A=this.items.pop()}}function It(A,n,t,s,a,i,r,o,g,c,I,l,B,Q,u,C){const E=at(Q),h=at(u),p=at(C),d=at(B),y=St(new e.Quaternion(g,c,I,l)),f=255&y,m=y>>>8&255,w=y>>>16&255,D=i<Z?0:Math.min(255,Math.max(1,Math.round((Math.log(i)-V)/j)+1)),x=r<Z?0:Math.min(255,Math.max(1,Math.round((Math.log(r)-V)/j)+1)),S=o<Z?0:Math.min(255,Math.max(1,Math.round((Math.log(o)-V)/j)+1)),b=et(t),k=et(s),M=et(a),v=4*n;A[v]=E|h<<8|p<<16|d<<24,A[v+1]=b|k<<16,A[v+2]=M|f<<16|m<<24,A[v+3]=D|x<<8|S<<16|w<<24}const lt={center:new e.Vector3,scales:new e.Vector3,quaternion:new e.Quaternion,color:new e.Color,opacity:0};function Bt(A,n){const t=lt,e=4*n,s=A[e],a=A[e+1],i=A[e+2],r=A[e+3];t.color.set((255&s)/255,(s>>>8&255)/255,(s>>>16&255)/255),t.opacity=(s>>>24&255)/255,t.center.set(st(65535&a),st(a>>>16&65535),st(65535&i));const o=255&r;t.scales.x=0===o?0:Math.exp(V+(o-1)*j);const g=r>>>8&255;t.scales.y=0===g?0:Math.exp(V+(g-1)*j);const c=r>>>16&255;t.scales.z=0===c?0:Math.exp(V+(c-1)*j);return bt(i>>>16&65535|r>>>8&16711680,t.quaternion),t}function Qt(A){const n=$,t=Math.max(X,Math.min(W,Math.ceil(A/n))),e=Math.ceil(A/(n*t));return{width:n,height:t,depth:e,maxSplats:n*t*e}}function ut(){return navigator.maxTouchPoints>0||/Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(navigator.userAgent)}function Ct(){return/Android/.test(navigator.userAgent)}function Et(){return/Oculus/.test(navigator.userAgent)}function ht(A,n,t){const e=new Uint8Array(4*n);for(let s=0;s<t/2;s++){const a=s*n*4,i=(t-1-s)*n*4;e.set(A.subarray(a,a+4*n)),A.set(A.subarray(i,i+4*n),a),A.set(e,i)}return A}function pt(A,n,t){const e=document.createElement("canvas");e.width=n,e.height=t;const s=e.getContext("2d");if(!s)throw new Error("Can't get 2d context");const a=s.createImageData(n,t);return a.data.set(A),s.putImageData(a,0,0),e.toDataURL("image/png")}function dt(A){const n=new e.Clock(A.autoStart);return n.startTime=A.startTime,n.oldTime=A.oldTime,n.elapsedTime=A.elapsedTime,n.running=A.running,n}const yt=UA("\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n");function ft(A){const n=new e.Vector3;for(const t of A)n.add(t);return n.divideScalar(A.length)}function mt(A){if(0===A.length)return new e.Quaternion;const n=A[0].clone();for(let t=1;t<A.length;t++)A[t].dot(A[0])<0?(n.x-=A[t].x,n.y-=A[t].y,n.z-=A[t].z,n.w-=A[t].w):(n.x+=A[t].x,n.y+=A[t].y,n.z+=A[t].z,n.w+=A[t].w);return n.normalize()}function wt(A,n){const t=new e.Vector3(0,0,0).applyMatrix4(A),s=new e.Vector3(0,0,0).applyMatrix4(n),a=new e.Vector3(0,0,-1).applyMatrix4(A).sub(t).normalize(),i=new e.Vector3(0,0,-1).applyMatrix4(n).sub(s).normalize();return{distance:t.distanceTo(s),coincidence:a.dot(i)}}function Dt(A,n){const[t,s]=[new e.Vector3,new e.Quaternion],[a,i]=[new e.Vector3,new e.Quaternion];A.decompose(t,s,new e.Vector3),n.decompose(a,i,new e.Vector3);return{distance:t.distanceTo(a),coorient:Math.abs(s.dot(i))}}function xt({matrix1:A,matrix2:n,maxDistance:t,minCoorient:e}){const{distance:s,coorient:a}=Dt(A,n);return s<=t&&(null==e||a>=e)}function St(A){const n=A.clone().normalize();n.w<0&&n.set(-n.x,-n.y,-n.z,-n.w);const t=2*Math.acos(n.w),s=Math.sqrt(n.x*n.x+n.y*n.y+n.z*n.z),a=s<1e-6?new e.Vector3(1,0,0):new e.Vector3(n.x,n.y,n.z).divideScalar(s),i=Math.abs(a.x)+Math.abs(a.y)+Math.abs(a.z);let r=a.x/i,o=a.y/i;if(a.z<0){const A=r;r=(1-Math.abs(o))*(r>=0?1:-1),o=(1-Math.abs(A))*(o>=0?1:-1)}const g=.5*r+.5,c=.5*o+.5,I=Math.round(255*g),l=Math.round(255*c);return Math.round(t*(255/Math.PI))<<16|l<<8|I}function bt(A,n){const t=A>>>16&255;let s=2*((255&A)/255-.5),a=2*((A>>>8&255)/255-.5);const i=1-(Math.abs(s)+Math.abs(a)),r=Math.max(-i,0);s+=s>=0?-r:r,a+=a>=0?-r:r;const o=new e.Vector3(s,a,i).normalize(),g=.5*(t/255*Math.PI),c=Math.sin(g),I=Math.cos(g);return n.set(o.x*c,o.y*c,o.z*c,I),n}function kt(A,n,t,e){return 255&Math.max(-127,Math.min(127,127*A))|(255&Math.max(-127,Math.min(127,127*n)))<<8|(255&Math.max(-127,Math.min(127,127*t)))<<16|(255&Math.max(-127,Math.min(127,127*e)))<<24}function Mt(A,n){const t=[];let e=0,s=null;const a=new L(((A,a)=>{if(t.push(A),e+=A.length,a||e>=n){const A=new Uint8Array(e);let a=0;for(const n of t)A.set(n,a),a+=n.length;s=A.slice(0,n)}}));let i=0;for(;null==s&&i<A.length;){const n=A.slice(i,i+1024);a.push(n,!1),i+=1024}if(null==s&&(a.push(new Uint8Array,!0),null==s))throw new Error("Failed to decompress partial gzip");return s}class vt{constructor({fileBytes:A,chunkBytes:n=65536}){this.fileBytes=A,this.chunkBytes=n,this.offset=0,this.chunks=[],this.totalBytes=0,this.gunzip=new L(((A,n)=>{this.chunks.push(A),this.totalBytes+=A.length}))}read(A){for(;this.totalBytes<A&&this.offset<this.fileBytes.length;){const A=Math.min(this.offset+this.chunkBytes,this.fileBytes.length);this.gunzip.push(this.fileBytes.subarray(this.offset,A),!1),this.offset=A}if(this.totalBytes<A&&this.offset>=this.fileBytes.length&&this.gunzip.push(new Uint8Array(0),!0),this.totalBytes<A)throw new Error(`Unexpected EOF: needed ${A}, got ${this.totalBytes}`);const n=new Uint8Array(this.totalBytes);let t=0;for(const A of this.chunks)n.set(A,t),t+=A.length;const e=n.subarray(0,A);return this.chunks=[n.subarray(A)],this.totalBytes-=A,e}}const Ft=Object.freeze(Object.defineProperty({__proto__:null,DataCache:class{constructor({asyncFetch:A,maxItems:n=5}){this.asyncFetch=A,this.maxItems=n,this.items=[]}async getFetch(A){const n=this.items.findIndex((n=>n.key===A));if(n>=0){const A=this.items.splice(n,1)[0];return this.items.push(A),A.data}const t=await this.asyncFetch(A);for(this.items.push({key:A,data:t});this.items.length>this.maxItems;)this.items.shift();return t}},FreeList:ct,GunzipReader:vt,IDENT_VERTEX_SHADER:yt,Sint8ToFloat:ot,Uint8ToFloat:rt,averagePositions:ft,averageQuaternions:mt,cloneClock:dt,coinciDist:wt,computeMaxSplats:function(A){const n=$,t=Math.max(X,Math.min(W,Math.ceil(A/n)));return n*t*Math.ceil(A/(n*t))},coorientDist:Dt,decodeQuatEulerXyz888:function(A,n){const t=(A>>>8&255)/255,e=(A>>>16&255)/255,s=(255&A)/255*(2*Math.PI)-Math.PI,a=t*(2*Math.PI)-Math.PI,i=e*(2*Math.PI)-Math.PI,r=Math.cos(.5*s),o=Math.sin(.5*s),g=Math.cos(.5*a),c=Math.sin(.5*a),I=Math.cos(.5*i),l=Math.sin(.5*i);return n.w=r*g*I+o*c*l,n.x=o*g*I-r*c*l,n.y=r*c*I+o*g*l,n.z=r*g*l-o*c*I,n.normalize(),n},decodeQuatOctXy88R8:bt,decodeQuatXyz888:function(A,n){const t=A<<24>>24,e=A<<16>>24,s=A<<8>>24;n.set(t/127,e/127,s/127,0);const a=n.x*n.x+n.y*n.y+n.z*n.z;return n.w=Math.sqrt(Math.max(0,1-a)),n},decompressPartialGzip:Mt,encodeQuatEulerXyz888:function(A){const n=A.clone().normalize(),t=2*(n.w*n.x+n.y*n.z),e=1-2*(n.x*n.x+n.y*n.y),s=Math.atan2(t,e),a=2*(n.w*n.y-n.z*n.x),i=Math.abs(a)>=1?Math.sign(a)*(Math.PI/2):Math.asin(a),r=2*(n.w*n.z+n.x*n.y),o=1-2*(n.y*n.y+n.z*n.z),g=Math.atan2(r,o),c=(s+Math.PI)/(2*Math.PI),I=(i+Math.PI)/(2*Math.PI),l=(g+Math.PI)/(2*Math.PI),B=Math.round(255*c),Q=Math.round(255*I);return Math.round(255*l)<<16|Q<<8|B},encodeQuatOctXy88R8:St,encodeQuatXyz888:function(A){const n=A.w<0;return 255&it(n?-A.x:A.x)|(255&it(n?-A.y:A.y))<<8|(255&it(n?-A.z:A.z))<<16},encodeSh1Rgb:function(A,n,t){const e=2*n;for(let n=0;n<9;++n){const s=127&Math.max(-63,Math.min(63,63*t[n])),a=7*n,i=a+7,r=Math.floor(a/32),o=a-32*r,g=s<<o&4294967295;if(A[e+r]|=g,i>32*r+32){const n=s>>>32-o&4294967295;A[e+r+1]|=n}}},encodeSh2Rgb:function(A,n,t){A[4*n+0]=kt(t[0],t[1],t[2],t[3]),A[4*n+1]=kt(t[4],t[5],t[6],t[7]),A[4*n+2]=kt(t[8],t[9],t[10],t[11]),A[4*n+3]=kt(t[12],t[13],t[14],0)},encodeSh3Rgb:function(A,n,t){const e=4*n;for(let n=0;n<21;++n){const s=63&Math.max(-31,Math.min(31,31*t[n])),a=6*n,i=a+6,r=Math.floor(a/32),o=a-32*r,g=s<<o&4294967295;if(A[e+r]|=g,i>32*r+32){const n=s>>>32-o&4294967295;A[e+r+1]|=n}}},epsilonSign:function(A,n=.001){return Math.abs(A)<n?0:Math.sign(A)},flipPixels:ht,floatBitsToUint:function(A){return nt[0]=A,tt[0]},floatToSint8:it,floatToUint8:at,fromHalf:st,getArrayBuffers:gt,getTextureSize:Qt,isAndroid:Ct,isMobile:ut,isOculus:Et,mapFilterObject:function(A,n){const t=Object.entries(A).map((([A,t])=>[A,n(t,A)])).filter((([A,n])=>void 0!==n));return Object.fromEntries(t)},mapObject:function(A,n){const t=Object.entries(A).map((([A,t])=>[A,n(t,A)]));return Object.fromEntries(t)},newArray:function(A,n){return new Array(A).fill(null).map(((A,t)=>n(t)))},omitUndefined:function(A){return Object.fromEntries(Object.entries(A).filter((([A,n])=>void 0!==n)))},pixelsToPngUrl:pt,setPackedSplat:It,setPackedSplatCenter:function(A,n,t,e,s){const a=et(t),i=et(e),r=et(s),o=4*n;A[o+1]=a|i<<16,A[o+2]=r|4294901760&A[o+2]},setPackedSplatOpacity:function(A,n,t){const e=at(t),s=4*n;A[s]=16777215&A[s]|e<<24},setPackedSplatQuat:function(A,n,t,s,a,i){const r=St(new e.Quaternion(t,s,a,i)),o=255&r,g=r>>>8&255,c=r>>>16&255,I=4*n;A[I+2]=65535&A[I+2]|o<<16|g<<24,A[I+3]=16777215&A[I+3]|c<<24},setPackedSplatRgb:function(A,n,t,e,s){const a=at(t),i=at(e),r=at(s),o=4*n;A[o]=a|i<<8|r<<16|4278190080&A[o]},setPackedSplatRgba:function(A,n,t,e,s,a){const i=at(t),r=at(e),o=at(s),g=at(a);A[4*n]=i|r<<8|o<<16|g<<24},setPackedSplatScales:function(A,n,t,e,s){const a=t<Z?0:Math.min(255,Math.max(1,Math.round((Math.log(t)-V)/j)+1)),i=e<Z?0:Math.min(255,Math.max(1,Math.round((Math.log(e)-V)/j)+1)),r=s<Z?0:Math.min(255,Math.max(1,Math.round((Math.log(s)-V)/j)+1)),o=4*n;A[o+3]=a|i<<8|r<<16|4278190080&A[o+3]},toHalf:et,uintBitsToFloat:function(A){return tt[0]=A,nt[0]},unpackSplat:Bt,withinCoinciDist:function({matrix1:A,matrix2:n,maxDistance:t,minCoincidence:e}){const{distance:s,coincidence:a}=wt(A,n);return s<=t&&(null==e||a>=e)},withinCoorientDist:xt,withinDist:function({matrix1:A,matrix2:n,maxDistance:t}){const s=new e.Vector3(0,0,0).applyMatrix4(A),a=new e.Vector3(0,0,0).applyMatrix4(n);return s.distanceTo(a)<=t}},Symbol.toStringTag,{value:"Module"}));class Nt{constructor({graph:A,inputs:n,outputs:t,template:e}){this.graph=A,this.template=e,this.inputs=n??{},this.outputs=t??{};const s=new kA({indent:this.template.indent});for(const A in this.outputs)this.outputs[A]&&s.declares.add(this.outputs[A]);const a=A.compile({inputs:this.inputs,outputs:this.outputs,compile:s});this.shader=e.generate({globals:s.globals,statements:a}),this.uniforms=s.uniforms,this.updaters=s.updaters}prepareMaterial(){return function(A){let n=Gt.get(A);if(n)return n;return n=new e.RawShaderMaterial({glslVersion:e.GLSL3,vertexShader:yt,fragmentShader:A.shader,uniforms:A.uniforms}),Gt.set(A,n),n}(this)}update(){for(const A of this.updaters)A()}}class Rt{constructor(A){const n=A.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m),t=A.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);if(!n||!t)throw new Error("Template must contain {{ GLOBALS }} and {{ STATEMENTS }}");this.before=A.substring(0,n.index),this.between=A.substring(n.index+n[0].length,t.index),this.after=A.substring(t.index+t[0].length),this.indent=t[1]}generate({globals:A,statements:n}){return this.before+Array.from(A).join("\n\n")+this.between+n.map((A=>this.indent+A)).join("\n")+this.after}}const Gt=new Map;function Ut(A,n,t="add"){const e=()=>{throw new Error(`Invalid ${t} types: ${A}, ${n}`)};if(A===n)return A;if("int"===A){if(tA(n))return n;e()}if("int"===n){if(tA(A))return A;e()}if("uint"===A){if(eA(n))return n;e()}if("uint"===n){if(eA(A))return A;e()}if("float"===A){if(iA(n))return n;e()}if("float"===n){if(iA(A))return A;e()}throw new Error(`Invalid ${t} types: ${A}, ${n}`)}function Lt(A,n){return Ut(A,n,"sub")}function Tt(A,n){const t=()=>{throw new Error(`Invalid mul types: ${A}, ${n}`)};if("int"===A){if(tA(n))return n;t()}if("int"===n){if(tA(A))return A;t()}if("uint"===A){if(eA(n))return n;t()}if("uint"===n){if(eA(A))return A;t()}if("float"===A){if(iA(n))return n;t()}if("float"===n){if(iA(A))return A;t()}if(tA(A)||eA(A)||tA(n)||eA(n)){if(A===n)return A;t()}if("vec2"===A){if("vec2"===n||cA(n))return"vec2";if("mat3x2"===n)return"vec3";if("mat4x2"===n)return"vec4";t()}if("vec3"===A){if("mat2x3"===n)return"vec2";if("vec3"===n||IA(n))return"vec3";if("mat4x3"===n)return"vec4";t()}if("vec4"===A){if("mat2x4"===n)return"vec2";if("mat3x4"===n)return"vec3";if("vec4"===n||lA(n))return"vec4";t()}if("vec2"===n){if(cA(A))return"vec2";if("mat2x3"===A)return"vec3";if("mat2x4"===A)return"vec4";t()}if("vec3"===n){if("mat3x2"===A)return"vec2";if(IA(A))return"vec3";if("mat3x4"===A)return"vec4";t()}if("vec4"===n){if("mat4x2"===A)return"vec2";if("mat4x3"===A)return"vec3";if(lA(A))return"vec4";t()}if(cA(A)){if(cA(n))return"mat2";if("mat3x2"===n)return"mat3x2";if("mat4x2"===n)return"mat4x2";t()}if("mat2x3"===A){if(cA(n))return"mat2x3";if("mat3x2"===n)return"mat3";if("mat4x2"===n)return"mat4x3";t()}if("mat2x4"===A){if(cA(n))return"mat2x4";if("mat3x2"===n)return"mat3x4";if("mat4x2"===n)return"mat4";t()}if("mat3x2"===A){if("mat2x3"===n)return"mat2";if(IA(n))return"mat3x2";if("mat4x3"===n)return"mat4x2";t()}if(IA(A)){if("mat2x3"===n)return"mat2x3";if(IA(n))return"mat3";if("mat4x3"===n)return"mat4x3";t()}if("mat3x4"===A){if("mat2x3"===n)return"mat2x4";if(IA(n))return"mat3x4";if("mat4x3"===n)return"mat4";t()}if("mat4x2"===A){if("mat2x4"===n)return"mat2";if("mat3x4"===n)return"mat3x2";if(lA(n))return"mat4x2";t()}if("mat4x3"===A){if("mat2x4"===n)return"mat2x3";if("mat3x4"===n)return"mat3";if(lA(n))return"mat4x3";t()}if(lA(A)){if("mat2x4"===n)return"mat2x4";if("mat3x4"===n)return"mat3x4";if(lA(n))return"mat4";t()}throw new Error(`Invalid mul types: ${A}, ${n}`)}function _t(A,n){return Ut(A,n,"div")}function Yt(A,n){if(A===n)return A;if("int"===A){if(tA(n))return n}else if("int"===n){if(tA(A))return A}else if("uint"===A){if(eA(n))return n}else if("uint"===n&&eA(A))return A;throw new Error(`Invalid imod types: ${A}, ${n}`)}function Jt(A,n){if(A===n||"float"===n)return A;throw new Error(`Invalid mod types: ${A}, ${n}`)}function Ht(A){return A}function qt(A){return A}function zt(A){return A}function Kt(A){return A}function Pt(A){return A}function Ot(A){return A}function Vt(A){return A}function jt(A){return A}function Zt(A){return A}function $t(A){return A}function Wt(A){return A}function Xt(A){return A}function Ae(A){return A}function ne(A){return A}function te(A){return A}function ee(A){return A}function se(A,n,t="min"){if(A===n)return A;if("float"===n){if(sA(A))return A}else if("int"===n){if(tA(A))return A}else if("uint"===n&&eA(A))return A;throw new Error(`Invalid ${t} types: ${A}, ${n}`)}function ae(A,n){return se(A,n,"max")}function ie(A,n,t){if("float"===n){if(sA(A))return A}else if("int"===n){if(tA(A))return A}else if("uint"===n&&eA(A))return A;throw new Error(`Invalid clamp types: ${A}, ${n}`)}function re(A,n,t){if(t===A)return A;if("float"===t)return A;if("bool"===t&&"float"===A)return A;if("bvec2"===t&&"vec2"===A)return A;if("bvec3"===t&&"vec3"===A)return A;if("bvec4"===t&&"vec4"===A)return A;throw new Error(`Invalid mix types: ${A}, ${n}, ${t}`)}function oe(A,n){if(A===n||"float"===n)return n;throw new Error(`Invalid step types: ${A}, ${n}`)}function ge(A,n,t){if(A===n&&(A===t||"float"===A))return t;throw new Error(`Invalid smoothstep types: ${A}, ${n}, ${t}`)}function ce(A,n="isNan"){if("float"===A)return"bool";if("vec2"===A)return"bvec2";if("vec3"===A)return"bvec3";if("vec4"===A)return"bvec4";throw new Error(`Invalid ${n} types: ${A}`)}function Ie(A){return ce(A,"isInf")}const le=(A,n)=>new fe({a:A,b:n}),Be=(A,n)=>new me({a:A,b:n}),Qe=(A,n)=>new we({a:A,b:n}),ue=(A,n)=>new De({a:A,b:n}),Ce=(A,n)=>new xe({a:A,b:n}),Ee=(A,n)=>new Se({a:A,b:n}),he=A=>new ke({a:A}),pe=A=>new Ue({a:A}),de=(A,n)=>new Pe({a:A,b:n}),ye=(A,n,t)=>new Ve({a:A,b:n,t});class fe extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"sum",outTypeFunc:Ut}),this.statements=({inputs:A,outputs:n})=>[`${n.sum} = ${A.a} + ${A.b};`]}}class me extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"difference",outTypeFunc:Lt}),this.statements=({inputs:A,outputs:n})=>[`${n.difference} = ${A.a} - ${A.b};`]}}class we extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"product",outTypeFunc:Tt}),this.statements=({inputs:A,outputs:n})=>[`${n.product} = ${A.a} * ${A.b};`]}}class De extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"quotient",outTypeFunc:_t}),this.statements=({inputs:A,outputs:n})=>[`${n.quotient} = ${A.a} / ${A.b};`]}}class xe extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"remainder",outTypeFunc:Yt}),this.statements=({inputs:A,outputs:n})=>[`${n.remainder} = ${A.a} % ${A.b};`]}}class Se extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"remainder",outTypeFunc:Jt}),this.statements=({inputs:A,outputs:n})=>[`${n.remainder} = mod(${A.a}, ${A.b});`]}}class be extends MA{constructor({a:A}){const n={a:dA(A)},t=n.a;super({inTypes:n,outTypes:{fract:t,integer:t},inputs:{a:A}}),this.statements=({inputs:A,outputs:n})=>[`${n.fract} = modf(${A.a}, ${n.integer});`]}}class ke extends LA{constructor({a:A}){super({a:A,outKey:"neg",outTypeFunc:Ht}),this.statements=({inputs:A,outputs:n})=>[`${n.neg} = -${A.a};`]}}class Me extends LA{constructor({a:A}){super({a:A,outKey:"abs",outTypeFunc:qt}),this.statements=({inputs:A,outputs:n})=>[`${n.abs} = abs(${A.a});`]}}class ve extends LA{constructor({a:A}){super({a:A,outKey:"sign",outTypeFunc:zt}),this.statements=({inputs:A,outputs:n})=>[`${n.sign} = sign(${A.a});`]}}class Fe extends LA{constructor({a:A}){super({a:A,outKey:"floor",outTypeFunc:Kt}),this.statements=({inputs:A,outputs:n})=>[`${n.floor} = floor(${A.a});`]}}class Ne extends LA{constructor({a:A}){super({a:A,outKey:"ceil",outTypeFunc:Pt}),this.statements=({inputs:A,outputs:n})=>[`${n.ceil} = ceil(${A.a});`]}}class Re extends LA{constructor({a:A}){super({a:A,outKey:"trunc",outTypeFunc:Ot}),this.statements=({inputs:A,outputs:n})=>[`${n.trunc} = trunc(${A.a});`]}}class Ge extends LA{constructor({a:A}){super({a:A,outKey:"round",outTypeFunc:Vt}),this.statements=({inputs:A,outputs:n})=>[`${n.round} = round(${A.a});`]}}class Ue extends LA{constructor({a:A}){super({a:A,outKey:"fract",outTypeFunc:jt}),this.statements=({inputs:A,outputs:n})=>[`${n.fract} = fract(${A.a});`]}}class Le extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"power",outTypeFunc:Zt}),this.statements=({inputs:A,outputs:n})=>[`${n.power} = pow(${A.a}, ${A.b});`]}}class Te extends LA{constructor({a:A}){super({a:A,outKey:"exp",outTypeFunc:$t}),this.statements=({inputs:A,outputs:n})=>[`${n.exp} = exp(${A.a});`]}}class _e extends LA{constructor({a:A}){super({a:A,outKey:"exp2",outTypeFunc:Wt}),this.statements=({inputs:A,outputs:n})=>[`${n.exp2} = exp2(${A.a});`]}}class Ye extends LA{constructor({a:A}){super({a:A,outKey:"log",outTypeFunc:Xt}),this.statements=({inputs:A,outputs:n})=>[`${n.log} = log(${A.a});`]}}class Je extends LA{constructor({a:A}){super({a:A,outKey:"log2",outTypeFunc:Ae}),this.statements=({inputs:A,outputs:n})=>[`${n.log2} = log2(${A.a});`]}}class He extends LA{constructor({a:A}){super({a:A,outKey:"sqr",outTypeFunc:ne}),this.statements=({inputs:A,outputs:n})=>[`${n.sqr} = ${A.a} * ${A.a};`]}}class qe extends LA{constructor({a:A}){super({a:A,outKey:"sqrt",outTypeFunc:te}),this.statements=({inputs:A,outputs:n})=>[`${n.sqrt} = sqrt(${A.a});`]}}class ze extends LA{constructor({a:A}){super({a:A,outKey:"inversesqrt",outTypeFunc:ee}),this.statements=({inputs:A,outputs:n})=>[`${n.inversesqrt} = inversesqrt(${A.a});`]}}class Ke extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"min",outTypeFunc:se}),this.statements=({inputs:A,outputs:n})=>[`${n.min} = min(${A.a}, ${A.b});`]}}class Pe extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"max",outTypeFunc:ae}),this.statements=({inputs:A,outputs:n})=>[`${n.max} = max(${A.a}, ${A.b});`]}}class Oe extends _A{constructor({a:A,min:n,max:t}){super({a:A,b:n,c:t,outKey:"clamp",outTypeFunc:ie}),this.statements=({inputs:A,outputs:n})=>{const{a:t,b:e,c:s}=A;return[`${n.clamp} = clamp(${t}, ${e}, ${s});`]}}}class Ve extends _A{constructor({a:A,b:n,t}){super({a:A,b:n,c:t,outKey:"mix",outTypeFunc:re}),this.statements=({inputs:A,outputs:n})=>{const{a:t,b:e,c:s}=A;return[`${n.mix} = mix(${t}, ${e}, ${s});`]}}}class je extends TA{constructor({edge:A,x:n}){super({a:A,b:n,outKey:"step",outTypeFunc:oe}),this.statements=({inputs:A,outputs:n})=>{const{a:t,b:e}=A;return[`${n.step} = step(${t}, ${e});`]}}}class Ze extends _A{constructor({edge0:A,edge1:n,x:t}){super({a:A,b:n,c:t,outKey:"smoothstep",outTypeFunc:ge}),this.statements=({inputs:A,outputs:n})=>{const{a:t,b:e,c:s}=A;return[`${n.smoothstep} = smoothstep(${t}, ${e}, ${s});`]}}}class $e extends LA{constructor({a:A}){super({a:A,outKey:"isNan",outTypeFunc:ce}),this.statements=({inputs:A,outputs:n})=>[`${n.isNan} = isNan(${A.a});`]}}class We extends LA{constructor({a:A}){super({a:A,outKey:"isInf",outTypeFunc:Ie}),this.statements=({inputs:A,outputs:n})=>[`${n.isInf} = isInf(${A.a});`]}}const Xe=(A,n)=>new os({a:A,b:n}),As=(A,n,t)=>new Bs({cond:A,t:n,f:t});class ns extends TA{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>A,outKey:"and"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.and?[`${n.and} = ${A.a} && ${A.b};`]:[`${n.and} = ${A.a} & ${A.b};`]}}class ts extends TA{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>A,outKey:"or"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.or?[`${n.or} = ${A.a} || ${A.b};`]:[`${n.or} = ${A.a} | ${A.b};`]}}class es extends TA{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>A,outKey:"xor"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.xor?[`${n.xor} = ${A.a} ^^ ${A.b};`]:[`${n.xor} = ${A.a} ^ ${A.b};`]}}class ss extends LA{constructor({a:A}){super({a:A,outTypeFunc:A=>A,outKey:"not"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.not?[`${n.not} = !${A.a};`]:[`${n.not} = not(${A.a});`]}}class as extends TA{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>Qs(A,"lessThan"),outKey:"lessThan"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.lessThan?[`${n.lessThan} = ${A.a} < ${A.b};`]:[`${n.lessThan} = lessThan(${A.a}, ${A.b});`]}}class is extends TA{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>Qs(A,"lessThanEqual"),outKey:"lessThanEqual"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.lessThanEqual?[`${n.lessThanEqual} = ${A.a} <= ${A.b};`]:[`${n.lessThanEqual} = lessThanEqual(${A.a}, ${A.b});`]}}class rs extends TA{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>Qs(A,"greaterThan"),outKey:"greaterThan"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.greaterThan?[`${n.greaterThan} = ${A.a} > ${A.b};`]:[`${n.greaterThan} = greaterThan(${A.a}, ${A.b});`]}}class os extends TA{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>Qs(A,"greaterThanEqual"),outKey:"greaterThanEqual"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.greaterThanEqual?[`${n.greaterThanEqual} = ${A.a} >= ${A.b};`]:[`${n.greaterThanEqual} = greaterThanEqual(${A.a}, ${A.b});`]}}class gs extends TA{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:us,outKey:"equal"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.equal?[`${n.equal} = ${A.a} == ${A.b};`]:[`${n.equal} = equal(${A.a}, ${A.b});`]}}class cs extends TA{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:Cs,outKey:"notEqual"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.notEqual?[`${n.notEqual} = ${A.a} != ${A.b};`]:[`${n.notEqual} = notEqual(${A.a}, ${A.b});`]}}class Is extends LA{constructor({a:A}){super({a:A,outTypeFunc:A=>"bool",outKey:"any"}),this.statements=({inputs:A,outputs:n})=>[`${n.any} = any(${A.a});`]}}class ls extends LA{constructor({a:A}){super({a:A,outTypeFunc:A=>"bool",outKey:"all"}),this.statements=({inputs:A,outputs:n})=>[`${n.all} = all(${A.a});`]}}class Bs extends _A{constructor({cond:A,t:n,f:t}){super({a:A,b:n,c:t,outKey:"select",outTypeFunc:(A,n,t)=>n}),this.statements=({inputs:A,outputs:n})=>{const{a:t,b:e,c:s}=A;return[`${n.select} = (${t}) ? (${e}) : (${s});`]}}}function Qs(A,n){if(nA(A))return"bool";if("ivec2"===A||"uvec2"===A||"vec2"===A)return"bvec2";if("ivec3"===A||"uvec3"===A||"vec3"===A)return"bvec3";if("ivec4"===A||"uvec4"===A||"vec4"===A)return"bvec4";throw new Error(`Invalid ${n} type: ${A}`)}function us(A,n="equal"){if(nA(A))return"bool";if(AA(A))return A;if("ivec2"===A||"uvec2"===A||"vec2"===A)return"bvec2";if("ivec3"===A||"uvec3"===A||"vec3"===A)return"bvec3";if("ivec4"===A||"uvec4"===A||"vec4"===A)return"bvec4";throw new Error(`Invalid ${n} type: ${A}`)}function Cs(A){return us(A,"notEqual")}class Es extends LA{constructor({a:A}){const n=function(A){if(AA(A))return"bool";if(tA(A))return"int";if(eA(A))return"uint";throw new Error(`Invalid compXor type: ${A}`)}(dA(A));super({a:A,outTypeFunc:A=>n,outKey:"compXor"}),this.statements=({inputs:A,outputs:t})=>{if(nA(this.outTypes.compXor))return[`${t.compXor} = ${A.a};`];const e=(rA(n)?["x","y"]:oA(n)?["x","y","z"]:["x","y","z","w"]).map((n=>`${A.a}.${n}`)),s=AA(n)?"^^":"^";return[`${t.compXor} = ${e.join(` ${s} `)};`]}}}const hs=A=>new ks({value:A}),ps=A=>new _s({value:A}),ds=A=>new Ys({value:A}),ys=A=>new Js({value:A}),fs=A=>new Ks({value:A}),ms=A=>new Xs({value:A}),ws=A=>new na({value:A});class Ds extends LA{constructor({value:A,outType:n,outKey:t}){super({a:A,outTypeFunc:()=>n,outKey:t}),this.statements=({inputs:A,outputs:e})=>[`${e[t]} = ${CA(n)}(${A.a});`]}}class xs extends Ds{constructor({value:A}){super({value:A,outType:"bool",outKey:"bool"})}}class Ss extends Ds{constructor({value:A}){super({value:A,outType:"int",outKey:"int"})}}class bs extends Ds{constructor({value:A}){super({value:A,outType:"uint",outKey:"uint"})}}class ks extends Ds{constructor({value:A}){super({value:A,outType:"float",outKey:"float"})}}class Ms extends Ds{constructor({value:A}){super({value:A,outType:"bvec2",outKey:"bvec2"})}}class vs extends Ds{constructor({value:A}){super({value:A,outType:"bvec3",outKey:"bvec3"})}}class Fs extends Ds{constructor({value:A}){super({value:A,outType:"bvec4",outKey:"bvec4"})}}class Ns extends Ds{constructor({value:A}){super({value:A,outType:"ivec2",outKey:"ivec2"})}}class Rs extends Ds{constructor({value:A}){super({value:A,outType:"ivec3",outKey:"ivec3"})}}class Gs extends Ds{constructor({value:A}){super({value:A,outType:"ivec4",outKey:"ivec4"})}}class Us extends Ds{constructor({value:A}){super({value:A,outType:"uvec2",outKey:"uvec2"})}}class Ls extends Ds{constructor({value:A}){super({value:A,outType:"uvec3",outKey:"uvec3"})}}class Ts extends Ds{constructor({value:A}){super({value:A,outType:"uvec4",outKey:"uvec4"})}}class _s extends Ds{constructor({value:A}){super({value:A,outType:"vec2",outKey:"vec2"})}}class Ys extends Ds{constructor({value:A}){super({value:A,outType:"vec3",outKey:"vec3"})}}class Js extends Ds{constructor({value:A}){super({value:A,outType:"vec4",outKey:"vec4"})}}class Hs extends Ds{constructor({value:A}){super({value:A,outType:"mat2",outKey:"mat2"})}}class qs extends Ds{constructor({value:A}){super({value:A,outType:"mat3",outKey:"mat3"})}}class zs extends Ds{constructor({value:A}){super({value:A,outType:"mat4",outKey:"mat4"})}}class Ks extends LA{constructor({value:A}){super({a:A,outKey:"int",outTypeFunc:()=>"int"}),this.statements=({inputs:A,outputs:n})=>[`${n.int} = floatBitsToInt(${A.a});`]}}class Ps extends LA{constructor({value:A}){super({a:A,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:A,outputs:n})=>[`${n.uint} = floatBitsToUint(${A.a});`]}}class Os extends LA{constructor({value:A}){super({a:A,outKey:"float",outTypeFunc:()=>"float"}),this.statements=({inputs:A,outputs:n})=>[`${n.float} = intBitsToFloat(${A.a});`]}}class Vs extends LA{constructor({value:A}){super({a:A,outKey:"float",outTypeFunc:()=>"float"}),this.statements=({inputs:A,outputs:n})=>[`${n.float} = uintBitsToFloat(${A.a});`]}}class js extends LA{constructor({value:A}){super({a:A,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:A,outputs:n})=>[`${n.uint} = packSnorm2x16(${A.a});`]}}class Zs extends LA{constructor({value:A}){super({a:A,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:A,outputs:n})=>[`${n.vec2} = unpackSnorm2x16(${A.a});`]}}class $s extends LA{constructor({value:A}){super({a:A,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:A,outputs:n})=>[`${n.uint} = packUnorm2x16(${A.a});`]}}class Ws extends LA{constructor({value:A}){super({a:A,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:A,outputs:n})=>[`${n.vec2} = unpackUnorm2x16(${A.a});`]}}class Xs extends LA{constructor({value:A}){super({a:A,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:A,outputs:n})=>[`${n.uint} = packHalf2x16(${A.a});`]}}class Aa extends LA{constructor({value:A}){super({a:A,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:A,outputs:n})=>[`${n.vec2} = unpackHalf2x16(${A.a});`]}}class na extends LA{constructor({value:A}){super({a:A,outKey:"rgba8",outTypeFunc:()=>"vec4"}),this.statements=({inputs:A,outputs:n})=>[`uvec4 uRgba = uvec4(${A.a} & 0xffu, (${A.a} >> 8u) & 0xffu, (${A.a} >> 16u) & 0xffu, (${A.a} >> 24u) & 0xffu);`,`${n.rgba8} = vec4(uRgba) / 255.0;`]}}const ta=(A,n)=>new ga({a:A,b:n}),ea=A=>new Ia({a:A}),sa=A=>new wa({vector:A}),aa=({vector:A,vectorType:n,x:t,y:e,z:s,w:a,r:i,g:r,b:o,a:g})=>new Da({vector:A,vectorType:n,x:t,y:e,z:s,w:a,r:i,g:r,b:o,a:g}),ia=(A,n)=>new Ba({a:A,b:n});class ra extends LA{constructor({a:A}){super({a:A,outTypeFunc:A=>"float",outKey:"length"}),this.statements=({inputs:A,outputs:n})=>[`${n.length} = length(${A.a});`]}}class oa extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"distance",outTypeFunc:(A,n)=>"float"}),this.statements=({inputs:A,outputs:n})=>[`${n.distance} = distance(${A.a}, ${A.b});`]}}class ga extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"dot",outTypeFunc:(A,n)=>"float"}),this.statements=({inputs:A,outputs:n})=>[`${n.dot} = dot(${A.a}, ${A.b});`]}}class ca extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"cross",outTypeFunc:(A,n)=>"vec3"}),this.statements=({inputs:A,outputs:n})=>[`${n.cross} = cross(${A.a}, ${A.b});`]}}class Ia extends LA{constructor({a:A}){super({a:A,outTypeFunc:A=>A,outKey:"normalize"}),this.statements=({inputs:A,outputs:n})=>[`${n.normalize} = normalize(${A.a});`]}}class la extends LA{constructor({a:A}){super({a:A,outTypeFunc:A=>function(A){if("vec3"===A)return"vec2";if("vec4"===A)return"vec3";throw new Error("Invalid type")}(A),outKey:"projected"}),this.statements=({inputs:A,outputs:n})=>{if("vec3"===this.inTypes.a)return[`${n.projected} = ${A.a}.xy / ${A.a}.z;`];if("vec4"===this.inTypes.a)return[`${n.projected} = ${A.a}.xyz / ${A.a}.w;`];throw new Error("Invalid type")}}}class Ba extends TA{constructor({a:A,b:n}){const t=function(A){if("float"===A)return"vec2";if("vec2"===A)return"vec3";if("vec3"===A)return"vec4";throw new Error("Invalid type")}(dA(A));super({a:A,b:n,outKey:"extend",outTypeFunc:()=>t}),this.statements=({inputs:A,outputs:n})=>[`${n.extend} = ${t}(${A.a}, ${A.b});`]}}class Qa extends _A{constructor({a:A,b:n,c:t}){super({a:A,b:n,c:t,outKey:"forward",outTypeFunc:(A,n,t)=>A}),this.statements=({inputs:A,outputs:n})=>[`${n.forward} = faceforward(${A.a}, ${A.b}, ${A.c});`]}}class ua extends TA{constructor({incident:A,normal:n}){super({a:A,b:n,outKey:"reflection",outTypeFunc:(A,n)=>A}),this.statements=({inputs:A,outputs:n})=>[`${n.reflection} = reflect(${A.a}, ${A.b});`]}}class Ca extends _A{constructor({incident:A,normal:n,eta:t}){super({a:A,b:n,c:t,outKey:"refraction",outTypeFunc:(A,n,t)=>A}),this.statements=({inputs:A,outputs:n})=>[`${n.refraction} = refract(${A.a}, ${A.b}, ${A.c});`]}}class Ea extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"product",outTypeFunc:(A,n)=>A}),this.statements=({inputs:t,outputs:e})=>[`${e.product} = matrixCompMult(${A}, ${n});`]}}function ha(A,n){if("vec2"===A){if("vec2"===n)return"mat2";if("vec3"===n)return"mat3x2";if("vec4"===n)return"mat4x2"}if("vec3"===A){if("vec2"===n)return"mat2x3";if("vec3"===n)return"mat3";if("vec4"===n)return"mat4x3"}if("vec4"===A){if("vec2"===n)return"mat2x4";if("vec3"===n)return"mat3x4";if("vec4"===n)return"mat4"}throw new Error(`Invalid outer type: ${A}, ${n}`)}class pa extends TA{constructor({a:A,b:n}){super({a:A,b:n,outKey:"outer",outTypeFunc:ha}),this.statements=({inputs:A,outputs:n})=>[`${n.outer} = outerProduct(${A.a}, ${A.b});`]}}function da(A){if("mat2"===A)return"mat2";if("mat3"===A)return"mat3";if("mat4"===A)return"mat4";if("mat2x2"===A)return"mat2x2";if("mat2x3"===A)return"mat3x2";if("mat2x4"===A)return"mat4x2";if("mat3x2"===A)return"mat2x3";if("mat3x3"===A)return"mat3x3";if("mat3x4"===A)return"mat4x3";if("mat4x2"===A)return"mat2x4";if("mat4x3"===A)return"mat3x4";if("mat4x4"===A)return"mat4x4";throw new Error(`Invalid transpose type: ${A}`)}class ya extends LA{constructor({a:A}){super({a:A,outKey:"transpose",outTypeFunc:da}),this.statements=({inputs:A,outputs:n})=>[`${n.transpose} = transpose(${A.a});`]}}class fa extends LA{constructor({a:A}){super({a:A,outKey:"det",outTypeFunc:A=>"float"}),this.statements=({inputs:A,outputs:n})=>[`${n.det} = determinant(${A.a});`]}}class ma extends LA{constructor({a:A}){super({a:A,outKey:"inverse",outTypeFunc:A=>A}),this.statements=({inputs:n,outputs:t})=>[`${t.inverse} = inverse(${A});`]}}class wa extends MA{constructor({vector:A}){const n={vector:dA(A)},t=function(A){switch(A){case"vec2":return{x:"float",y:"float",r:"float",g:"float"};case"vec3":return{x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"};case"vec4":return{x:"float",y:"float",z:"float",w:"float",r:"float",g:"float",b:"float",a:"float"};case"ivec2":return{x:"int",y:"int",r:"int",g:"int"};case"ivec3":return{x:"int",y:"int",z:"int",r:"int",g:"int",b:"int"};case"ivec4":return{x:"int",y:"int",z:"int",w:"int",r:"int",g:"int",b:"int",a:"int"};case"uvec2":return{x:"uint",y:"uint",r:"uint",g:"uint"};case"uvec3":return{x:"uint",y:"uint",z:"uint",r:"uint",g:"uint",b:"uint"};case"uvec4":return{x:"uint",y:"uint",z:"uint",w:"uint",r:"uint",g:"uint",b:"uint",a:"uint"};default:throw new Error(`Invalid vector type: ${A}`)}}(n.vector);super({inTypes:n,outTypes:t,inputs:{vector:A}}),this.statements=({inputs:A,outputs:n})=>{const{x:t,y:e,z:s,w:a,r:i,g:r,b:o,a:g}=n,{vector:c}=A;return[t?`${t} = ${c}.x;`:null,e?`${e} = ${c}.y;`:null,s?`${s} = ${c}.z;`:null,a?`${a} = ${c}.w;`:null,i?`${i} = ${c}.r;`:null,r?`${r} = ${c}.g;`:null,o?`${o} = ${c}.b;`:null,g?`${g} = ${c}.a;`:null].filter(Boolean)}}}class Da extends MA{constructor({vector:A,vectorType:n,x:t,y:e,z:s,w:a,r:i,g:r,b:o,a:g}){if(!A&&!n)throw new Error("Either vector or vectorType must be provided");const c=n??dA(A),I=BA(c),l=QA(c),B={vector:c,x:I,y:I,r:I,g:I},Q={vector:A,x:t,y:e,r:i,g:r};l>=3&&(Object.assign(B,{z:I,b:I}),Object.assign(Q,{z:s,b:o})),l>=4&&(Object.assign(B,{w:I,a:I}),Object.assign(Q,{w:a,a:g})),super({inTypes:B,outTypes:{vector:c},inputs:Q}),this.statements=({inputs:A,outputs:n})=>{const{vector:t}=n,{vector:e,x:s,y:a,z:i,w:r,r:o,g,b:c,a:B}=A,Q=[`${t}.x = ${s??o??(e?`${e}.x`:SA(I))};`,`${t}.y = ${a??g??(e?`${e}.y`:SA(I))};`];return l>=3&&Q.push(`${t}.z = ${i??c??(e?`${e}.z`:SA(I))};`),l>=4&&Q.push(`${t}.w = ${r??B??(e?`${e}.w`:SA(I))};`),Q}}dynoOut(){return new fA(this,"vector")}}class xa extends LA{constructor({vector:A,select:n}){super({a:A,outKey:"swizzle",outTypeFunc:A=>function(A,n){let t=null;if(sA(A)?t=1===n.length?"float":2===n.length?"vec2":3===n.length?"vec3":4===n.length?"vec4":null:tA(A)?t=1===n.length?"int":2===n.length?"ivec2":3===n.length?"ivec3":4===n.length?"ivec4":null:eA(A)&&(t=1===n.length?"uint":2===n.length?"uvec2":3===n.length?"uvec3":4===n.length?"uvec4":null),null==t)throw new Error(`Invalid swizzle: ${n}`);return t}(A,n)}),this.statements=({inputs:A,outputs:t})=>[`${t.swizzle} = ${A.a}.${n};`]}}const Sa=A=>new Ta({value:A}),ba=A=>new _a({value:A}),ka=A=>new Ya({value:A}),Ma=A=>new Ja({value:A}),va=A=>new za({value:A}),Fa=A=>new Ka({value:A}),Na=(A,n,t)=>new Pa({z:A,zNear:n,zFar:t}).outputs.depth;class Ra extends MA{constructor({from:A,to:n,index:t}){super({inTypes:{from:"int",to:"int",index:"int"},outTypes:{index:"int"},inputs:{from:A,to:n,index:t},statements:({inputs:A,outputs:n})=>[`${n.index} = ${A.index} - ${A.from} + ${A.to};`]})}dynoOut(){return new fA(this,"index")}}class Ga extends MA{constructor({state:A}){const n=dA(A);super({inTypes:{state:n},outTypes:{state:"uint"},inputs:{state:A},globals:()=>[UA("\n          uint pcg_next(uint state) {\n            return state * 747796405u + 2891336453u;\n          }\n        ")],statements:({inputs:A,outputs:t})=>{const e="uint"===n?`${A.state}`:"int"===n?`uint(${A.state})`:`floatBitsToUint(${A.state})`;return[`${t.state} = pcg_next(${e});`]}})}dynoOut(){return new fA(this,"state")}}class Ua extends MA{constructor({state:A}){super({inTypes:{state:"uint"},outTypes:{hash:"uint"},inputs:{state:A},globals:()=>[UA("\n          uint pcg_hash(uint state) {\n            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n            return (hash >> 22u) ^ hash;\n          }\n        ")],statements:({inputs:A,outputs:n})=>[`${n.hash} = pcg_hash(${A.state});`]})}dynoOut(){return new fA(this,"hash")}}class La extends MA{constructor({value:A}){const n=dA(A),t=uA(n);super({inTypes:{value:n},outTypes:{state:"uint"},inputs:{value:A},globals:()=>[UA("\n          uint pcg_mix(uint value) {\n            return value;\n          }\n          uint pcg_mix(uvec2 value) {\n            return value.x + 0x9e3779b9u * value.y;\n          }\n          uint pcg_mix(uvec3 value) {\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;\n          }\n          uint pcg_mix(uvec4 value) {\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;\n          }\n        ")],statements:({inputs:A,outputs:e})=>{const s=eA(n)?`${A.value}`:tA(n)?`${t}(${A.value})`:`floatBitsToUint(${A.value})`;return[`${t} bits = ${s};`,`${e.state} = pcg_mix(bits);`]}})}dynoOut(){return new fA(this,"state")}}class Ta extends vA{constructor({value:A}){super({inTypes:{value:dA(A)},outTypes:{hash:"uint"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");let n=new La({value:A}).outputs.state;return n=new Ga({state:n}).outputs.state,new Ua({state:n}).outputs}})}dynoOut(){return new fA(this,"hash")}}class _a extends vA{constructor({value:A}){super({inTypes:{value:dA(A)},outTypes:{hash:"uvec2"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");let n=new La({value:A}).outputs.state;n=new Ga({state:n}).outputs.state;const t=new Ua({state:n}).outputs.hash;n=new Ga({state:n}).outputs.state;const e=new Ua({state:n}).outputs.hash;return{hash:aa({vectorType:"uvec2",x:t,y:e})}}})}dynoOut(){return new fA(this,"hash")}}class Ya extends vA{constructor({value:A}){super({inTypes:{value:dA(A)},outTypes:{hash:"uvec3"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");let n=new La({value:A}).outputs.state;n=new Ga({state:n}).outputs.state;const t=new Ua({state:n}).outputs.hash;n=new Ga({state:n}).outputs.state;const e=new Ua({state:n}).outputs.hash;n=new Ga({state:n}).outputs.state;const s=new Ua({state:n}).outputs.hash;return{hash:aa({vectorType:"uvec3",x:t,y:e,z:s})}}})}dynoOut(){return new fA(this,"hash")}}class Ja extends vA{constructor({value:A}){super({inTypes:{value:dA(A)},outTypes:{hash:"uvec4"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");let n=new La({value:A}).outputs.state;n=new Ga({state:n}).outputs.state;const t=new Ua({state:n}).outputs.hash;n=new Ga({state:n}).outputs.state;const e=new Ua({state:n}).outputs.hash;n=new Ga({state:n}).outputs.state;const s=new Ua({state:n}).outputs.hash;n=new Ga({state:n}).outputs.state;const a=new Ua({state:n}).outputs.hash;return{hash:aa({vectorType:"uvec4",x:t,y:e,z:s,w:a})}}})}dynoOut(){return new fA(this,"hash")}}class Ha extends vA{constructor({value:A}){super({inTypes:{value:dA(A)},outTypes:{hash:"float"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");const n=Sa(A);return{hash:Qe(hs(n),xA("float",1/2**32))}}})}dynoOut(){return new fA(this,"hash")}}class qa extends vA{constructor({value:A}){super({inTypes:{value:dA(A)},outTypes:{hash:"vec2"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");const n=ba(A);return{hash:Qe(ps(n),xA("float",1/2**32))}}})}dynoOut(){return new fA(this,"hash")}}class za extends vA{constructor({value:A}){super({inTypes:{value:dA(A)},outTypes:{hash:"vec3"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");const n=ka(A);return{hash:Qe(ds(n),xA("float",1/2**32))}}})}dynoOut(){return new fA(this,"hash")}}class Ka extends vA{constructor({value:A}){super({inTypes:{value:dA(A)},outTypes:{hash:"vec4"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");const n=Ma(A);return{hash:Qe(ys(n),xA("float",1/2**32))}}})}dynoOut(){return new fA(this,"hash")}}class Pa extends MA{constructor({z:A,zNear:n,zFar:t}){super({inTypes:{z:"float",zNear:"float",zFar:"float"},outTypes:{depth:"float"},inputs:{z:A,zNear:n,zFar:t},statements:({inputs:A,outputs:n})=>[`float clamped = clamp(${A.z}, ${A.zNear}, ${A.zFar});`,`${n.depth} = (log2(clamped + 1.0) - log2(${A.zNear} + 1.0)) / (log2(${A.zFar} + 1.0) - log2(${A.zNear} + 1.0));`]})}dynoOut(){return new fA(this,"depth")}}const Oa=(A,{scale:n,scales:t,rotate:e,translate:s})=>new ja({position:A,scale:n,scales:t,rotate:e,translate:s}).outputs.position,Va=(A,{scale:n,scales:t,rotate:e})=>new Za({dir:A,scale:n,scales:t,rotate:e}).outputs.dir;class ja extends MA{constructor({position:A,scale:n,scales:t,rotate:e,translate:s}){super({inTypes:{position:"vec3",scale:"float",scales:"vec3",rotate:"vec4",translate:"vec3"},outTypes:{position:"vec3"},inputs:{position:A,scale:n,scales:t,rotate:e,translate:s},statements:({inputs:A,outputs:n})=>{const{position:t}=n;if(!t)return[];const{scale:e,scales:s,rotate:a,translate:i}=A;return[`${t} = ${A.position??"vec3(0.0, 0.0, 0.0)"};`,e?`${t} *= ${e};`:null,s?`${t} *= ${s};`:null,a?`${t} = quatVec(${a}, ${t});`:null,i?`${t} += ${i};`:null].filter(Boolean)}})}}class Za extends MA{constructor({dir:A,scale:n,scales:t,rotate:e}){super({inTypes:{dir:"vec3",scale:"float",scales:"vec3",rotate:"vec4"},outTypes:{dir:"vec3"},inputs:{dir:A,scale:n,scales:t,rotate:e},statements:({inputs:A,outputs:n})=>{const{dir:t}=n;if(!t)return[];const{scale:e,scales:s,rotate:a}=A;return[`${t} = ${A.dir??"vec3(0.0, 0.0, 0.0)"};`,e?`${t} *= ${e};`:null,s?`${t} *= ${s};`:null,a?`${t} = quatVec(${a}, ${t});`:null].filter(Boolean)}})}}class $a extends MA{constructor({quaternion:A,rotate:n}){super({inTypes:{quaternion:"vec4",rotate:"vec4"},outTypes:{quaternion:"vec4"},inputs:{quaternion:A,rotate:n},statements:({inputs:A,outputs:t})=>{const{quaternion:e}=t;return e?[`${e} = ${A.quaternion??"vec4(0.0, 0.0, 0.0, 1.0)"};`,n?`${e} = quatQuat(${A.rotate}, ${e});`:null].filter(Boolean):[]}})}}class Wa extends MA{constructor({texture:A,lod:n}){const t=dA(A);super({inTypes:{texture:t,lod:"int"},outTypes:{size:ni(t)},inputs:{texture:A,lod:n},statements:({inputs:A,outputs:n})=>[`${n.size} = textureSize(${A.texture}, ${A.lod??"0"});`]})}dynoOut(){return new fA(this,"size")}}class Xa extends MA{constructor({texture:A,coord:n,bias:t}){const e=dA(A);super({inTypes:{texture:e,coord:ti(e),bias:"float"},outTypes:{sample:ei(e)},inputs:{texture:A,coord:n,bias:t},statements:({inputs:A,outputs:n})=>[`${n.sample} = texture(${A.texture}, ${A.coord}${A.bias?`, ${A.bias}`:""});`]})}dynoOut(){return new fA(this,"sample")}}class Ai extends MA{constructor({texture:A,coord:n,lod:t}){const e=dA(A);super({inTypes:{texture:e,coord:ni(e),lod:"int"},outTypes:{texel:ei(e)},inputs:{texture:A,coord:n,lod:t},statements:({inputs:A,outputs:n})=>[`${n.texel} = texelFetch(${A.texture}, ${A.coord}, ${A.lod??"0"});`]})}dynoOut(){return new fA(this,"texel")}}function ni(A){switch(A){case"sampler2D":case"usampler2D":case"isampler2D":case"samplerCube":case"usamplerCube":case"isamplerCube":case"sampler2DShadow":case"samplerCubeShadow":return"ivec2";case"sampler3D":case"usampler3D":case"isampler3D":case"sampler2DArray":case"usampler2DArray":case"isampler2DArray":case"sampler2DArrayShadow":return"ivec3";default:throw new Error(`Invalid texture type: ${A}`)}}function ti(A){switch(A){case"sampler2D":case"usampler2D":case"isampler2D":return"vec2";case"sampler3D":case"usampler3D":case"isampler3D":case"samplerCube":case"usamplerCube":case"isamplerCube":case"sampler2DArray":case"usampler2DArray":case"isampler2DArray":case"sampler2DShadow":return"vec3";case"samplerCubeShadow":case"sampler2DArrayShadow":return"vec4";default:throw new Error(`Invalid texture type: ${A}`)}}function ei(A){switch(A){case"sampler2D":case"sampler2DArray":case"sampler3D":case"samplerCube":case"sampler2DShadow":return"vec4";case"usampler2D":case"usampler2DArray":case"usampler3D":case"usamplerCube":return"uvec4";case"isampler2D":case"isampler2DArray":case"isampler3D":case"isamplerCube":return"ivec4";case"samplerCubeShadow":case"sampler2DArrayShadow":return"float";default:throw new Error(`Invalid texture type: ${A}`)}}const si=A=>new ri({radians:A});class ai extends LA{constructor({degrees:A}){super({a:A,outTypeFunc:A=>A,outKey:"radians"}),this.statements=({inputs:A,outputs:n})=>[`${n.radians} = radians(${A.a});`]}}class ii extends LA{constructor({radians:A}){super({a:A,outTypeFunc:A=>A,outKey:"degrees"}),this.statements=({inputs:A,outputs:n})=>[`${n.degrees} = degrees(${A.a});`]}}class ri extends LA{constructor({radians:A}){super({a:A,outTypeFunc:A=>A,outKey:"sin"}),this.statements=({inputs:A,outputs:n})=>[`${n.sin} = sin(${A.a});`]}}class oi extends LA{constructor({radians:A}){super({a:A,outTypeFunc:A=>A,outKey:"cos"}),this.statements=({inputs:A,outputs:n})=>[`${n.cos} = cos(${A.a});`]}}class gi extends LA{constructor({radians:A}){super({a:A,outTypeFunc:A=>A,outKey:"tan"}),this.statements=({inputs:A,outputs:n})=>[`${n.tan} = tan(${A.a});`]}}class ci extends LA{constructor({sin:A}){super({a:A,outTypeFunc:A=>A,outKey:"asin"}),this.statements=({inputs:A,outputs:n})=>[`${n.asin} = asin(${A.a});`]}}class Ii extends LA{constructor({cos:A}){super({a:A,outTypeFunc:A=>A,outKey:"acos"}),this.statements=({inputs:A,outputs:n})=>[`${n.acos} = acos(${A.a});`]}}class li extends LA{constructor({tan:A}){super({a:A,outTypeFunc:A=>A,outKey:"atan"}),this.statements=({inputs:A,outputs:n})=>[`${n.atan} = atan(${A.a});`]}}class Bi extends TA{constructor({y:A,x:n}){super({a:A,b:n,outTypeFunc:(A,n)=>A,outKey:"atan2"}),this.statements=({inputs:A,outputs:n})=>[`${n.atan2} = atan2(${A.a}, ${A.b});`]}}class Qi extends LA{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"sinh"}),this.statements=({inputs:A,outputs:n})=>[`${n.sinh} = sinh(${A.a});`]}}class ui extends LA{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"cosh"}),this.statements=({inputs:A,outputs:n})=>[`${n.cosh} = cosh(${A.a});`]}}class Ci extends LA{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"tanh"}),this.statements=({inputs:A,outputs:n})=>[`${n.tanh} = tanh(${A.a});`]}}class Ei extends LA{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"asinh"}),this.statements=({inputs:A,outputs:n})=>[`${n.asinh} = asinh(${A.a});`]}}class hi extends LA{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"acosh"}),this.statements=({inputs:A,outputs:n})=>[`${n.acosh} = acosh(${A.a});`]}}class pi extends LA{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"atanh"}),this.statements=({inputs:A,outputs:n})=>[`${n.atanh} = atanh(${A.a});`]}}const di=Object.freeze(Object.defineProperty({__proto__:null,Abs:Me,Acos:Ii,Acosh:hi,Add:fe,All:ls,And:ns,Any:Is,Asin:ci,Asinh:Ei,Atan:li,Atan2:Bi,Atanh:pi,BVec2:Ms,BVec3:vs,BVec4:Fs,BinaryOp:TA,Bool:xs,Ceil:Ne,Clamp:Oe,Combine:Da,CombineGsplat:nn,CompMult:Ea,CompXor:Es,Compilation:kA,Cos:oi,Cosh:ui,Cross:ca,Degrees:ii,Determinant:fa,Distance:oa,Div:De,Dot:ga,Dyno:MA,DynoBlock:vA,DynoBool:ln,DynoBvec2:Cn,DynoBvec3:dn,DynoBvec4:wn,DynoConst:DA,DynoFloat:un,DynoInt:Qn,DynoIsampler2D:Jn,DynoIsampler2DArray:zn,DynoIsampler3D:On,DynoIsamplerCube:Zn,DynoIvec2:hn,DynoIvec3:fn,DynoIvec4:xn,DynoLiteral:mA,DynoMat2:bn,DynoMat2x2:kn,DynoMat2x3:Mn,DynoMat2x4:vn,DynoMat3:Fn,DynoMat3x2:Nn,DynoMat3x3:Rn,DynoMat3x4:Gn,DynoMat4:Un,DynoMat4x2:Ln,DynoMat4x3:Tn,DynoMat4x4:_n,DynoOutput:fA,DynoProgram:Nt,DynoProgramTemplate:Rt,DynoRemapIndex:Ra,DynoSampler2D:Hn,DynoSampler2DArray:Kn,DynoSampler2DArrayShadow:Xn,DynoSampler2DShadow:Wn,DynoSampler3D:Vn,DynoSamplerCube:$n,DynoSamplerCubeShadow:At,DynoUint:Bn,DynoUniform:In,DynoUsampler2D:Yn,DynoUsampler2DArray:qn,DynoUsampler3D:Pn,DynoUsamplerCube:jn,DynoUvec2:En,DynoUvec3:yn,DynoUvec4:Dn,DynoValue:yA,DynoVec2:pn,DynoVec3:mn,DynoVec4:Sn,Equal:gs,Exp:Te,Exp2:_e,ExtendVec:Ba,FaceForward:Qa,Float:ks,FloatBitsToInt:Ks,FloatBitsToUint:Ps,Floor:Fe,Fract:Ue,GreaterThan:rs,GreaterThanEqual:os,Gsplat:YA,GsplatNormal:en,Hash:Ta,Hash2:_a,Hash3:Ya,Hash4:Ja,HashFloat:Ha,HashVec2:qa,HashVec3:za,HashVec4:Ka,IMod:xe,IVec2:Ns,IVec3:Rs,IVec4:Gs,Int:Ss,IntBitsToFloat:Os,Inverse:ma,InverseSqrt:ze,IsInf:We,IsNan:$e,Length:ra,LessThan:as,LessThanEqual:is,Log:Ye,Log2:Je,Mat2:Hs,Mat3:qs,Mat4:zs,Max:Pe,Min:Ke,Mix:Ve,Mod:Se,Modf:be,Mul:we,Neg:ke,Normalize:Ia,NormalizedDepth:Pa,Not:ss,NotEqual:cs,NumPackedSplats:ZA,Or:ts,Outer:pa,OutputPackedSplat:rn,OutputRgba8:on,PackHalf2x16:Xs,PackSnorm2x16:js,PackUnorm2x16:$s,PcgHash:Ua,PcgMix:La,PcgNext:Ga,Pow:Le,ProjectH:la,Radians:ai,ReadPackedSplat:WA,ReadPackedSplatRange:XA,ReflectVec:ua,RefractVec:Ca,Round:Ge,Select:Bs,Sign:ve,SimpleCast:Ds,Sin:ri,Sinh:Qi,Smoothstep:Ze,Split:wa,SplitGsplat:An,Sqr:He,Sqrt:qe,Step:je,Sub:me,Swizzle:xa,TPackedSplats:JA,Tan:gi,Tanh:Ci,TexelFetch:Ai,Texture:Xa,TextureSize:Wa,TransformDir:Za,TransformGsplat:sn,TransformPosition:ja,TransformQuaternion:$a,Transpose:ya,TrinaryOp:_A,Trunc:Re,UVec2:Us,UVec3:Ls,UVec4:Ts,Uint:bs,UintBitsToFloat:Vs,UintToRgba8:na,UnaryOp:LA,UnpackHalf2x16:Aa,UnpackSnorm2x16:Zs,UnpackUnorm2x16:Ws,Vec2:_s,Vec3:Ys,Vec4:Js,Xor:es,abs:A=>new Me({a:A}),acos:A=>new Ii({cos:A}),acosh:A=>new hi({x:A}),add:le,all:A=>new ls({a:A}),and:(A,n)=>new ns({a:A,b:n}),any:A=>new Is({a:A}),arrayIndex:()=>{throw new Error("Not implemented")},arrayLength:()=>{throw new Error("Not implemented")},asin:A=>new ci({sin:A}),asinh:A=>new Ei({x:A}),atan:A=>new li({tan:A}),atan2:(A,n)=>new Bi({y:A,x:n}),atanh:A=>new pi({x:A}),bool:A=>new xs({value:A}),bvec2:A=>new Ms({value:A}),bvec3:A=>new vs({value:A}),bvec4:A=>new Fs({value:A}),ceil:A=>new Ne({a:A}),clamp:(A,n,t)=>new Oe({a:A,min:n,max:t}),combine:aa,combineGsplat:KA,comment:()=>{throw new Error("Not implemented")},compMult:(A,n)=>new Ea({a:A,b:n}),compXor:A=>new Es({a:A}),cos:A=>new oi({radians:A}),cosh:A=>new ui({x:A}),cross:(A,n)=>new ca({a:A,b:n}),defineGsplat:VA,defineGsplatNormal:tn,definePackedSplats:jA,degrees:A=>new ii({radians:A}),determinant:A=>new fa({a:A}),distance:(A,n)=>new oa({a:A,b:n}),div:ue,dot:ta,dyno:NA,dynoBlock:FA,dynoBool:(A=!1,n)=>new ln({key:n,value:A}),dynoBvec2:(A,n)=>new Cn({key:n,value:A}),dynoBvec3:(A,n)=>new dn({key:n,value:A}),dynoBvec4:(A,n)=>new wn({key:n,value:A}),dynoConst:xA,dynoDeclare:RA,dynoFloat:gn,dynoFor:()=>{throw new Error("Not implemented")},dynoIf:()=>{throw new Error("Not implemented")},dynoInt:(A=0,n)=>new Qn({key:n,value:A}),dynoIsampler2D:(A,n)=>new Jn({key:n,value:A}),dynoIsampler2DArray:(A,n)=>new zn({key:A,value:n}),dynoIsampler3D:(A,n)=>new On({key:n,value:A}),dynoIsamplerCube:(A,n)=>new Zn({key:n,value:A}),dynoIvec2:(A,n)=>new hn({key:n,value:A}),dynoIvec3:(A,n)=>new fn({key:n,value:A}),dynoIvec4:(A,n)=>new xn({key:n,value:A}),dynoLiteral:wA,dynoMat2:(A,n)=>new bn({key:n,value:A}),dynoMat2x2:(A,n)=>new kn({key:n,value:A}),dynoMat2x3:(A,n)=>new Mn({key:n,value:A}),dynoMat2x4:(A,n)=>new vn({key:n,value:A}),dynoMat3:(A,n)=>new Fn({key:n,value:A}),dynoMat3x2:(A,n)=>new Nn({key:n,value:A}),dynoMat3x3:(A,n)=>new Rn({key:n,value:A}),dynoMat3x4:(A,n)=>new Gn({key:n,value:A}),dynoMat4:(A,n)=>new Un({key:n,value:A}),dynoMat4x2:(A,n)=>new Ln({key:n,value:A}),dynoMat4x3:(A,n)=>new Tn({key:n,value:A}),dynoMat4x4:(A,n)=>new _n({key:n,value:A}),dynoSampler2D:(A,n)=>new Hn({key:n,value:A}),dynoSampler2DArray:(A,n)=>new Kn({key:n,value:A}),dynoSampler2DArrayShadow:(A,n)=>new Xn({key:n,value:A}),dynoSampler2DShadow:(A,n)=>new Wn({key:n,value:A}),dynoSampler3D:(A,n)=>new Vn({key:n,value:A}),dynoSamplerCube:(A,n)=>new $n({key:n,value:A}),dynoSamplerCubeShadow:(A,n)=>new At({key:n,value:A}),dynoSwitch:()=>{throw new Error("Not implemented")},dynoUint:(A=0,n)=>new Bn({key:n,value:A}),dynoUsampler2D:(A,n)=>new Yn({key:n,value:A}),dynoUsampler2DArray:(A,n)=>new qn({key:n,value:A}),dynoUsampler3D:(A,n)=>new Pn({key:n,value:A}),dynoUsamplerCube:(A,n)=>new jn({key:n,value:A}),dynoUvec2:(A,n)=>new En({key:n,value:A}),dynoUvec3:(A,n)=>new yn({key:n,value:A}),dynoUvec4:(A,n)=>new Dn({key:n,value:A}),dynoVec2:(A,n)=>new pn({key:n,value:A}),dynoVec3:cn,dynoVec4:(A,n)=>new Sn({key:n,value:A}),equal:(A,n)=>new gs({a:A,b:n}),exp:A=>new Te({a:A}),exp2:A=>new _e({a:A}),extendVec:ia,faceforward:(A,n,t)=>new Qa({a:A,b:n,c:t}),float:hs,floatBitsToInt:fs,floatBitsToUint:A=>new Ps({value:A}),floor:A=>new Fe({a:A}),fract:pe,greaterThan:(A,n)=>new rs({a:A,b:n}),greaterThanEqual:Xe,gsplatNormal:PA,hash:Sa,hash2:ba,hash3:ka,hash4:Ma,hashFloat:A=>new Ha({value:A}),hashVec2:A=>new qa({value:A}),hashVec3:va,hashVec4:Fa,imod:Ce,int:A=>new Ss({value:A}),intBitsToFloat:A=>new Os({value:A}),inverse:A=>new ma({a:A}),inversesqrt:A=>new ze({a:A}),isAllFloatType:iA,isBoolType:AA,isFloatType:sA,isInf:A=>new We({a:A}),isIntType:tA,isMat2:cA,isMat3:IA,isMat4:lA,isMatFloatType:aA,isNan:A=>new $e({a:A}),isScalarType:nA,isUintType:eA,isVector2Type:rA,isVector3Type:oA,isVector4Type:gA,isVectorType:function(A){return rA(A)||oA(A)||gA(A)},ivec2:A=>new Ns({value:A}),ivec3:A=>new Rs({value:A}),ivec4:A=>new Gs({value:A}),length:A=>new ra({a:A}),lessThan:(A,n)=>new as({a:A,b:n}),lessThanEqual:(A,n)=>new is({a:A,b:n}),literalNegOne:function(A){const n=String(A);if(AA(A))return`${n}(true)`;if(iA(A))return`${n}(-1.0)`;if(tA(A))return`${n}(-1)`;if(eA(A))return`${n}(0xFFFFFFFFu)`;throw new Error(`Type not implemented: ${n}`)},literalOne:function(A){const n=String(A);if(AA(A))return`${n}(true)`;if(iA(A))return`${n}(1.0)`;if(tA(A))return`${n}(1)`;if(eA(A))return`${n}(1u)`;throw new Error(`Type not implemented: ${n}`)},literalZero:SA,log:A=>new Ye({a:A}),log2:A=>new Je({a:A}),mat2:A=>new Hs({value:A}),mat3:A=>new qs({value:A}),mat4:A=>new zs({value:A}),max:de,min:(A,n)=>new Ke({a:A,b:n}),mix:ye,mod:Ee,modf:A=>new be({a:A}).outputs,mul:Qe,neg:he,normalize:ea,normalizedDepth:Na,not:A=>new ss({a:A}),notEqual:(A,n)=>new cs({a:A,b:n}),numPackedSplats:A=>new ZA({packedSplats:A}),numberAsFloat:pA,numberAsInt:EA,numberAsUint:hA,or:(A,n)=>new ts({a:A,b:n}),outer:(A,n)=>new pa({a:A,b:n}),outputPackedSplat:an,outputRgba8:A=>new on({rgba8:A}),packHalf2x16:ms,packSnorm2x16:A=>new js({value:A}),packUnorm2x16:A=>new $s({value:A}),pcgHash:A=>new Ua({state:A}),pcgMix:A=>new La({value:A}),pcgNext:A=>new Ga({state:A}),pow:(A,n)=>new Le({a:A,b:n}),projectH:A=>new la({a:A}),radians:A=>new ai({degrees:A}),readPackedSplat:HA,readPackedSplatRange:qA,reflectVec:(A,n)=>new ua({incident:A,normal:n}),refractVec:(A,n,t)=>new Ca({incident:A,normal:n,eta:t}),remapIndex:(A,n,t)=>new Ra({index:A,from:n,to:t}),round:A=>new Ge({a:A}),sameSizeIvec:function(A){if(nA(A))return"int";if(rA(A))return"ivec2";if(oA(A))return"ivec3";if(gA(A))return"ivec4";throw new Error(`Invalid vector type: ${A}`)},sameSizeUvec:uA,sameSizeVec:function(A){if(nA(A))return"float";if(rA(A))return"vec2";if(oA(A))return"vec3";if(gA(A))return"vec4";throw new Error(`Invalid vector type: ${A}`)},select:As,sign:A=>new ve({a:A}),sin:si,sinh:A=>new Qi({x:A}),smoothstep:(A,n,t)=>new Ze({edge0:A,edge1:n,x:t}),split:sa,splitGsplat:zA,sqr:A=>new He({a:A}),sqrt:A=>new qe({a:A}),step:(A,n)=>new je({edge:A,x:n}),sub:Be,swizzle:(A,n)=>new xa({vector:A,select:n}),tan:A=>new gi({radians:A}),tanh:A=>new Ci({x:A}),texelFetch:(A,n,t)=>new Ai({texture:A,coord:n,lod:t}),texture:(A,n,t)=>new Xa({texture:A,coord:n,bias:t}),textureSize:(A,n)=>new Wa({texture:A,lod:n}),transformDir:Va,transformGsplat:OA,transformPos:Oa,transformQuat:(A,{rotate:n})=>new $a({quaternion:A,rotate:n}).outputs.quaternion,transpose:A=>new ya({a:A}),trunc:A=>new Re({a:A}),typeLiteral:CA,uint:A=>new bs({value:A}),uintBitsToFloat:A=>new Vs({value:A}),uintToRgba8:ws,uniform:(A,n,t)=>new In({key:A,type:n,value:t}),unindent:UA,unindentLines:GA,unpackHalf2x16:A=>new Aa({value:A}),unpackSnorm2x16:A=>new Zs({value:A}),unpackUnorm2x16:A=>new Ws({value:A}),uvec2:A=>new Us({value:A}),uvec3:A=>new Ls({value:A}),uvec4:A=>new Ts({value:A}),valType:dA,vec2:ps,vec3:ds,vec4:ys,vectorDim:QA,vectorElementType:BA,xor:(A,n)=>new es({a:A,b:n})},Symbol.toStringTag,{value:"Module"}));const yi=class A{constructor({renderer:A}={}){this.renderer=A,this.capacity=0,this.count=0}dispose(){this.target&&(this.target.dispose(),this.target=void 0)}ensureBuffer(A,n){const t=4*(Math.ceil(Math.max(1,A)/$)*$);if(n.byteLength>=t)return n;const e=new ArrayBuffer(t);if(n instanceof ArrayBuffer)return e;return new(0,n.constructor)(e)}ensureCapacity(A){const{width:n,height:t,depth:s,maxSplats:a}=Qt(A);(!this.target||a>this.capacity)&&(this.dispose(),this.capacity=a,this.target=new e.WebGLArrayRenderTarget(n,t,s,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:e.NearestFilter,minFilter:e.NearestFilter}),this.target.texture.format=e.RGBAFormat,this.target.texture.type=e.UnsignedByteType,this.target.texture.internalFormat="RGBA8",this.target.scissorTest=!0)}prepareProgramMaterial(n){let t=A.readbackProgram.get(n);if(!t){const e=FA({index:"int"},{rgba8:"vec4"},(({index:A})=>{n.inputs.index=A;return{rgba8:new on({rgba8:n.outputs.rgba8})}}));A.programTemplate||(A.programTemplate=new Rt("precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout vec4 target;\n\n{{ GLOBALS }}\n\nvoid computeReadback(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        computeReadback(index);\n    } else {\n        target = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}")),t=new Nt({graph:e,inputs:{index:"index"},outputs:{rgba8:"target"},template:A.programTemplate}),Object.assign(t.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),A.readbackProgram.set(n,t)}const e=t.prepareMaterial();return A.mesh.material=e,{program:t,material:e}}saveRenderState(A){return{xrEnabled:A.xr.enabled,autoClear:A.autoClear}}resetRenderState(A,n){A.setRenderTarget(null),A.xr.enabled=n.xrEnabled,A.autoClear=n.autoClear}process({count:n,material:t}){const e=this.renderer;if(!e)throw new Error("No renderer");if(!this.target)throw new Error("No target");const s=$*W;t.uniforms.targetBase.value=0,t.uniforms.targetCount.value=n;let a=0;for(;a<n;){const i=Math.floor(a/s),r=i*s,o=Math.min(W,Math.ceil((n-r)/$));t.uniforms.targetLayer.value=i,this.target.scissor.set(0,0,$,o),e.setRenderTarget(this.target,i),e.xr.enabled=!1,e.autoClear=!1,e.render(A.scene,A.camera),a+=$*o}this.count=n}async read({readback:A}){const n=this.renderer;if(!n)throw new Error("No renderer");if(!this.target)throw new Error("No target");const t=Math.ceil(this.count/$)*$;if(A.byteLength<4*t)throw new Error(`Readback buffer too small: ${A.byteLength} < ${4*t}`);const e=new Uint8Array(A instanceof ArrayBuffer?A:A.buffer),s=$*W;let a=0;const i=[];for(;a<this.count;){const A=Math.floor(a/s),t=A*s,r=Math.min(W,Math.ceil((this.count-t)/$));n.setRenderTarget(this.target,A);const o=$*r*4,g=e.subarray(4*t,4*t+o),c=null==n?void 0:n.readRenderTargetPixelsAsync(this.target,0,0,$,r,g);i.push(c),a+=$*r}return Promise.all(i).then((()=>A))}render({reader:A,count:n,renderer:t}){if(this.renderer=t||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(n);const{program:e,material:s}=this.prepareProgramMaterial(A);e.update();const a=this.saveRenderState(this.renderer);this.process({count:n,material:s}),this.resetRenderState(this.renderer,a)}async readback({readback:A}){if(!this.renderer)throw new Error("No renderer");const n=this.saveRenderState(this.renderer),t=this.read({readback:A});return this.resetRenderState(this.renderer,n),t}async renderReadback({reader:A,count:n,renderer:t,readback:e}){if(this.renderer=t||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(n);const{program:s,material:a}=this.prepareProgramMaterial(A);s.update();const i=this.saveRenderState(this.renderer);this.process({count:n,material:a});const r=this.read({readback:e});return this.resetRenderState(this.renderer,i),r}getTexture(){var A;return null==(A=this.target)?void 0:A.texture}};yi.programTemplate=null,yi.readbackProgram=new Map,yi.geometry=new e.PlaneGeometry(2,2),yi.mesh=new e.Mesh(yi.geometry,new e.RawShaderMaterial({visible:!1})),yi.scene=(new e.Scene).add(yi.mesh),yi.camera=new e.Camera;let fi=yi;const mi=class A{constructor(n={}){this.capacity=0,this.count=0,this.array=null,this.readback=null,this.source=null,this.needsUpdate=!0,this.dyno=new In({key:"rgbaArray",type:Di,globals:()=>[xi],value:{texture:A.getEmpty(),count:0},update:n=>{var t;return n.texture=(null==(t=this.readback)?void 0:t.getTexture())??this.source??A.getEmpty(),n.count=this.count,n}}),n.array?(this.array=n.array,this.capacity=Math.floor(this.array.length/4),this.capacity=Math.floor(this.capacity/$)*$,this.count=Math.min(this.capacity,n.count??Number.POSITIVE_INFINITY)):(this.capacity=n.capacity??0,this.count=0)}dispose(){this.readback&&(this.readback.dispose(),this.readback=null),this.source&&(this.source.dispose(),this.source=null)}ensureCapacity(A){var n;if(!this.array||A>((null==(n=this.array)?void 0:n.length)??0)/4){this.capacity=Qt(A).maxSplats;const n=new Uint8Array(4*this.capacity);this.array&&n.set(this.array),this.array=n}return this.array}getTexture(){var n;let t=null==(n=this.readback)?void 0:n.getTexture();return(this.source||this.array)&&(t=this.maybeUpdateSource()),t??A.getEmpty()}maybeUpdateSource(){if(!this.array)throw new Error("No array");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:n,depth:t}=this.source.image;this.capacity!==A*n*t&&(this.source.dispose(),this.source=null)}if(this.source)this.array.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.array.buffer));else{const{width:A,height:n,depth:t}=Qt(this.capacity);this.source=new e.DataArrayTexture(this.array,A,n,t),this.source.format=e.RGBAFormat,this.source.type=e.UnsignedByteType,this.source.internalFormat="RGBA8",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}render({reader:A,count:n,renderer:t}){this.readback||(this.readback=new fi({renderer:t})),this.readback.render({reader:A,count:n,renderer:t}),this.capacity=this.readback.capacity,this.count=this.readback.count}fromPackedSplats({packedSplats:n,base:t,count:e,renderer:s}){const{dynoSplats:a,dynoBase:i,dynoCount:r,reader:o}=A.makeDynos();return a.packedSplats=n,i.value=t,r.value=e,this.render({reader:o,count:e,renderer:s}),this}async read(){if(!this.readback)throw new Error("No readback");(!this.array||this.array.length<4*this.count)&&(this.array=new Uint8Array(4*this.capacity));return(await this.readback.readback({readback:this.array})).subarray(0,4*this.count)}static getEmpty(){if(!A.emptySource){const n=new Uint8Array(4);A.emptySource=new e.DataArrayTexture(n,1,1,1),A.emptySource.format=e.RGBAFormat,A.emptySource.type=e.UnsignedByteType,A.emptySource.internalFormat="RGBA8",A.emptySource.needsUpdate=!0}return A.emptySource}static makeDynos(){if(!A.dynos){const n=new mr,t=new Qn({value:0}),e=new Qn({value:0}),s=FA({index:"int"},{rgba8:"vec4"},(({index:A})=>{if(!A)throw new Error("index is undefined");A=le(A,t);const s=qA(n,A,t,e);return{rgba8:zA(s).outputs.rgba}}));A.dynos={dynoSplats:n,dynoBase:t,dynoCount:e,reader:s}}return A.dynos}};mi.emptySource=null,mi.dynos=null;let wi=mi;const Di={type:"RgbaArray"},xi=UA("\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n");var Si=(A=>(A.ALL="all",A.PLANE="plane",A.SPHERE="sphere",A.BOX="box",A.ELLIPSOID="ellipsoid",A.CYLINDER="cylinder",A.CAPSULE="capsule",A.INFINITE_CONE="infinite_cone",A))(Si||{});function bi(A){switch(A){case"all":return 0;case"plane":return 1;case"sphere":return 2;case"box":return 3;case"ellipsoid":return 4;case"cylinder":return 5;case"capsule":return 6;case"infinite_cone":return 7;default:throw new Error(`Unknown SDF type: ${A}`)}}var ki=(A=>(A.MULTIPLY="multiply",A.SET_RGB="set_rgb",A.ADD_RGBA="add_rgba",A))(ki||{});function Mi(A){switch(A){case"multiply":return 0;case"set_rgb":return 1;case"add_rgba":return 2;default:throw new Error(`Unknown blend mode: ${A}`)}}class vi extends e.Object3D{constructor(A={}){super();const{type:n,invert:t,opacity:s,color:a,displace:i,radius:r}=A;this.type=n??"sphere",this.invert=t??!1,this.opacity=s??1,this.color=a??new e.Color(1,1,1),this.displace=i??new e.Vector3(0,0,0),this.radius=r??0}}const Fi=class A extends e.Object3D{constructor(n={}){const{name:t,rgbaBlendMode:e="multiply",sdfSmooth:s=0,softEdge:a=0,invert:i=!1,sdfs:r=null}=n;super(),this.rgbaBlendMode=e,this.sdfSmooth=s,this.softEdge=a,this.invert=i,this.sdfs=r,this.ordering=A.nextOrdering++,this.name=t??`Edit ${this.ordering}`}addSdf(A){null==this.sdfs&&(this.sdfs=[]),this.sdfs.includes(A)||this.sdfs.push(A)}removeSdf(A){null!=this.sdfs&&(this.sdfs=this.sdfs.filter((n=>n!==A)))}};Fi.nextOrdering=1;let Ni=Fi;class Ri{constructor({maxSdfs:A,maxEdits:n}){this.maxSdfs=Math.max(16,A??0),this.numSdfs=0,this.sdfData=new Uint32Array(8*this.maxSdfs*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs),this.dynoSdfArray=new In({key:"sdfArray",type:Gi,globals:()=>[Ui],value:{numSdfs:0,sdfTexture:this.sdfTexture},update:A=>(A.numSdfs=this.numSdfs,A.sdfTexture=this.sdfTexture,A)}),this.maxEdits=Math.max(16,n??0),this.numEdits=0,this.editData=new Uint32Array(4*this.maxEdits),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoNumEdits=new Qn({value:0}),this.dynoEdits=this.newEdits(this.editData,this.maxEdits)}newSdfTexture(A,n){const t=new e.DataTexture(A,8,n,e.RGBAIntegerFormat,e.UnsignedIntType);return t.internalFormat="RGBA32UI",t.needsUpdate=!0,t}newEdits(A,n){return new In({key:"edits",type:"uvec4",count:n,globals:()=>[Li],value:A})}ensureCapacity({maxSdfs:A,maxEdits:n}){let t=!1;return A>this.sdfTexture.image.height&&(this.sdfTexture.dispose(),this.maxSdfs=Math.max(2*this.maxSdfs,A),this.sdfData=new Uint32Array(8*this.maxSdfs*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs)),n>(this.dynoEdits.count??0)&&(this.maxEdits=Math.max(2*this.maxEdits,n),this.editData=new Uint32Array(4*this.maxEdits),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoEdits=this.newEdits(this.editData,this.maxEdits),t=!0),t}updateEditData(A,n){const t=this.editData[A]!==n;return this.editData[A]=n,t}updateEditFloatData(A,n){Ti[0]=n;const t=this.editFloatData[A]!==Ti[0];return t&&(this.editFloatData[A]=Ti[0]),t}encodeEdit(A,{sdfFirst:n,sdfCount:t,invert:e,rgbaBlendMode:s,softEdge:a,sdfSmooth:i}){const r=4*A;let o=!1;return o=this.updateEditData(r+0,s|(e?256:0))||o,o=this.updateEditData(r+1,n|t<<16)||o,o=this.updateEditFloatData(r+2,a)||o,o=this.updateEditFloatData(r+3,i)||o,o}updateSdfData(A,n){const t=this.sdfData[A]!==n;return this.sdfData[A]=n,t}updateSdfFloatData(A,n){Ti[0]=n;const t=this.sdfFloatData[A]!==Ti[0];return t&&(this.sdfFloatData[A]=Ti[0]),t}encodeSdf(A,{sdfType:n,invert:t,center:e,quaternion:s,scale:a,sizes:i},r){const o=32*A,g=n|(t?256:0);let c=!1;c=this.updateSdfFloatData(o+0,(null==e?void 0:e.x)??0)||c,c=this.updateSdfFloatData(o+1,(null==e?void 0:e.y)??0)||c,c=this.updateSdfFloatData(o+2,(null==e?void 0:e.z)??0)||c,c=this.updateSdfData(o+3,g)||c,c=this.updateSdfFloatData(o+4,(null==s?void 0:s.x)??0)||c,c=this.updateSdfFloatData(o+5,(null==s?void 0:s.y)??0)||c,c=this.updateSdfFloatData(o+6,(null==s?void 0:s.z)??0)||c,c=this.updateSdfFloatData(o+7,(null==s?void 0:s.w)??0)||c,c=this.updateSdfFloatData(o+8,(null==a?void 0:a.x)??0)||c,c=this.updateSdfFloatData(o+9,(null==a?void 0:a.y)??0)||c,c=this.updateSdfFloatData(o+10,(null==a?void 0:a.z)??0)||c,c=this.updateSdfData(o+11,0)||c,c=this.updateSdfFloatData(o+12,(null==i?void 0:i.x)??0)||c,c=this.updateSdfFloatData(o+13,(null==i?void 0:i.y)??0)||c,c=this.updateSdfFloatData(o+14,(null==i?void 0:i.z)??0)||c,c=this.updateSdfFloatData(o+15,(null==i?void 0:i.w)??0)||c;const I=Math.min(4,r.length);for(let A=0;A<I;++A){const n=o+16+4*A;c=this.updateSdfFloatData(n+0,r[A].x)||c,c=this.updateSdfFloatData(n+1,r[A].y)||c,c=this.updateSdfFloatData(n+2,r[A].z)||c,c=this.updateSdfFloatData(n+3,r[A].w)||c}return c}update(A){const n=A.reduce(((A,{sdfs:n})=>A+n.length),0),t=this.ensureCapacity({maxEdits:A.length,maxSdfs:n}),s=[new e.Vector4,new e.Vector4],a=new e.Vector3,i=new e.Quaternion,r=new e.Vector3,o=new e.Vector4;let g=0,c=t;A.length!==this.dynoNumEdits.value&&(this.dynoNumEdits.value=A.length,this.numEdits=A.length,c=!0);for(const[n,{edit:t,sdfs:e}]of A.entries()){c=this.encodeEdit(n,{sdfFirst:g,sdfCount:e.length,invert:t.invert,rgbaBlendMode:Mi(t.rgbaBlendMode),softEdge:t.softEdge,sdfSmooth:t.sdfSmooth})||c;let A=!1;for(const n of e){o.set(n.scale.x,n.scale.y,n.scale.z,n.radius),n.scale.setScalar(1),n.updateMatrixWorld();n.matrixWorld.clone().invert().decompose(a,i,r),n.scale.set(o.x,o.y,o.z),n.updateMatrixWorld(),s[0].set(n.color.r,n.color.g,n.color.b,n.opacity),s[1].set(n.displace.x,n.displace.y,n.displace.z,1),A=this.encodeSdf(g,{sdfType:bi(n.type),invert:n.invert,center:a,quaternion:i,scale:r,sizes:o},s)||A,g+=1}this.numSdfs=g,A&&(this.sdfTexture.needsUpdate=!0),c||(c=A)}return{updated:c,dynoUpdated:t}}modify(A){return function(A,n,t,e){const s=new MA({inTypes:{gsplat:YA,sdfArray:Gi,numEdits:"int",rgbaDisplaceEdits:"uvec4"},outTypes:{gsplat:YA},globals:()=>[Ui,Li],inputs:{gsplat:A,sdfArray:n,numEdits:t,rgbaDisplaceEdits:e},statements:({inputs:A,outputs:n})=>{const{sdfArray:t,numEdits:e,rgbaDisplaceEdits:s}=A,{gsplat:a}=n;return GA(`\n        ${a} = ${A.gsplat};\n        if (isGsplatActive(${a}.flags)) {\n          for (int editIndex = 0; editIndex < ${e}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${s}[editIndex], ${t}.sdfTexture, ${t}.numSdfs,\n              ${a}.center, ${a}.rgba\n            );\n          }\n        }\n      `)}});return s.outputs.gsplat}(A,this.dynoSdfArray,this.dynoNumEdits,this.dynoEdits)}}const Gi={type:"SdfArray"},Ui=UA("\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n"),Li=UA("\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n");const Ti=new Float32Array(1);class _i{constructor(A){this.modifier=A,this.cache=new Map}apply(A){let n=this.cache.get(A);return n||(n=FA({index:"int"},{gsplat:YA},(({index:n})=>{const{gsplat:t}=A.apply({index:n});return this.modifier.apply({gsplat:t})})),this.cache.set(A,n)),n}}class Yi{constructor(){this.scale=new un({value:Number.NEGATIVE_INFINITY}),this.rotate=new Sn({value:new e.Quaternion(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}),this.translate=new mn({value:new e.Vector3(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)})}apply(A){return Oa(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}applyDir(A){return Va(A,{rotate:this.rotate})}applyGsplat(A){return OA(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}updateFromMatrix(A){const n=new e.Vector3,t=new e.Quaternion,s=new e.Vector3;A.decompose(s,t,n);const a=(n.x+n.y+n.z)/3;let i=!1;return a!==this.scale.value&&(this.scale.value=a,i=!0),s.equals(this.translate.value)||(this.translate.value.copy(s),i=!0),t.equals(this.rotate.value)||(this.rotate.value.copy(t),i=!0),i}update(A){return A.updateMatrixWorld(),this.updateFromMatrix(A.matrixWorld)}}class Ji extends e.Object3D{constructor({numSplats:A,generator:n,construct:t,update:e}){if(super(),this.numSplats=A??0,this.generator=n,this.frameUpdate=e,this.version=0,t){const A=t(this);Object.assign(this,A)}}updateVersion(){this.version+=1}set needsUpdate(A){A&&this.updateVersion()}}const Hi=class A extends Ji{constructor(A={}){const n={transform:new Yi,viewToWorld:new Yi,worldToView:new Yi,viewToObject:new Yi,recolor:new Sn({value:new e.Vector4(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)}),time:new un({value:0}),deltaTime:new un({value:0})};if(super({update:({time:A,deltaTime:n,viewToWorld:t,globalEdits:e})=>this.update({time:A,deltaTime:n,viewToWorld:t,globalEdits:e})}),this.isInitialized=!1,this.recolor=new e.Color(1,1,1),this.opacity=1,this.enableViewToObject=!1,this.enableViewToWorld=!1,this.enableWorldToView=!1,this.skinning=null,this.edits=null,this.rgbaDisplaceEdits=null,this.splatRgba=null,this.maxSh=3,this.packedSplats=A.packedSplats??new fr,this.numSplats=this.packedSplats.numSplats,this.editable=A.editable??!0,this.onFrame=A.onFrame,this.context=n,this.objectModifier=A.objectModifier,this.worldModifier=A.worldModifier,this.updateGenerator(),A.url||A.fileBytes||A.constructSplats||A.packedSplats&&!A.packedSplats.isInitialized)this.initialized=this.asyncInitialize(A).then((async()=>{if(this.updateGenerator(),this.isInitialized=!0,A.onLoad){const n=A.onLoad(this);n instanceof Promise&&await n}return this}));else if(this.isInitialized=!0,this.initialized=Promise.resolve(this),A.onLoad){const n=A.onLoad(this);n instanceof Promise&&(this.initialized=n.then((()=>this)))}}async asyncInitialize(A){const{url:n,fileBytes:t,fileType:e,fileName:s,maxSplats:a,constructSplats:i}=A;if(n||t||i){const A={url:n,fileBytes:t,fileType:e,fileName:s,maxSplats:a,construct:i};this.packedSplats.reinitialize(A)}this.packedSplats&&(await this.packedSplats.initialized,this.numSplats=this.packedSplats.numSplats,this.updateGenerator())}static async staticInitialize(){await O(),A.isStaticInitialized=!0}pushSplat(A,n,t,e,s){this.packedSplats.pushSplat(A,n,t,e,s)}forEachSplat(A){this.packedSplats.forEachSplat(A)}dispose(){this.packedSplats.dispose()}constructGenerator(A){const{transform:n,viewToObject:t,recolor:e}=A,s=FA({index:"int"},{gsplat:YA},(({index:A})=>{if(!A)throw new Error("index is undefined");let s=HA(this.packedSplats.dyno,A);if(this.maxSh>=1){const{sh1Texture:A,sh2Texture:n,sh3Texture:e}=this.ensureShTextures();if(A){const a=t.translate,{center:i}=zA(s).outputs,r=ea(Be(i,a));let o=function(A,n,t){return NA({inTypes:{gsplat:YA,sh1:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:A,sh1:n,viewDir:t},globals:()=>[VA,zi],statements:({inputs:A,outputs:n})=>GA(`\n        if (isGsplatActive(${A.gsplat}.flags)) {\n          ${n.rgb} = evaluateSH1(${A.gsplat}, ${A.sh1}, ${A.viewDir});\n        } else {\n          ${n.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(s,A,r);this.maxSh>=2&&n&&(o=le(o,function(A,n,t){return NA({inTypes:{gsplat:YA,sh2:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:A,sh2:n,viewDir:t},globals:()=>[VA,Ki],statements:({inputs:A,outputs:n})=>GA(`\n        if (isGsplatActive(${A.gsplat}.flags)) {\n          ${n.rgb} = evaluateSH2(${A.gsplat}, ${A.sh2}, ${A.viewDir});\n        } else {\n          ${n.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(s,n,r))),this.maxSh>=3&&e&&(o=le(o,function(A,n,t){return NA({inTypes:{gsplat:YA,sh3:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:A,sh3:n,viewDir:t},globals:()=>[VA,Pi],statements:({inputs:A,outputs:n})=>GA(`\n        if (isGsplatActive(${A.gsplat}.flags)) {\n          ${n.rgb} = evaluateSH3(${A.gsplat}, ${A.sh3}, ${A.viewDir});\n        } else {\n          ${n.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(s,e,r)));let{rgba:g}=zA(s).outputs;g=le(g,ia(o,xA("float",0))),s=KA({gsplat:s,rgba:g})}}if(this.splatRgba){const n=function(A,n){return new MA({inTypes:{rgba:Di,index:"int"},outTypes:{rgba:"vec4"},inputs:{rgba:A,index:n},globals:()=>[xi],statements:({inputs:A,outputs:n})=>GA(`\n        if ((index >= 0) && (index < ${A.rgba}.count)) {\n          ${n.rgba} = texelFetch(${A.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${n.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)}).outputs.rgba}(this.splatRgba.dyno,A);s=KA({gsplat:s,rgba:n})}this.skinning&&(s=this.skinning.modify(s)),this.objectModifier&&(s=this.objectModifier.apply({gsplat:s}).gsplat),s=n.applyGsplat(s);const a=Qe(e,zA(s).outputs.rgba);return s=KA({gsplat:s,rgba:a}),this.rgbaDisplaceEdits&&(s=this.rgbaDisplaceEdits.modify(s)),this.worldModifier&&(s=this.worldModifier.apply({gsplat:s}).gsplat),{gsplat:s}}));this.generator=s}updateGenerator(){this.constructGenerator(this.context)}update({time:n,viewToWorld:t,deltaTime:s,globalEdits:a}){var i;this.numSplats=this.packedSplats.numSplats,this.context.time.value=n,this.context.deltaTime.value=s,A.dynoTime.value=n;const{transform:r,viewToObject:o,recolor:g}=this.context;let c=r.update(this);this.context.viewToWorld.updateFromMatrix(t)&&this.enableViewToWorld&&(c=!0);const I=t.clone().invert();this.context.worldToView.updateFromMatrix(I)&&this.enableWorldToView&&(c=!0);const l=(new e.Matrix4).compose(r.translate.value,r.rotate.value,(new e.Vector3).setScalar(r.scale.value)).invert().multiply(t);o.updateFromMatrix(l)&&(this.enableViewToObject||this.packedSplats.extra.sh1)&&(c=!0);const B=new e.Vector4(this.recolor.r,this.recolor.g,this.recolor.b,this.opacity);B.equals(g.value)||(g.value.copy(B),c=!0);const Q=this.editable?(this.edits??[]).concat(a):[];this.editable&&!this.edits&&this.traverseVisible((A=>{A instanceof Ni&&Q.push(A)})),Q.sort(((A,n)=>A.ordering-n.ordering));const u=Q.map((A=>{if(null!=A.sdfs)return{edit:A,sdfs:A.sdfs};const n=[];return A.traverseVisible((A=>{A instanceof vi&&n.push(A)})),{edit:A,sdfs:n}}));if(u.length>0&&!this.rgbaDisplaceEdits){const A=u.length,n=u.reduce(((A,n)=>A+n.sdfs.length),0);this.rgbaDisplaceEdits=new Ri({maxEdits:A,maxSdfs:n}),this.updateGenerator()}if(this.rgbaDisplaceEdits){const A=this.rgbaDisplaceEdits.update(u);c||(c=A.updated),A.dynoUpdated&&this.updateGenerator()}c&&this.updateVersion(),null==(i=this.onFrame)||i.call(this,{mesh:this,time:n,deltaTime:s})}raycast(A,n){if(!this.packedSplats.packedArray||!this.packedSplats.numSplats)return;const{near:t,far:s,ray:a}=A,i=this.matrixWorld.clone().invert(),r=(new e.Matrix3).setFromMatrix4(i),o=a.origin.clone().applyMatrix4(i),g=a.direction.clone().applyMatrix3(r),c=new e.Vector3;i.decompose(new e.Vector3,new e.Quaternion,c),c.x,c.y,c.z;const I=function(A,n,t,e,s,a,i,r,o,g,c){return q.raycast_splats(A,n,t,e,s,a,i,r,o,g,c)}(o.x,o.y,o.z,g.x,g.y,g.z,t,s,this.packedSplats.numSplats,this.packedSplats.packedArray,!0);for(const A of I){const t=a.direction.clone().multiplyScalar(A).add(a.origin);n.push({distance:A,point:t,object:this})}}ensureShTextures(){if(!this.packedSplats.extra.sh1)return{};let A=this.packedSplats.extra.sh1Texture;if(!A){let n=this.packedSplats.extra.sh1;const{width:t,height:s,depth:a,maxSplats:i}=Qt(n.length/2);if(n.length<2*i){const A=new Uint32Array(2*i);A.set(n),this.packedSplats.extra.sh1=A,n=A}const r=new e.DataArrayTexture(n,t,s,a);r.format=e.RGIntegerFormat,r.type=e.UnsignedIntType,r.internalFormat="RG32UI",r.needsUpdate=!0,A=new qn({value:r,key:"sh1"}),this.packedSplats.extra.sh1Texture=A}if(!this.packedSplats.extra.sh2)return{sh1Texture:A};let n=this.packedSplats.extra.sh2Texture;if(!n){let A=this.packedSplats.extra.sh2;const{width:t,height:s,depth:a,maxSplats:i}=Qt(A.length/4);if(A.length<4*i){const n=new Uint32Array(4*i);n.set(A),this.packedSplats.extra.sh2=n,A=n}const r=new e.DataArrayTexture(A,t,s,a);r.format=e.RGBAIntegerFormat,r.type=e.UnsignedIntType,r.internalFormat="RGBA32UI",r.needsUpdate=!0,n=new qn({value:r,key:"sh2"}),this.packedSplats.extra.sh2Texture=n}if(!this.packedSplats.extra.sh3)return{sh1Texture:A,sh2Texture:n};let t=this.packedSplats.extra.sh3Texture;if(!t){let A=this.packedSplats.extra.sh3;const{width:n,height:s,depth:a,maxSplats:i}=Qt(A.length/4);if(A.length<4*i){const n=new Uint32Array(4*i);n.set(A),this.packedSplats.extra.sh3=n,A=n}const r=new e.DataArrayTexture(A,n,s,a);r.format=e.RGBAIntegerFormat,r.type=e.UnsignedIntType,r.internalFormat="RGBA32UI",r.needsUpdate=!0,t=new qn({value:r,key:"sh3"}),this.packedSplats.extra.sh3Texture=t}return{sh1Texture:A,sh2Texture:n,sh3Texture:t}}};Hi.staticInitialized=Hi.staticInitialize(),Hi.isStaticInitialized=!1,Hi.dynoTime=new un({value:0});let qi=Hi;const zi=UA("\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n"),Ki=UA("\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n"),Pi=UA("\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n");const Oi=class A{constructor({fileBytes:A}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A}async parseHeader(){const A=new ReadableStream({start:A=>{A.enqueue(this.fileBytes.slice(0,65536)),A.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const n="end_header\n";for(;;){const{value:t,done:e}=await A.read();if(e)throw new Error("Failed to read header");this.header+=t;const s=this.header.indexOf(n);if(s>=0){this.header=this.header.slice(0,s+11);break}}const t=(new TextEncoder).encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,t),this.elements={};let e=null;this.comments=[],this.header.trim().split("\n").forEach(((A,n)=>{const t=A.trim();if(0===n){if("ply"!==t)throw new Error("Invalid PLY header");return}if(0===t.length)return;const s=t.split(" ");switch(s[0]){case"format":if("binary_little_endian"===s[1])this.littleEndian=!0;else{if("binary_big_endian"!==s[1])throw new Error(`Unsupported PLY format: ${s[1]}`);this.littleEndian=!1}if("1.0"!==s[2])throw new Error(`Unsupported PLY version: ${s[2]}`);break;case"end_header":break;case"comment":this.comments.push(t.slice(8));break;case"element":{const A=s[1];e={name:A,count:Number.parseInt(s[2]),properties:{}},this.elements[A]=e;break}case"property":if(null==e)throw new Error("Property must be inside an element");"list"===s[1]?e.properties[s[4]]={isList:!0,type:s[3],countType:s[2]}:e.properties[s[2]]={isList:!1,type:s[1]}}})),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(A){let n=0;const t=this.data;if(null==t)throw new Error("No data to parse");for(const e in this.elements){const s=this.elements[e],{count:a,properties:i}=s,r={},o=[];for(const[A,e]of Object.entries(i))e.isList?(r[A]=[],o.push((()=>{const s=r[A];s.length=Zi[e.countType](t,n,this.littleEndian),n+=Wi[e.countType];for(let A=0;A<s.length;A++)s[A]=Zi[e.type](t,n,this.littleEndian),n+=Wi[e.type]}))):(r[A]=0,o.push((()=>{r[A]=Zi[e.type](t,n,this.littleEndian),n+=Wi[e.type]})));const g=A(s)??(()=>{});for(let A=0;A<a;A++){for(const A of o)A();g(A,r)}}}parseSplats(n,t){if(null==this.elements.vertex)throw new Error("No vertex element found");let e=!1;const s=[];let a,i,r,o=0,g=[],c=[],I=[];function l(){const A=nr[o];g=new Array(3).fill(null).flatMap(((n,t)=>[0,1,2].map(((n,e)=>`f_rest_${t+e*A/3}`)))),c=new Array(5).fill(null).flatMap(((n,t)=>[0,1,2].map(((n,e)=>`f_rest_${3+t+e*A/3}`)))),I=new Array(7).fill(null).flatMap(((n,t)=>[0,1,2].map(((n,e)=>`f_rest_${8+t+e*A/3}`)))),a=o>=1?new Float32Array(9):void 0,i=o>=2?new Float32Array(15):void 0,r=o>=3?new Float32Array(21):void 0}function B(A,n){if(!a)throw new Error("Missing sh1");for(const[A,t]of g.entries())a[A]=8*n[t]/255-4;if(i)for(const[A,t]of c.entries())i[A]=8*n[t]/255-4;if(r)for(const[A,t]of I.entries())r[A]=8*n[t]/255-4;null==t||t(A,a,i,r)}this.parseData((Q=>{if("chunk"===Q.name)return function(A){const{min_x:n,min_y:t,min_z:a,max_x:i,max_y:r,max_z:o,min_scale_x:g,min_scale_y:c,min_scale_z:I,max_scale_x:l,max_scale_y:B,max_scale_z:Q}=A.properties;if(!(n&&t&&a&&i&&r&&o&&g&&c&&I&&l&&B&&Q))throw new Error("Missing PLY chunk properties");return e=!0,(A,n)=>{const{min_x:t,min_y:e,min_z:a,max_x:i,max_y:r,max_z:o,min_scale_x:g,min_scale_y:c,min_scale_z:I,max_scale_x:l,max_scale_y:B,max_scale_z:Q,min_r:u,min_g:C,min_b:E,max_r:h,max_g:p,max_b:d}=n;s.push({min_x:t,min_y:e,min_z:a,max_x:i,max_y:r,max_z:o,min_scale_x:g,min_scale_y:c,min_scale_z:I,max_scale_x:l,max_scale_y:B,max_scale_z:Q,min_r:u,min_g:C,min_b:E,max_r:h,max_g:p,max_b:d})}}(Q);if(e)return function(A){if(t&&"sh"===A.name)return o=tr(A.properties),l(),B;if("vertex"!==A.name)return null;const{packed_position:e,packed_rotation:a,packed_scale:i,packed_color:r}=A.properties;if(!(e&&a&&i&&r))throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const g=Math.sqrt(2);return(A,t)=>{const e=s[A>>>8];if(null==e)throw new Error("Missing PLY chunk");const{min_x:a,min_y:i,min_z:r,max_x:o,max_y:c,max_z:I,min_scale_x:l,min_scale_y:B,min_scale_z:Q,max_scale_x:u,max_scale_y:C,max_scale_z:E,min_r:h,min_g:p,min_b:d,max_r:y,max_g:f,max_b:m}=e,{packed_position:w,packed_rotation:D,packed_scale:x,packed_color:S}=t,b=(w>>>21&2047)/2047*(o-a)+a,k=(w>>>11&1023)/1023*(c-i)+i,M=(2047&w)/2047*(I-r)+r,v=((D>>>20&1023)/1023-.5)*g,F=((D>>>10&1023)/1023-.5)*g,N=((1023&D)/1023-.5)*g,R=Math.sqrt(Math.max(0,1-v*v-F*F-N*N)),G=D>>>30,U=0===G?v:1===G?R:F,L=G<=1?F:2===G?R:N,T=G<=2?N:R,_=0===G?R:v,Y=Math.exp((x>>>21&2047)/2047*(u-l)+l),J=Math.exp((x>>>11&1023)/1023*(C-B)+B),H=Math.exp((2047&x)/2047*(E-Q)+Q);n(A,b,k,M,Y,J,H,U,L,T,_,(255&S)/255,(S>>>24&255)/255*((y??1)-(h??0))+(h??0),(S>>>16&255)/255*((f??1)-(p??0))+(p??0),(S>>>8&255)/255*((m??1)-(d??0))+(d??0))}}(Q);if("vertex"!==Q.name)return null;const{x:u,y:C,z:E,scale_0:h,scale_1:p,scale_2:d,rot_0:y,rot_1:f,rot_2:m,rot_3:w,opacity:D,f_dc_0:x,f_dc_1:S,f_dc_2:b,red:k,green:M,blue:v,alpha:F}=Q.properties;if(!u||!C||!E)throw new Error("Missing PLY properties: x, y, z");const N=h&&p&&d,R=y&&f&&m&&w,G=null!=F?Xi[F.type]:1,U=null!=k?Xi[k.type]:1,L=null!=M?Xi[M.type]:1,T=null!=v?Xi[v.type]:1;return o=tr(Q.properties),l(),(e,s)=>{const o=N?Math.exp(s.scale_0):A.defaultPointScale,l=N?Math.exp(s.scale_1):A.defaultPointScale,B=N?Math.exp(s.scale_2):A.defaultPointScale,Q=R?s.rot_1:0,u=R?s.rot_2:0,C=R?s.rot_3:0,E=R?s.rot_0:1,h=null!=D?1/(1+Math.exp(-s.opacity)):null!=F?s.alpha/G:1,p=null!=x?s.f_dc_0*ji+.5:null!=k?s.red/U:1,d=null!=S?s.f_dc_1*ji+.5:null!=M?s.green/L:1,y=null!=b?s.f_dc_2*ji+.5:null!=v?s.blue/T:1;if(n(e,s.x,s.y,s.z,o,l,B,Q,u,C,E,h,p,d,y),t&&a){if(a)for(const[A,n]of g.entries())a[A]=s[n];if(i)for(const[A,n]of c.entries())i[A]=s[n];if(r)for(const[A,n]of I.entries())r[A]=s[n];t(e,a,i,r)}}}))}injectRgba(A){let n=0;const t=this.data;if(null==t)throw new Error("No parsed data");if(A.length!==4*this.numSplats)throw new Error("Invalid RGBA array length");for(const e in this.elements){const s=this.elements[e],{count:a,properties:i}=s,r=[];let o=0;const g="vertex"===e;if(g)for(const A of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!i[A]||"float"!==i[A].type)throw new Error(`Can't injectRgba due to property: ${A}`);for(const[e,s]of Object.entries(i))if(s.isList)r.push((()=>{const A=Zi[s.countType](t,n,this.littleEndian);n+=Wi[s.countType],n+=A*Wi[s.type]}));else{if(g)if("f_dc_0"===e||"f_dc_1"===e||"f_dc_2"===e){const a=Number.parseInt(e.slice(5));r.push((()=>{const e=(A[o+a]/255-.5)/ji;$i[s.type](t,n,this.littleEndian,e)}))}else"opacity"===e&&r.push((()=>{const e=Math.max(-100,Math.min(100,-Math.log(1/(A[o+3]/255)-1)));$i[s.type](t,n,this.littleEndian,e)}));r.push((()=>{n+=Wi[s.type]}))}for(let A=0;A<a;A++){for(const A of r)A();g&&(o+=4)}}}};Oi.defaultPointScale=.001;let Vi=Oi;const ji=.28209479177387814,Zi={char:(A,n,t)=>A.getInt8(n),uchar:(A,n,t)=>A.getUint8(n),short:(A,n,t)=>A.getInt16(n,t),ushort:(A,n,t)=>A.getUint16(n,t),int:(A,n,t)=>A.getInt32(n,t),uint:(A,n,t)=>A.getUint32(n,t),float:(A,n,t)=>A.getFloat32(n,t),double:(A,n,t)=>A.getFloat64(n,t)},$i={char:(A,n,t,e)=>{A.setInt8(n,e)},uchar:(A,n,t,e)=>{A.setUint8(n,e)},short:(A,n,t,e)=>{A.setInt16(n,e,t)},ushort:(A,n,t,e)=>{A.setUint16(n,e,t)},int:(A,n,t,e)=>{A.setInt32(n,e,t)},uint:(A,n,t,e)=>{A.setUint32(n,e,t)},float:(A,n,t,e)=>{A.setFloat32(n,e,t)},double:(A,n,t,e)=>{A.setFloat64(n,e,t)}},Wi={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},Xi={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},Ar={0:0,9:1,24:2,45:3},nr={0:0,1:9,2:24,3:45};function tr(A){let n=0;for(;A[`f_rest_${n}`];)n+=1;const t=Ar[n];if(null==t)throw new Error(`Unsupported number of SH coefficients: ${n}`);return t}const er='(function() {\n  "use strict";\n  let wasm;\n  const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {\n    throw Error("TextDecoder not available");\n  } };\n  if (typeof TextDecoder !== "undefined") {\n    cachedTextDecoder.decode();\n  }\n  let cachedUint8ArrayMemory0 = null;\n  function getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n  }\n  function getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n  }\n  function sort_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  function raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid) {\n    const ret = wasm.raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid);\n    return ret;\n  }\n  async function __wbg_load(module, imports) {\n    if (typeof Response === "function" && module instanceof Response) {\n      if (typeof WebAssembly.instantiateStreaming === "function") {\n        try {\n          return await WebAssembly.instantiateStreaming(module, imports);\n        } catch (e) {\n          if (module.headers.get("Content-Type") != "application/wasm") {\n            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n", e);\n          } else {\n            throw e;\n          }\n        }\n      }\n      const bytes = await module.arrayBuffer();\n      return await WebAssembly.instantiate(bytes, imports);\n    } else {\n      const instance = await WebAssembly.instantiate(module, imports);\n      if (instance instanceof WebAssembly.Instance) {\n        return { instance, module };\n      } else {\n        return instance;\n      }\n    }\n  }\n  function __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n      const ret = arg0.buffer;\n      return ret;\n    };\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\n      const ret = new Uint16Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n      const ret = new Uint32Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\n      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n      const ret = new Float32Array(arg0 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n      const table = wasm.__wbindgen_export_0;\n      const offset = table.grow(4);\n      table.set(0, void 0);\n      table.set(offset + 0, void 0);\n      table.set(offset + 1, null);\n      table.set(offset + 2, true);\n      table.set(offset + 3, false);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n      const ret = wasm.memory;\n      return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n      throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    return imports;\n  }\n  function __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n  }\n  async function __wbg_init(module_or_path) {\n    if (wasm !== void 0) return wasm;\n    if (typeof module_or_path !== "undefined") {\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n        ({ module_or_path } = module_or_path);\n      } else {\n        console.warn("using deprecated parameters for the initialization function; pass a single object instead");\n      }\n    }\n    if (typeof module_or_path === "undefined") {\n      module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIM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AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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", self.location.href);\n    }\n    const imports = __wbg_get_imports();\n    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {\n      module_or_path = fetch(module_or_path);\n    }\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n    return __wbg_finalize_init(instance, module);\n  }\n  var ch2 = {};\n  var wk = function(c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n      c + \';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})\'\n    ], { type: "text/javascript" }))));\n    w.onmessage = function(e) {\n      var d = e.data, ed = d.$e$;\n      if (ed) {\n        var err2 = new Error(ed[0]);\n        err2["code"] = ed[1];\n        err2.stack = ed[2];\n        cb(err2, null);\n      } else\n        cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n  };\n  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n  var fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */\n    0,\n    0,\n    /* impossible */\n    0\n  ]);\n  var fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */\n    0,\n    0\n  ]);\n  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n  var freb = function(eb, start) {\n    var b = new u16(31);\n    for (var i2 = 0; i2 < 31; ++i2) {\n      b[i2] = start += 1 << eb[i2 - 1];\n    }\n    var r = new i32(b[30]);\n    for (var i2 = 1; i2 < 30; ++i2) {\n      for (var j = b[i2]; j < b[i2 + 1]; ++j) {\n        r[j] = j - b[i2] << 5 | i2;\n      }\n    }\n    return { b, r };\n  };\n  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n  fl[28] = 258, revfl[258] = 28;\n  var _b = freb(fdeb, 0), fd = _b.b;\n  var rev = new u16(32768);\n  for (var i = 0; i < 32768; ++i) {\n    var x = (i & 43690) >> 1 | (i & 21845) << 1;\n    x = (x & 52428) >> 2 | (x & 13107) << 2;\n    x = (x & 61680) >> 4 | (x & 3855) << 4;\n    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n  }\n  var hMap = function(cd, mb, r) {\n    var s = cd.length;\n    var i2 = 0;\n    var l = new u16(mb);\n    for (; i2 < s; ++i2) {\n      if (cd[i2])\n        ++l[cd[i2] - 1];\n    }\n    var le = new u16(mb);\n    for (i2 = 1; i2 < mb; ++i2) {\n      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;\n    }\n    var co;\n    if (r) {\n      co = new u16(1 << mb);\n      var rvb = 15 - mb;\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          var sv = i2 << 4 | cd[i2];\n          var r_1 = mb - cd[i2];\n          var v = le[cd[i2] - 1]++ << r_1;\n          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n            co[rev[v] >> rvb] = sv;\n          }\n        }\n      }\n    } else {\n      co = new u16(s);\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];\n        }\n      }\n    }\n    return co;\n  };\n  var flt = new u8(288);\n  for (var i = 0; i < 144; ++i)\n    flt[i] = 8;\n  for (var i = 144; i < 256; ++i)\n    flt[i] = 9;\n  for (var i = 256; i < 280; ++i)\n    flt[i] = 7;\n  for (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n  var fdt = new u8(32);\n  for (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);\n  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\n  var max = function(a) {\n    var m = a[0];\n    for (var i2 = 1; i2 < a.length; ++i2) {\n      if (a[i2] > m)\n        m = a[i2];\n    }\n    return m;\n  };\n  var bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n  };\n  var bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n  };\n  var shft = function(p) {\n    return (p + 7) / 8 | 0;\n  };\n  var slc = function(v, s, e) {\n    if (s == null || s < 0)\n      s = 0;\n    if (e == null || e > v.length)\n      e = v.length;\n    return new u8(v.subarray(s, e));\n  };\n  var ec = [\n    "unexpected EOF",\n    "invalid block type",\n    "invalid length/literal",\n    "invalid distance",\n    "stream finished",\n    "no stream handler",\n    ,\n    "no callback",\n    "invalid UTF-8 data",\n    "extra field too long",\n    "date not in range 1980-2099",\n    "filename too long",\n    "stream finishing",\n    "invalid zip data"\n    // determined by unknown compression method\n  ];\n  var err = function(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(e, err);\n    if (!nt)\n      throw e;\n    return e;\n  };\n  var inflt = function(dat, st, buf, dict) {\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n      return buf || new u8(0);\n    var noBuf = !buf;\n    var resize = noBuf || st.i != 2;\n    var noSt = st.i;\n    if (noBuf)\n      buf = new u8(sl * 3);\n    var cbuf = function(l2) {\n      var bl = buf.length;\n      if (l2 > bl) {\n        var nbuf = new u8(Math.max(bl * 2, l2));\n        nbuf.set(buf);\n        buf = nbuf;\n      }\n    };\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    var tbts = sl * 8;\n    do {\n      if (!lm) {\n        final = bits(dat, pos, 1);\n        var type = bits(dat, pos + 1, 3);\n        pos += 3;\n        if (!type) {\n          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n          if (t > sl) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + l);\n          buf.set(dat.subarray(s, t), bt);\n          st.b = bt += l, st.p = pos = t * 8, st.f = final;\n          continue;\n        } else if (type == 1)\n          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n        else if (type == 2) {\n          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n          var tl = hLit + bits(dat, pos + 5, 31) + 1;\n          pos += 14;\n          var ldt = new u8(tl);\n          var clt = new u8(19);\n          for (var i2 = 0; i2 < hcLen; ++i2) {\n            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\n          }\n          pos += hcLen * 3;\n          var clb = max(clt), clbmsk = (1 << clb) - 1;\n          var clm = hMap(clt, clb, 1);\n          for (var i2 = 0; i2 < tl; ) {\n            var r = clm[bits(dat, pos, clbmsk)];\n            pos += r & 15;\n            var s = r >> 4;\n            if (s < 16) {\n              ldt[i2++] = s;\n            } else {\n              var c = 0, n = 0;\n              if (s == 16)\n                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];\n              else if (s == 17)\n                n = 3 + bits(dat, pos, 7), pos += 3;\n              else if (s == 18)\n                n = 11 + bits(dat, pos, 127), pos += 7;\n              while (n--)\n                ldt[i2++] = c;\n            }\n          }\n          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n          lbt = max(lt);\n          dbt = max(dt);\n          lm = hMap(lt, lbt, 1);\n          dm = hMap(dt, dbt, 1);\n        } else\n          err(1);\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n      }\n      if (resize)\n        cbuf(bt + 131072);\n      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n      var lpos = pos;\n      for (; ; lpos = pos) {\n        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n        pos += c & 15;\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (!c)\n          err(2);\n        if (sym < 256)\n          buf[bt++] = sym;\n        else if (sym == 256) {\n          lpos = pos, lm = null;\n          break;\n        } else {\n          var add2 = sym - 254;\n          if (sym > 264) {\n            var i2 = sym - 257, b = fleb[i2];\n            add2 = bits(dat, pos, (1 << b) - 1) + fl[i2];\n            pos += b;\n          }\n          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n          if (!d)\n            err(3);\n          pos += d & 15;\n          var dt = fd[dsym];\n          if (dsym > 3) {\n            var b = fdeb[dsym];\n            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n          }\n          if (pos > tbts) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + 131072);\n          var end = bt + add2;\n          if (bt < dt) {\n            var shift = dl - dt, dend = Math.min(dt, end);\n            if (shift + bt < 0)\n              err(3);\n            for (; bt < dend; ++bt)\n              buf[bt] = dict[shift + bt];\n          }\n          for (; bt < end; ++bt)\n            buf[bt] = buf[bt - dt];\n        }\n      }\n      st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n      if (lm)\n        final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n  };\n  var et = /* @__PURE__ */ new u8(0);\n  var mrg = function(a, b) {\n    var o = {};\n    for (var k in a)\n      o[k] = a[k];\n    for (var k in b)\n      o[k] = b[k];\n    return o;\n  };\n  var wcln = function(fn, fnStr, td2) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\\s+/g, "").split(",");\n    for (var i2 = 0; i2 < dt.length; ++i2) {\n      var v = dt[i2], k = ks[i2];\n      if (typeof v == "function") {\n        fnStr += ";" + k + "=";\n        var st_1 = v.toString();\n        if (v.prototype) {\n          if (st_1.indexOf("[native code]") != -1) {\n            var spInd = st_1.indexOf(" ", 8) + 1;\n            fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));\n          } else {\n            fnStr += st_1;\n            for (var t in v.prototype)\n              fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();\n          }\n        } else\n          fnStr += st_1;\n      } else\n        td2[k] = v;\n    }\n    return fnStr;\n  };\n  var ch = [];\n  var cbfs = function(v) {\n    var tl = [];\n    for (var k in v) {\n      if (v[k].buffer) {\n        tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n      }\n    }\n    return tl;\n  };\n  var wrkr = function(fns, init, id, cb) {\n    if (!ch[id]) {\n      var fnStr = "", td_1 = {}, m = fns.length - 1;\n      for (var i2 = 0; i2 < m; ++i2)\n        fnStr = wcln(fns[i2], fnStr, td_1);\n      ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td2 = mrg({}, ch[id].e);\n    return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);\n  };\n  var bInflt = function() {\n    return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];\n  };\n  var pbf = function(msg) {\n    return postMessage(msg, [msg.buffer]);\n  };\n  var gopt = function(o) {\n    return o && {\n      out: o.size && new u8(o.size),\n      dictionary: o.dictionary\n    };\n  };\n  var cbify = function(dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function(err2, dat2) {\n      w.terminate();\n      cb(err2, dat2);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function() {\n      w.terminate();\n    };\n  };\n  var b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n  };\n  var b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n  };\n  var b8 = function(d, b) {\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\n  };\n  var gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n      err(6, "invalid gzip data");\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n      st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n      ;\n    return st + (flg & 2);\n  };\n  var Inflate = /* @__PURE__ */ function() {\n    function Inflate2(opts, cb) {\n      if (typeof opts == "function")\n        cb = opts, opts = {};\n      this.ondata = cb;\n      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n      this.s = { i: 0, b: dict ? dict.length : 0 };\n      this.o = new u8(32768);\n      this.p = new u8(0);\n      if (dict)\n        this.o.set(dict);\n    }\n    Inflate2.prototype.e = function(c) {\n      if (!this.ondata)\n        err(5);\n      if (this.d)\n        err(4);\n      if (!this.p.length)\n        this.p = c;\n      else if (c.length) {\n        var n = new u8(this.p.length + c.length);\n        n.set(this.p), n.set(c, this.p.length), this.p = n;\n      }\n    };\n    Inflate2.prototype.c = function(final) {\n      this.s.i = +(this.d = final || false);\n      var bts = this.s.b;\n      var dt = inflt(this.p, this.s, this.o);\n      this.ondata(slc(dt, bts, this.s.b), this.d);\n      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    Inflate2.prototype.push = function(chunk, final) {\n      this.e(chunk), this.c(final);\n    };\n    return Inflate2;\n  }();\n  function inflate(data, opts, cb) {\n    if (!cb)\n      cb = opts, opts = {};\n    if (typeof cb != "function")\n      err(7);\n    return cbify(data, opts, [\n      bInflt\n    ], function(ev) {\n      return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));\n    }, 1, cb);\n  }\n  function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n  }\n  var Gunzip = /* @__PURE__ */ function() {\n    function Gunzip2(opts, cb) {\n      this.v = 1;\n      this.r = 0;\n      Inflate.call(this, opts, cb);\n    }\n    Gunzip2.prototype.push = function(chunk, final) {\n      Inflate.prototype.e.call(this, chunk);\n      this.r += chunk.length;\n      if (this.v) {\n        var p = this.p.subarray(this.v - 1);\n        var s = p.length > 3 ? gzs(p) : 4;\n        if (s > p.length) {\n          if (!final)\n            return;\n        } else if (this.v > 1 && this.onmember) {\n          this.onmember(this.r - p.length);\n        }\n        this.p = p.subarray(s), this.v = 0;\n      }\n      Inflate.prototype.c.call(this, final);\n      if (this.s.f && !this.s.l && !final) {\n        this.v = shft(this.s.p) + 9;\n        this.s = { i: 0 };\n        this.o = new u8(0);\n        this.push(new u8(0), final);\n      }\n    };\n    return Gunzip2;\n  }();\n  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();\n  var tds = 0;\n  try {\n    td.decode(et, { stream: true });\n    tds = 1;\n  } catch (e) {\n  }\n  var dutf8 = function(d) {\n    for (var r = "", i2 = 0; ; ) {\n      var c = d[i2++];\n      var eb = (c > 127) + (c > 223) + (c > 239);\n      if (i2 + eb > d.length)\n        return { s: r, r: slc(d, i2 - 1) };\n      if (!eb)\n        r += String.fromCharCode(c);\n      else if (eb == 3) {\n        c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n      } else if (eb & 1)\n        r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);\n      else\n        r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);\n    }\n  };\n  function strFromU8(dat, latin1) {\n    if (latin1) {\n      var r = "";\n      for (var i2 = 0; i2 < dat.length; i2 += 16384)\n        r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));\n      return r;\n    } else if (td) {\n      return td.decode(dat);\n    } else {\n      var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;\n      if (r.length)\n        err(8);\n      return s;\n    }\n  }\n  var slzh = function(d, b) {\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n  };\n  var zh = function(d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n  };\n  var z64e = function(d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n      ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n  };\n  var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {\n    fn();\n  };\n  function unzip(data, opts, cb) {\n    if (!cb)\n      cb = opts, opts = {};\n    if (typeof cb != "function")\n      err(7);\n    var term = [];\n    var tAll = function() {\n      for (var i3 = 0; i3 < term.length; ++i3)\n        term[i3]();\n    };\n    var files = {};\n    var cbd = function(a, b) {\n      mt(function() {\n        cb(a, b);\n      });\n    };\n    mt(function() {\n      cbd = cb;\n    });\n    var e = data.length - 22;\n    for (; b4(data, e) != 101010256; --e) {\n      if (!e || data.length - e > 65558) {\n        cbd(err(13, 0, 1), null);\n        return tAll;\n      }\n    }\n    var lft = b2(data, e + 8);\n    if (lft) {\n      var c = lft;\n      var o = b4(data, e + 16);\n      var z = o == 4294967295 || c == 65535;\n      if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 101075792;\n        if (z) {\n          c = lft = b4(data, ze + 32);\n          o = b4(data, ze + 48);\n        }\n      }\n      var fltr = opts && opts.filter;\n      var _loop_3 = function(i3) {\n        var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\n        o = no;\n        var cbl = function(e2, d) {\n          if (e2) {\n            tAll();\n            cbd(e2, null);\n          } else {\n            if (d)\n              files[fn] = d;\n            if (!--lft)\n              cbd(null, files);\n          }\n        };\n        if (!fltr || fltr({\n          name: fn,\n          size: sc,\n          originalSize: su,\n          compression: c_1\n        })) {\n          if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n          else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (su < 524288 || sc > 0.8 * su) {\n              try {\n                cbl(null, inflateSync(infl, { out: new u8(su) }));\n              } catch (e2) {\n                cbl(e2, null);\n              }\n            } else\n              term.push(inflate(infl, { size: su }, cbl));\n          } else\n            cbl(err(14, "unknown compression type " + c_1, 1), null);\n        } else\n          cbl(null, null);\n      };\n      for (var i2 = 0; i2 < c; ++i2) {\n        _loop_3(i2);\n      }\n    } else\n      cbd(null, {});\n    return tAll;\n  }\n  function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 101010256; --e) {\n      if (!e || data.length - e > 65558)\n        err(13);\n    }\n    var c = b2(data, e + 8);\n    if (!c)\n      return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n      var ze = b4(data, e - 12);\n      z = b4(data, ze) == 101075792;\n      if (z) {\n        c = b4(data, ze + 32);\n        o = b4(data, ze + 48);\n      }\n    }\n    var fltr = opts && opts.filter;\n    for (var i2 = 0; i2 < c; ++i2) {\n      var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\n      o = no;\n      if (!fltr || fltr({\n        name: fn,\n        size: sc,\n        originalSize: su,\n        compression: c_2\n      })) {\n        if (!c_2)\n          files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n          files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n        else\n          err(14, "unknown compression type " + c_2);\n      }\n    }\n    return files;\n  }\n  /**\n   * @license\n   * Copyright 2010-2024 Three.js Authors\n   * SPDX-License-Identifier: MIT\n   */\n  const REVISION = "172";\n  const FrontSide = 0;\n  const BackSide = 1;\n  const NormalBlending = 1;\n  const AddEquation = 100;\n  const SrcAlphaFactor = 204;\n  const OneMinusSrcAlphaFactor = 205;\n  const LessEqualDepth = 3;\n  const MultiplyOperation = 0;\n  const UVMapping = 300;\n  const RepeatWrapping = 1e3;\n  const ClampToEdgeWrapping = 1001;\n  const MirroredRepeatWrapping = 1002;\n  const NearestFilter = 1003;\n  const LinearFilter = 1006;\n  const LinearMipmapLinearFilter = 1008;\n  const UnsignedByteType = 1009;\n  const UnsignedIntType = 1014;\n  const FloatType = 1015;\n  const RGBAFormat = 1023;\n  const RGIntegerFormat = 1031;\n  const RGBAIntegerFormat = 1033;\n  const NoColorSpace = "";\n  const SRGBColorSpace = "srgb";\n  const LinearSRGBColorSpace = "srgb-linear";\n  const LinearTransfer = "linear";\n  const SRGBTransfer = "srgb";\n  const KeepStencilOp = 7680;\n  const AlwaysStencilFunc = 519;\n  const StaticDrawUsage = 35044;\n  const GLSL3 = "300 es";\n  const WebGLCoordinateSystem = 2e3;\n  const WebGPUCoordinateSystem = 2001;\n  class EventDispatcher {\n    addEventListener(type, listener) {\n      if (this._listeners === void 0) this._listeners = {};\n      const listeners = this._listeners;\n      if (listeners[type] === void 0) {\n        listeners[type] = [];\n      }\n      if (listeners[type].indexOf(listener) === -1) {\n        listeners[type].push(listener);\n      }\n    }\n    hasEventListener(type, listener) {\n      if (this._listeners === void 0) return false;\n      const listeners = this._listeners;\n      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n    }\n    removeEventListener(type, listener) {\n      if (this._listeners === void 0) return;\n      const listeners = this._listeners;\n      const listenerArray = listeners[type];\n      if (listenerArray !== void 0) {\n        const index = listenerArray.indexOf(listener);\n        if (index !== -1) {\n          listenerArray.splice(index, 1);\n        }\n      }\n    }\n    dispatchEvent(event) {\n      if (this._listeners === void 0) return;\n      const listeners = this._listeners;\n      const listenerArray = listeners[event.type];\n      if (listenerArray !== void 0) {\n        event.target = this;\n        const array = listenerArray.slice(0);\n        for (let i2 = 0, l = array.length; i2 < l; i2++) {\n          array[i2].call(this, event);\n        }\n        event.target = null;\n      }\n    }\n  }\n  const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];\n  function generateUUID() {\n    const d0 = Math.random() * 4294967295 | 0;\n    const d1 = Math.random() * 4294967295 | 0;\n    const d2 = Math.random() * 4294967295 | 0;\n    const d3 = Math.random() * 4294967295 | 0;\n    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];\n    return uuid.toLowerCase();\n  }\n  function clamp(value, min, max2) {\n    return Math.max(min, Math.min(max2, value));\n  }\n  function euclideanModulo(n, m) {\n    return (n % m + m) % m;\n  }\n  function lerp(x2, y, t) {\n    return (1 - t) * x2 + t * y;\n  }\n  function denormalize(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return value / 4294967295;\n      case Uint16Array:\n        return value / 65535;\n      case Uint8Array:\n        return value / 255;\n      case Int32Array:\n        return Math.max(value / 2147483647, -1);\n      case Int16Array:\n        return Math.max(value / 32767, -1);\n      case Int8Array:\n        return Math.max(value / 127, -1);\n      default:\n        throw new Error("Invalid component type.");\n    }\n  }\n  function normalize$1(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return Math.round(value * 4294967295);\n      case Uint16Array:\n        return Math.round(value * 65535);\n      case Uint8Array:\n        return Math.round(value * 255);\n      case Int32Array:\n        return Math.round(value * 2147483647);\n      case Int16Array:\n        return Math.round(value * 32767);\n      case Int8Array:\n        return Math.round(value * 127);\n      default:\n        throw new Error("Invalid component type.");\n    }\n  }\n  class Vector2 {\n    constructor(x2 = 0, y = 0) {\n      Vector2.prototype.isVector2 = true;\n      this.x = x2;\n      this.y = y;\n    }\n    get width() {\n      return this.x;\n    }\n    set width(value) {\n      this.x = value;\n    }\n    get height() {\n      return this.y;\n    }\n    set height(value) {\n      this.y = value;\n    }\n    set(x2, y) {\n      this.x = x2;\n      this.y = y;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      return this;\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6];\n      this.y = e[1] * x2 + e[4] * y + e[7];\n      return this;\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y;\n    }\n    cross(v) {\n      return this.x * v.y - this.y * v.x;\n    }\n    lengthSq() {\n      return this.x * this.x + this.y * this.y;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    angle() {\n      const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n      return angle;\n    }\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y;\n      return dx * dx + dy * dy;\n    }\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      return this;\n    }\n    rotateAround(center, angle) {\n      const c = Math.cos(angle), s = Math.sin(angle);\n      const x2 = this.x - center.x;\n      const y = this.y - center.y;\n      this.x = x2 * c - y * s + center.x;\n      this.y = x2 * s + y * c + center.y;\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n    }\n  }\n  class Matrix3 {\n    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      Matrix3.prototype.isMatrix3 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n      }\n    }\n    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      const te = this.elements;\n      te[0] = n11;\n      te[1] = n21;\n      te[2] = n31;\n      te[3] = n12;\n      te[4] = n22;\n      te[5] = n32;\n      te[6] = n13;\n      te[7] = n23;\n      te[8] = n33;\n      return this;\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      return this;\n    }\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrix3Column(this, 0);\n      yAxis.setFromMatrix3Column(this, 1);\n      zAxis.setFromMatrix3Column(this, 2);\n      return this;\n    }\n    setFromMatrix4(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[4],\n        me[8],\n        me[1],\n        me[5],\n        me[9],\n        me[2],\n        me[6],\n        me[10]\n      );\n      return this;\n    }\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[3], a13 = ae[6];\n      const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n      const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n      const b11 = be[0], b12 = be[3], b13 = be[6];\n      const b21 = be[1], b22 = be[4], b23 = be[7];\n      const b31 = be[2], b32 = be[5], b33 = be[8];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n      te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n      te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return this;\n    }\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[3] *= s;\n      te[6] *= s;\n      te[1] *= s;\n      te[4] *= s;\n      te[7] *= s;\n      te[2] *= s;\n      te[5] *= s;\n      te[8] *= s;\n      return this;\n    }\n    determinant() {\n      const te = this.elements;\n      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];\n      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;\n    }\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\n      te[2] = (n32 * n21 - n31 * n22) * detInv;\n      te[3] = t12 * detInv;\n      te[4] = (n33 * n11 - n31 * n13) * detInv;\n      te[5] = (n31 * n12 - n32 * n11) * detInv;\n      te[6] = t13 * detInv;\n      te[7] = (n21 * n13 - n23 * n11) * detInv;\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\n      return this;\n    }\n    transpose() {\n      let tmp;\n      const m = this.elements;\n      tmp = m[1];\n      m[1] = m[3];\n      m[3] = tmp;\n      tmp = m[2];\n      m[2] = m[6];\n      m[6] = tmp;\n      tmp = m[5];\n      m[5] = m[7];\n      m[7] = tmp;\n      return this;\n    }\n    getNormalMatrix(matrix4) {\n      return this.setFromMatrix4(matrix4).invert().transpose();\n    }\n    transposeIntoArray(r) {\n      const m = this.elements;\n      r[0] = m[0];\n      r[1] = m[3];\n      r[2] = m[6];\n      r[3] = m[1];\n      r[4] = m[4];\n      r[5] = m[7];\n      r[6] = m[2];\n      r[7] = m[5];\n      r[8] = m[8];\n      return this;\n    }\n    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n      const c = Math.cos(rotation);\n      const s = Math.sin(rotation);\n      this.set(\n        sx * c,\n        sx * s,\n        -sx * (c * cx + s * cy) + cx + tx,\n        -sy * s,\n        sy * c,\n        -sy * (-s * cx + c * cy) + cy + ty,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    //\n    scale(sx, sy) {\n      this.premultiply(_m3.makeScale(sx, sy));\n      return this;\n    }\n    rotate(theta) {\n      this.premultiply(_m3.makeRotation(-theta));\n      return this;\n    }\n    translate(tx, ty) {\n      this.premultiply(_m3.makeTranslation(tx, ty));\n      return this;\n    }\n    // for 2D Transforms\n    makeTranslation(x2, y) {\n      if (x2.isVector2) {\n        this.set(\n          1,\n          0,\n          x2.x,\n          0,\n          1,\n          x2.y,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          x2,\n          0,\n          1,\n          y,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    makeRotation(theta) {\n      const c = Math.cos(theta);\n      const s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeScale(x2, y) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    //\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 9; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 9; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      return array;\n    }\n    clone() {\n      return new this.constructor().fromArray(this.elements);\n    }\n  }\n  const _m3 = /* @__PURE__ */ new Matrix3();\n  function arrayNeedsUint32(array) {\n    for (let i2 = array.length - 1; i2 >= 0; --i2) {\n      if (array[i2] >= 65535) return true;\n    }\n    return false;\n  }\n  function createElementNS(name) {\n    return document.createElementNS("http://www.w3.org/1999/xhtml", name);\n  }\n  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\n    0.4123908,\n    0.3575843,\n    0.1804808,\n    0.212639,\n    0.7151687,\n    0.0721923,\n    0.0193308,\n    0.1191948,\n    0.9505322\n  );\n  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\n    3.2409699,\n    -1.5373832,\n    -0.4986108,\n    -0.9692436,\n    1.8759675,\n    0.0415551,\n    0.0556301,\n    -0.203977,\n    1.0569715\n  );\n  function createColorManagement() {\n    const ColorManagement2 = {\n      enabled: true,\n      workingColorSpace: LinearSRGBColorSpace,\n      /**\n       * Implementations of supported color spaces.\n       *\n       * Required:\n       *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n       *\t- whitePoint: reference white [ x y ]\n       *\t- transfer: transfer function (pre-defined)\n       *\t- toXYZ: Matrix3 RGB to XYZ transform\n       *\t- fromXYZ: Matrix3 XYZ to RGB transform\n       *\t- luminanceCoefficients: RGB luminance coefficients\n       *\n       * Optional:\n       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n       *\n       * Reference:\n       * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n       */\n      spaces: {},\n      convert: function(color, sourceColorSpace, targetColorSpace) {\n        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n          return color;\n        }\n        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\n          color.r = SRGBToLinear(color.r);\n          color.g = SRGBToLinear(color.g);\n          color.b = SRGBToLinear(color.b);\n        }\n        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {\n          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n        }\n        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\n          color.r = LinearToSRGB(color.r);\n          color.g = LinearToSRGB(color.g);\n          color.b = LinearToSRGB(color.b);\n        }\n        return color;\n      },\n      fromWorkingColorSpace: function(color, targetColorSpace) {\n        return this.convert(color, this.workingColorSpace, targetColorSpace);\n      },\n      toWorkingColorSpace: function(color, sourceColorSpace) {\n        return this.convert(color, sourceColorSpace, this.workingColorSpace);\n      },\n      getPrimaries: function(colorSpace) {\n        return this.spaces[colorSpace].primaries;\n      },\n      getTransfer: function(colorSpace) {\n        if (colorSpace === NoColorSpace) return LinearTransfer;\n        return this.spaces[colorSpace].transfer;\n      },\n      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {\n        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n      },\n      define: function(colorSpaces) {\n        Object.assign(this.spaces, colorSpaces);\n      },\n      // Internal APIs\n      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {\n        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);\n      },\n      _getDrawingBufferColorSpace: function(colorSpace) {\n        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n      },\n      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\n        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n      }\n    };\n    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\n    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\n    const D65 = [0.3127, 0.329];\n    ColorManagement2.define({\n      [LinearSRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: LinearTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      },\n      [SRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: SRGBTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      }\n    });\n    return ColorManagement2;\n  }\n  const ColorManagement = /* @__PURE__ */ createColorManagement();\n  function SRGBToLinear(c) {\n    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n  }\n  function LinearToSRGB(c) {\n    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n  }\n  let _canvas;\n  class ImageUtils {\n    static getDataURL(image) {\n      if (/^data:/i.test(image.src)) {\n        return image.src;\n      }\n      if (typeof HTMLCanvasElement === "undefined") {\n        return image.src;\n      }\n      let canvas;\n      if (image instanceof HTMLCanvasElement) {\n        canvas = image;\n      } else {\n        if (_canvas === void 0) _canvas = createElementNS("canvas");\n        _canvas.width = image.width;\n        _canvas.height = image.height;\n        const context = _canvas.getContext("2d");\n        if (image instanceof ImageData) {\n          context.putImageData(image, 0, 0);\n        } else {\n          context.drawImage(image, 0, 0, image.width, image.height);\n        }\n        canvas = _canvas;\n      }\n      if (canvas.width > 2048 || canvas.height > 2048) {\n        console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);\n        return canvas.toDataURL("image/jpeg", 0.6);\n      } else {\n        return canvas.toDataURL("image/png");\n      }\n    }\n    static sRGBToLinear(image) {\n      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {\n        const canvas = createElementNS("canvas");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext("2d");\n        context.drawImage(image, 0, 0, image.width, image.height);\n        const imageData = context.getImageData(0, 0, image.width, image.height);\n        const data = imageData.data;\n        for (let i2 = 0; i2 < data.length; i2++) {\n          data[i2] = SRGBToLinear(data[i2] / 255) * 255;\n        }\n        context.putImageData(imageData, 0, 0);\n        return canvas;\n      } else if (image.data) {\n        const data = image.data.slice(0);\n        for (let i2 = 0; i2 < data.length; i2++) {\n          if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n            data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);\n          } else {\n            data[i2] = SRGBToLinear(data[i2]);\n          }\n        }\n        return {\n          data,\n          width: image.width,\n          height: image.height\n        };\n      } else {\n        console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");\n        return image;\n      }\n    }\n  }\n  let _sourceId = 0;\n  class Source {\n    constructor(data = null) {\n      this.isSource = true;\n      Object.defineProperty(this, "id", { value: _sourceId++ });\n      this.uuid = generateUUID();\n      this.data = data;\n      this.dataReady = true;\n      this.version = 0;\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (!isRootObject && meta.images[this.uuid] !== void 0) {\n        return meta.images[this.uuid];\n      }\n      const output = {\n        uuid: this.uuid,\n        url: ""\n      };\n      const data = this.data;\n      if (data !== null) {\n        let url;\n        if (Array.isArray(data)) {\n          url = [];\n          for (let i2 = 0, l = data.length; i2 < l; i2++) {\n            if (data[i2].isDataTexture) {\n              url.push(serializeImage(data[i2].image));\n            } else {\n              url.push(serializeImage(data[i2]));\n            }\n          }\n        } else {\n          url = serializeImage(data);\n        }\n        output.url = url;\n      }\n      if (!isRootObject) {\n        meta.images[this.uuid] = output;\n      }\n      return output;\n    }\n  }\n  function serializeImage(image) {\n    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {\n      return ImageUtils.getDataURL(image);\n    } else {\n      if (image.data) {\n        return {\n          data: Array.from(image.data),\n          width: image.width,\n          height: image.height,\n          type: image.data.constructor.name\n        };\n      } else {\n        console.warn("THREE.Texture: Unable to serialize Texture.");\n        return {};\n      }\n    }\n  }\n  let _textureId = 0;\n  class Texture extends EventDispatcher {\n    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {\n      super();\n      this.isTexture = true;\n      Object.defineProperty(this, "id", { value: _textureId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.source = new Source(image);\n      this.mipmaps = [];\n      this.mapping = mapping;\n      this.channel = 0;\n      this.wrapS = wrapS;\n      this.wrapT = wrapT;\n      this.magFilter = magFilter;\n      this.minFilter = minFilter;\n      this.anisotropy = anisotropy;\n      this.format = format;\n      this.internalFormat = null;\n      this.type = type;\n      this.offset = new Vector2(0, 0);\n      this.repeat = new Vector2(1, 1);\n      this.center = new Vector2(0, 0);\n      this.rotation = 0;\n      this.matrixAutoUpdate = true;\n      this.matrix = new Matrix3();\n      this.generateMipmaps = true;\n      this.premultiplyAlpha = false;\n      this.flipY = true;\n      this.unpackAlignment = 4;\n      this.colorSpace = colorSpace;\n      this.userData = {};\n      this.version = 0;\n      this.onUpdate = null;\n      this.renderTarget = null;\n      this.isRenderTargetTexture = false;\n      this.pmremVersion = 0;\n    }\n    get image() {\n      return this.source.data;\n    }\n    set image(value = null) {\n      this.source.data = value;\n    }\n    updateMatrix() {\n      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.name = source.name;\n      this.source = source.source;\n      this.mipmaps = source.mipmaps.slice(0);\n      this.mapping = source.mapping;\n      this.channel = source.channel;\n      this.wrapS = source.wrapS;\n      this.wrapT = source.wrapT;\n      this.magFilter = source.magFilter;\n      this.minFilter = source.minFilter;\n      this.anisotropy = source.anisotropy;\n      this.format = source.format;\n      this.internalFormat = source.internalFormat;\n      this.type = source.type;\n      this.offset.copy(source.offset);\n      this.repeat.copy(source.repeat);\n      this.center.copy(source.center);\n      this.rotation = source.rotation;\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrix.copy(source.matrix);\n      this.generateMipmaps = source.generateMipmaps;\n      this.premultiplyAlpha = source.premultiplyAlpha;\n      this.flipY = source.flipY;\n      this.unpackAlignment = source.unpackAlignment;\n      this.colorSpace = source.colorSpace;\n      this.renderTarget = source.renderTarget;\n      this.isRenderTargetTexture = source.isRenderTargetTexture;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      this.needsUpdate = true;\n      return this;\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (!isRootObject && meta.textures[this.uuid] !== void 0) {\n        return meta.textures[this.uuid];\n      }\n      const output = {\n        metadata: {\n          version: 4.6,\n          type: "Texture",\n          generator: "Texture.toJSON"\n        },\n        uuid: this.uuid,\n        name: this.name,\n        image: this.source.toJSON(meta).uuid,\n        mapping: this.mapping,\n        channel: this.channel,\n        repeat: [this.repeat.x, this.repeat.y],\n        offset: [this.offset.x, this.offset.y],\n        center: [this.center.x, this.center.y],\n        rotation: this.rotation,\n        wrap: [this.wrapS, this.wrapT],\n        format: this.format,\n        internalFormat: this.internalFormat,\n        type: this.type,\n        colorSpace: this.colorSpace,\n        minFilter: this.minFilter,\n        magFilter: this.magFilter,\n        anisotropy: this.anisotropy,\n        flipY: this.flipY,\n        generateMipmaps: this.generateMipmaps,\n        premultiplyAlpha: this.premultiplyAlpha,\n        unpackAlignment: this.unpackAlignment\n      };\n      if (Object.keys(this.userData).length > 0) output.userData = this.userData;\n      if (!isRootObject) {\n        meta.textures[this.uuid] = output;\n      }\n      return output;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n    transformUv(uv) {\n      if (this.mapping !== UVMapping) return uv;\n      uv.applyMatrix3(this.matrix);\n      if (uv.x < 0 || uv.x > 1) {\n        switch (this.wrapS) {\n          case RepeatWrapping:\n            uv.x = uv.x - Math.floor(uv.x);\n            break;\n          case ClampToEdgeWrapping:\n            uv.x = uv.x < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n              uv.x = Math.ceil(uv.x) - uv.x;\n            } else {\n              uv.x = uv.x - Math.floor(uv.x);\n            }\n            break;\n        }\n      }\n      if (uv.y < 0 || uv.y > 1) {\n        switch (this.wrapT) {\n          case RepeatWrapping:\n            uv.y = uv.y - Math.floor(uv.y);\n            break;\n          case ClampToEdgeWrapping:\n            uv.y = uv.y < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n              uv.y = Math.ceil(uv.y) - uv.y;\n            } else {\n              uv.y = uv.y - Math.floor(uv.y);\n            }\n            break;\n        }\n      }\n      if (this.flipY) {\n        uv.y = 1 - uv.y;\n      }\n      return uv;\n    }\n    set needsUpdate(value) {\n      if (value === true) {\n        this.version++;\n        this.source.needsUpdate = true;\n      }\n    }\n    set needsPMREMUpdate(value) {\n      if (value === true) {\n        this.pmremVersion++;\n      }\n    }\n  }\n  Texture.DEFAULT_IMAGE = null;\n  Texture.DEFAULT_MAPPING = UVMapping;\n  Texture.DEFAULT_ANISOTROPY = 1;\n  class Vector4 {\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      Vector4.prototype.isVector4 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n    }\n    get width() {\n      return this.z;\n    }\n    set width(value) {\n      this.z = value;\n    }\n    get height() {\n      return this.w;\n    }\n    set height(value) {\n      this.w = value;\n    }\n    set(x2, y, z, w) {\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      this.w = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    setW(w) {\n      this.w = w;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        case 3:\n          this.w = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        case 3:\n          return this.w;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y, this.z, this.w);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      this.w = v.w !== void 0 ? v.w : 1;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      this.w += v.w;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      this.w += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      this.w = a.w + b.w;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      this.w += v.w * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      this.w -= v.w;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      this.w -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      this.w = a.w - b.w;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      this.w *= v.w;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      this.w *= scalar;\n      return this;\n    }\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z, w = this.w;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z + e[12] * w;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z + e[13] * w;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z + e[14] * w;\n      this.w = e[3] * x2 + e[7] * y + e[11] * z + e[15] * w;\n      return this;\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      this.w /= v.w;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    setAxisAngleFromQuaternion(q) {\n      this.w = 2 * Math.acos(q.w);\n      const s = Math.sqrt(1 - q.w * q.w);\n      if (s < 1e-4) {\n        this.x = 1;\n        this.y = 0;\n        this.z = 0;\n      } else {\n        this.x = q.x / s;\n        this.y = q.y / s;\n        this.z = q.z / s;\n      }\n      return this;\n    }\n    setAxisAngleFromRotationMatrix(m) {\n      let angle, x2, y, z;\n      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];\n      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n          this.set(1, 0, 0, 0);\n          return this;\n        }\n        angle = Math.PI;\n        const xx = (m11 + 1) / 2;\n        const yy = (m22 + 1) / 2;\n        const zz = (m33 + 1) / 2;\n        const xy = (m12 + m21) / 4;\n        const xz = (m13 + m31) / 4;\n        const yz = (m23 + m32) / 4;\n        if (xx > yy && xx > zz) {\n          if (xx < epsilon) {\n            x2 = 0;\n            y = 0.707106781;\n            z = 0.707106781;\n          } else {\n            x2 = Math.sqrt(xx);\n            y = xy / x2;\n            z = xz / x2;\n          }\n        } else if (yy > zz) {\n          if (yy < epsilon) {\n            x2 = 0.707106781;\n            y = 0;\n            z = 0.707106781;\n          } else {\n            y = Math.sqrt(yy);\n            x2 = xy / y;\n            z = yz / y;\n          }\n        } else {\n          if (zz < epsilon) {\n            x2 = 0.707106781;\n            y = 0.707106781;\n            z = 0;\n          } else {\n            z = Math.sqrt(zz);\n            x2 = xz / z;\n            y = yz / z;\n          }\n        }\n        this.set(x2, y, z, angle);\n        return this;\n      }\n      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));\n      if (Math.abs(s) < 1e-3) s = 1;\n      this.x = (m32 - m23) / s;\n      this.y = (m13 - m31) / s;\n      this.z = (m21 - m12) / s;\n      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n      return this;\n    }\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      this.w = e[15];\n      return this;\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      this.w = Math.min(this.w, v.w);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      this.w = Math.max(this.w, v.w);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      this.w = clamp(this.w, min.w, max2.w);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      this.w = clamp(this.w, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      this.w = Math.floor(this.w);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      this.w = Math.ceil(this.w);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      this.w = Math.round(this.w);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      this.w = Math.trunc(this.w);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      this.w = -this.w;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    }\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      this.w += (v.w - this.w) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      this.w = v1.w + (v2.w - v1.w) * alpha;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      this.w = array[offset + 3];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      array[offset + 3] = this.w;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      this.w = attribute.getW(index);\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      this.w = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n      yield this.w;\n    }\n  }\n  class RenderTarget extends EventDispatcher {\n    constructor(width = 1, height = 1, options = {}) {\n      super();\n      this.isRenderTarget = true;\n      this.width = width;\n      this.height = height;\n      this.depth = 1;\n      this.scissor = new Vector4(0, 0, width, height);\n      this.scissorTest = false;\n      this.viewport = new Vector4(0, 0, width, height);\n      const image = { width, height, depth: 1 };\n      options = Object.assign({\n        generateMipmaps: false,\n        internalFormat: null,\n        minFilter: LinearFilter,\n        depthBuffer: true,\n        stencilBuffer: false,\n        resolveDepthBuffer: true,\n        resolveStencilBuffer: true,\n        depthTexture: null,\n        samples: 0,\n        count: 1\n      }, options);\n      const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);\n      texture.flipY = false;\n      texture.generateMipmaps = options.generateMipmaps;\n      texture.internalFormat = options.internalFormat;\n      this.textures = [];\n      const count = options.count;\n      for (let i2 = 0; i2 < count; i2++) {\n        this.textures[i2] = texture.clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n      }\n      this.depthBuffer = options.depthBuffer;\n      this.stencilBuffer = options.stencilBuffer;\n      this.resolveDepthBuffer = options.resolveDepthBuffer;\n      this.resolveStencilBuffer = options.resolveStencilBuffer;\n      this._depthTexture = null;\n      this.depthTexture = options.depthTexture;\n      this.samples = options.samples;\n    }\n    get texture() {\n      return this.textures[0];\n    }\n    set texture(value) {\n      this.textures[0] = value;\n    }\n    set depthTexture(current) {\n      if (this._depthTexture !== null) this._depthTexture.renderTarget = null;\n      if (current !== null) current.renderTarget = this;\n      this._depthTexture = current;\n    }\n    get depthTexture() {\n      return this._depthTexture;\n    }\n    setSize(width, height, depth = 1) {\n      if (this.width !== width || this.height !== height || this.depth !== depth) {\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        for (let i2 = 0, il = this.textures.length; i2 < il; i2++) {\n          this.textures[i2].image.width = width;\n          this.textures[i2].image.height = height;\n          this.textures[i2].image.depth = depth;\n        }\n        this.dispose();\n      }\n      this.viewport.set(0, 0, width, height);\n      this.scissor.set(0, 0, width, height);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.width = source.width;\n      this.height = source.height;\n      this.depth = source.depth;\n      this.scissor.copy(source.scissor);\n      this.scissorTest = source.scissorTest;\n      this.viewport.copy(source.viewport);\n      this.textures.length = 0;\n      for (let i2 = 0, il = source.textures.length; i2 < il; i2++) {\n        this.textures[i2] = source.textures[i2].clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n      }\n      const image = Object.assign({}, source.texture.image);\n      this.texture.source = new Source(image);\n      this.depthBuffer = source.depthBuffer;\n      this.stencilBuffer = source.stencilBuffer;\n      this.resolveDepthBuffer = source.resolveDepthBuffer;\n      this.resolveStencilBuffer = source.resolveStencilBuffer;\n      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();\n      this.samples = source.samples;\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n  }\n  class WebGLRenderTarget extends RenderTarget {\n    constructor(width = 1, height = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLRenderTarget = true;\n    }\n  }\n  class DataArrayTexture extends Texture {\n    constructor(data = null, width = 1, height = 1, depth = 1) {\n      super(null);\n      this.isDataArrayTexture = true;\n      this.image = { data, width, height, depth };\n      this.magFilter = NearestFilter;\n      this.minFilter = NearestFilter;\n      this.wrapR = ClampToEdgeWrapping;\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n      this.layerUpdates = /* @__PURE__ */ new Set();\n    }\n    addLayerUpdate(layerIndex) {\n      this.layerUpdates.add(layerIndex);\n    }\n    clearLayerUpdates() {\n      this.layerUpdates.clear();\n    }\n  }\n  class WebGLArrayRenderTarget extends WebGLRenderTarget {\n    constructor(width = 1, height = 1, depth = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLArrayRenderTarget = true;\n      this.depth = depth;\n      this.texture = new DataArrayTexture(null, width, height, depth);\n      this.texture.isRenderTargetTexture = true;\n    }\n  }\n  class Quaternion {\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      this.isQuaternion = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n    }\n    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\n      if (t === 0) {\n        dst[dstOffset + 0] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n        return;\n      }\n      if (t === 1) {\n        dst[dstOffset + 0] = x1;\n        dst[dstOffset + 1] = y1;\n        dst[dstOffset + 2] = z1;\n        dst[dstOffset + 3] = w1;\n        return;\n      }\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n        let s = 1 - t;\n        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\n        if (sqrSin > Number.EPSILON) {\n          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\n          s = Math.sin(s * len) / sin;\n          t = Math.sin(t * len) / sin;\n        }\n        const tDir = t * dir;\n        x0 = x0 * s + x1 * tDir;\n        y0 = y0 * s + y1 * tDir;\n        z0 = z0 * s + z1 * tDir;\n        w0 = w0 * s + w1 * tDir;\n        if (s === 1 - t) {\n          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n          x0 *= f;\n          y0 *= f;\n          z0 *= f;\n          w0 *= f;\n        }\n      }\n      dst[dstOffset] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n    }\n    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n      const x0 = src0[srcOffset0];\n      const y0 = src0[srcOffset0 + 1];\n      const z0 = src0[srcOffset0 + 2];\n      const w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1];\n      const y1 = src1[srcOffset1 + 1];\n      const z1 = src1[srcOffset1 + 2];\n      const w1 = src1[srcOffset1 + 3];\n      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n      return dst;\n    }\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    get w() {\n      return this._w;\n    }\n    set w(value) {\n      this._w = value;\n      this._onChangeCallback();\n    }\n    set(x2, y, z, w) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n      this._onChangeCallback();\n      return this;\n    }\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._w);\n    }\n    copy(quaternion) {\n      this._x = quaternion.x;\n      this._y = quaternion.y;\n      this._z = quaternion.z;\n      this._w = quaternion.w;\n      this._onChangeCallback();\n      return this;\n    }\n    setFromEuler(euler, update = true) {\n      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;\n      const cos = Math.cos;\n      const sin = Math.sin;\n      const c1 = cos(x2 / 2);\n      const c2 = cos(y / 2);\n      const c3 = cos(z / 2);\n      const s1 = sin(x2 / 2);\n      const s2 = sin(y / 2);\n      const s3 = sin(z / 2);\n      switch (order) {\n        case "XYZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "YXZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "ZXY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "ZYX":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "YZX":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "XZY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        default:\n          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);\n      }\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    setFromAxisAngle(axis, angle) {\n      const halfAngle = angle / 2, s = Math.sin(halfAngle);\n      this._x = axis.x * s;\n      this._y = axis.y * s;\n      this._z = axis.z * s;\n      this._w = Math.cos(halfAngle);\n      this._onChangeCallback();\n      return this;\n    }\n    setFromRotationMatrix(m) {\n      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n      if (trace > 0) {\n        const s = 0.5 / Math.sqrt(trace + 1);\n        this._w = 0.25 / s;\n        this._x = (m32 - m23) * s;\n        this._y = (m13 - m31) * s;\n        this._z = (m21 - m12) * s;\n      } else if (m11 > m22 && m11 > m33) {\n        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n        this._w = (m32 - m23) / s;\n        this._x = 0.25 * s;\n        this._y = (m12 + m21) / s;\n        this._z = (m13 + m31) / s;\n      } else if (m22 > m33) {\n        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\n        this._w = (m13 - m31) / s;\n        this._x = (m12 + m21) / s;\n        this._y = 0.25 * s;\n        this._z = (m23 + m32) / s;\n      } else {\n        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\n        this._w = (m21 - m12) / s;\n        this._x = (m13 + m31) / s;\n        this._y = (m23 + m32) / s;\n        this._z = 0.25 * s;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    setFromUnitVectors(vFrom, vTo) {\n      let r = vFrom.dot(vTo) + 1;\n      if (r < Number.EPSILON) {\n        r = 0;\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n          this._x = -vFrom.y;\n          this._y = vFrom.x;\n          this._z = 0;\n          this._w = r;\n        } else {\n          this._x = 0;\n          this._y = -vFrom.z;\n          this._z = vFrom.y;\n          this._w = r;\n        }\n      } else {\n        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n        this._w = r;\n      }\n      return this.normalize();\n    }\n    angleTo(q) {\n      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n    }\n    rotateTowards(q, step) {\n      const angle = this.angleTo(q);\n      if (angle === 0) return this;\n      const t = Math.min(1, step / angle);\n      this.slerp(q, t);\n      return this;\n    }\n    identity() {\n      return this.set(0, 0, 0, 1);\n    }\n    invert() {\n      return this.conjugate();\n    }\n    conjugate() {\n      this._x *= -1;\n      this._y *= -1;\n      this._z *= -1;\n      this._onChangeCallback();\n      return this;\n    }\n    dot(v) {\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n    }\n    lengthSq() {\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    }\n    length() {\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    }\n    normalize() {\n      let l = this.length();\n      if (l === 0) {\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n        this._w = 1;\n      } else {\n        l = 1 / l;\n        this._x = this._x * l;\n        this._y = this._y * l;\n        this._z = this._z * l;\n        this._w = this._w * l;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    multiply(q) {\n      return this.multiplyQuaternions(this, q);\n    }\n    premultiply(q) {\n      return this.multiplyQuaternions(q, this);\n    }\n    multiplyQuaternions(a, b) {\n      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n      this._onChangeCallback();\n      return this;\n    }\n    slerp(qb, t) {\n      if (t === 0) return this;\n      if (t === 1) return this.copy(qb);\n      const x2 = this._x, y = this._y, z = this._z, w = this._w;\n      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;\n      if (cosHalfTheta < 0) {\n        this._w = -qb._w;\n        this._x = -qb._x;\n        this._y = -qb._y;\n        this._z = -qb._z;\n        cosHalfTheta = -cosHalfTheta;\n      } else {\n        this.copy(qb);\n      }\n      if (cosHalfTheta >= 1) {\n        this._w = w;\n        this._x = x2;\n        this._y = y;\n        this._z = z;\n        return this;\n      }\n      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n      if (sqrSinHalfTheta <= Number.EPSILON) {\n        const s = 1 - t;\n        this._w = s * w + t * this._w;\n        this._x = s * x2 + t * this._x;\n        this._y = s * y + t * this._y;\n        this._z = s * z + t * this._z;\n        this.normalize();\n        return this;\n      }\n      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n      this._w = w * ratioA + this._w * ratioB;\n      this._x = x2 * ratioA + this._x * ratioB;\n      this._y = y * ratioA + this._y * ratioB;\n      this._z = z * ratioA + this._z * ratioB;\n      this._onChangeCallback();\n      return this;\n    }\n    slerpQuaternions(qa, qb, t) {\n      return this.copy(qa).slerp(qb, t);\n    }\n    random() {\n      const theta1 = 2 * Math.PI * Math.random();\n      const theta2 = 2 * Math.PI * Math.random();\n      const x0 = Math.random();\n      const r1 = Math.sqrt(1 - x0);\n      const r2 = Math.sqrt(x0);\n      return this.set(\n        r1 * Math.sin(theta1),\n        r1 * Math.cos(theta1),\n        r2 * Math.sin(theta2),\n        r2 * Math.cos(theta2)\n      );\n    }\n    equals(quaternion) {\n      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n    }\n    fromArray(array, offset = 0) {\n      this._x = array[offset];\n      this._y = array[offset + 1];\n      this._z = array[offset + 2];\n      this._w = array[offset + 3];\n      this._onChangeCallback();\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._w;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this._x = attribute.getX(index);\n      this._y = attribute.getY(index);\n      this._z = attribute.getZ(index);\n      this._w = attribute.getW(index);\n      this._onChangeCallback();\n      return this;\n    }\n    toJSON() {\n      return this.toArray();\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._w;\n    }\n  }\n  class Vector3 {\n    constructor(x2 = 0, y = 0, z = 0) {\n      Vector3.prototype.isVector3 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n    }\n    set(x2, y, z) {\n      if (z === void 0) z = this.z;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y, this.z);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      return this;\n    }\n    multiplyVectors(a, b) {\n      this.x = a.x * b.x;\n      this.y = a.y * b.y;\n      this.z = a.z * b.z;\n      return this;\n    }\n    applyEuler(euler) {\n      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n    }\n    applyAxisAngle(axis, angle) {\n      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n    }\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6] * z;\n      this.y = e[1] * x2 + e[4] * y + e[7] * z;\n      this.z = e[2] * x2 + e[5] * y + e[8] * z;\n      return this;\n    }\n    applyNormalMatrix(m) {\n      return this.applyMatrix3(m).normalize();\n    }\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);\n      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;\n      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;\n      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;\n      return this;\n    }\n    applyQuaternion(q) {\n      const vx = this.x, vy = this.y, vz = this.z;\n      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n      const tx = 2 * (qy * vz - qz * vy);\n      const ty = 2 * (qz * vx - qx * vz);\n      const tz = 2 * (qx * vy - qy * vx);\n      this.x = vx + qw * tx + qy * tz - qz * ty;\n      this.y = vy + qw * ty + qz * tx - qx * tz;\n      this.z = vz + qw * tz + qx * ty - qy * tx;\n      return this;\n    }\n    project(camera) {\n      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n    }\n    unproject(camera) {\n      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n    }\n    transformDirection(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z;\n      return this.normalize();\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    // TODO lengthSquared?\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      return this;\n    }\n    cross(v) {\n      return this.crossVectors(this, v);\n    }\n    crossVectors(a, b) {\n      const ax = a.x, ay = a.y, az = a.z;\n      const bx = b.x, by = b.y, bz = b.z;\n      this.x = ay * bz - az * by;\n      this.y = az * bx - ax * bz;\n      this.z = ax * by - ay * bx;\n      return this;\n    }\n    projectOnVector(v) {\n      const denominator = v.lengthSq();\n      if (denominator === 0) return this.set(0, 0, 0);\n      const scalar = v.dot(this) / denominator;\n      return this.copy(v).multiplyScalar(scalar);\n    }\n    projectOnPlane(planeNormal) {\n      _vector$c.copy(this).projectOnVector(planeNormal);\n      return this.sub(_vector$c);\n    }\n    reflect(normal) {\n      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    }\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n      return dx * dx + dy * dy + dz * dz;\n    }\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n    }\n    setFromSpherical(s) {\n      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n    }\n    setFromSphericalCoords(radius, phi, theta) {\n      const sinPhiRadius = Math.sin(phi) * radius;\n      this.x = sinPhiRadius * Math.sin(theta);\n      this.y = Math.cos(phi) * radius;\n      this.z = sinPhiRadius * Math.cos(theta);\n      return this;\n    }\n    setFromCylindrical(c) {\n      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n    }\n    setFromCylindricalCoords(radius, theta, y) {\n      this.x = radius * Math.sin(theta);\n      this.y = y;\n      this.z = radius * Math.cos(theta);\n      return this;\n    }\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      return this;\n    }\n    setFromMatrixScale(m) {\n      const sx = this.setFromMatrixColumn(m, 0).length();\n      const sy = this.setFromMatrixColumn(m, 1).length();\n      const sz = this.setFromMatrixColumn(m, 2).length();\n      this.x = sx;\n      this.y = sy;\n      this.z = sz;\n      return this;\n    }\n    setFromMatrixColumn(m, index) {\n      return this.fromArray(m.elements, index * 4);\n    }\n    setFromMatrix3Column(m, index) {\n      return this.fromArray(m.elements, index * 3);\n    }\n    setFromEuler(e) {\n      this.x = e._x;\n      this.y = e._y;\n      this.z = e._z;\n      return this;\n    }\n    setFromColor(c) {\n      this.x = c.r;\n      this.y = c.g;\n      this.z = c.b;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      return this;\n    }\n    randomDirection() {\n      const theta = Math.random() * Math.PI * 2;\n      const u = Math.random() * 2 - 1;\n      const c = Math.sqrt(1 - u * u);\n      this.x = c * Math.cos(theta);\n      this.y = u;\n      this.z = c * Math.sin(theta);\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n    }\n  }\n  const _vector$c = /* @__PURE__ */ new Vector3();\n  const _quaternion$4 = /* @__PURE__ */ new Quaternion();\n  class Box3 {\n    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {\n      this.isBox3 = true;\n      this.min = min;\n      this.max = max2;\n    }\n    set(min, max2) {\n      this.min.copy(min);\n      this.max.copy(max2);\n      return this;\n    }\n    setFromArray(array) {\n      this.makeEmpty();\n      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {\n        this.expandByPoint(_vector$b.fromArray(array, i2));\n      }\n      return this;\n    }\n    setFromBufferAttribute(attribute) {\n      this.makeEmpty();\n      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {\n        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));\n      }\n      return this;\n    }\n    setFromPoints(points) {\n      this.makeEmpty();\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        this.expandByPoint(points[i2]);\n      }\n      return this;\n    }\n    setFromCenterAndSize(center, size) {\n      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    }\n    setFromObject(object, precise = false) {\n      this.makeEmpty();\n      return this.expandByObject(object, precise);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(box) {\n      this.min.copy(box.min);\n      this.max.copy(box.max);\n      return this;\n    }\n    makeEmpty() {\n      this.min.x = this.min.y = this.min.z = Infinity;\n      this.max.x = this.max.y = this.max.z = -Infinity;\n      return this;\n    }\n    isEmpty() {\n      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    }\n    getCenter(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n    getSize(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n    }\n    expandByPoint(point) {\n      this.min.min(point);\n      this.max.max(point);\n      return this;\n    }\n    expandByVector(vector) {\n      this.min.sub(vector);\n      this.max.add(vector);\n      return this;\n    }\n    expandByScalar(scalar) {\n      this.min.addScalar(-scalar);\n      this.max.addScalar(scalar);\n      return this;\n    }\n    expandByObject(object, precise = false) {\n      object.updateWorldMatrix(false, false);\n      const geometry = object.geometry;\n      if (geometry !== void 0) {\n        const positionAttribute = geometry.getAttribute("position");\n        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {\n          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {\n            if (object.isMesh === true) {\n              object.getVertexPosition(i2, _vector$b);\n            } else {\n              _vector$b.fromBufferAttribute(positionAttribute, i2);\n            }\n            _vector$b.applyMatrix4(object.matrixWorld);\n            this.expandByPoint(_vector$b);\n          }\n        } else {\n          if (object.boundingBox !== void 0) {\n            if (object.boundingBox === null) {\n              object.computeBoundingBox();\n            }\n            _box$4.copy(object.boundingBox);\n          } else {\n            if (geometry.boundingBox === null) {\n              geometry.computeBoundingBox();\n            }\n            _box$4.copy(geometry.boundingBox);\n          }\n          _box$4.applyMatrix4(object.matrixWorld);\n          this.union(_box$4);\n        }\n      }\n      const children = object.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        this.expandByObject(children[i2], precise);\n      }\n      return this;\n    }\n    containsPoint(point) {\n      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n    }\n    containsBox(box) {\n      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n    }\n    getParameter(point, target) {\n      return target.set(\n        (point.x - this.min.x) / (this.max.x - this.min.x),\n        (point.y - this.min.y) / (this.max.y - this.min.y),\n        (point.z - this.min.z) / (this.max.z - this.min.z)\n      );\n    }\n    intersectsBox(box) {\n      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n    }\n    intersectsSphere(sphere) {\n      this.clampPoint(sphere.center, _vector$b);\n      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    intersectsPlane(plane) {\n      let min, max2;\n      if (plane.normal.x > 0) {\n        min = plane.normal.x * this.min.x;\n        max2 = plane.normal.x * this.max.x;\n      } else {\n        min = plane.normal.x * this.max.x;\n        max2 = plane.normal.x * this.min.x;\n      }\n      if (plane.normal.y > 0) {\n        min += plane.normal.y * this.min.y;\n        max2 += plane.normal.y * this.max.y;\n      } else {\n        min += plane.normal.y * this.max.y;\n        max2 += plane.normal.y * this.min.y;\n      }\n      if (plane.normal.z > 0) {\n        min += plane.normal.z * this.min.z;\n        max2 += plane.normal.z * this.max.z;\n      } else {\n        min += plane.normal.z * this.max.z;\n        max2 += plane.normal.z * this.min.z;\n      }\n      return min <= -plane.constant && max2 >= -plane.constant;\n    }\n    intersectsTriangle(triangle) {\n      if (this.isEmpty()) {\n        return false;\n      }\n      this.getCenter(_center);\n      _extents.subVectors(this.max, _center);\n      _v0$2.subVectors(triangle.a, _center);\n      _v1$7.subVectors(triangle.b, _center);\n      _v2$4.subVectors(triangle.c, _center);\n      _f0.subVectors(_v1$7, _v0$2);\n      _f1.subVectors(_v2$4, _v1$7);\n      _f2.subVectors(_v0$2, _v2$4);\n      let axes = [\n        0,\n        -_f0.z,\n        _f0.y,\n        0,\n        -_f1.z,\n        _f1.y,\n        0,\n        -_f2.z,\n        _f2.y,\n        _f0.z,\n        0,\n        -_f0.x,\n        _f1.z,\n        0,\n        -_f1.x,\n        _f2.z,\n        0,\n        -_f2.x,\n        -_f0.y,\n        _f0.x,\n        0,\n        -_f1.y,\n        _f1.x,\n        0,\n        -_f2.y,\n        _f2.x,\n        0\n      ];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      _triangleNormal.crossVectors(_f0, _f1);\n      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);\n    }\n    clampPoint(point, target) {\n      return target.copy(point).clamp(this.min, this.max);\n    }\n    distanceToPoint(point) {\n      return this.clampPoint(point, _vector$b).distanceTo(point);\n    }\n    getBoundingSphere(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n      } else {\n        this.getCenter(target.center);\n        target.radius = this.getSize(_vector$b).length() * 0.5;\n      }\n      return target;\n    }\n    intersect(box) {\n      this.min.max(box.min);\n      this.max.min(box.max);\n      if (this.isEmpty()) this.makeEmpty();\n      return this;\n    }\n    union(box) {\n      this.min.min(box.min);\n      this.max.max(box.max);\n      return this;\n    }\n    applyMatrix4(matrix) {\n      if (this.isEmpty()) return this;\n      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      this.setFromPoints(_points);\n      return this;\n    }\n    translate(offset) {\n      this.min.add(offset);\n      this.max.add(offset);\n      return this;\n    }\n    equals(box) {\n      return box.min.equals(this.min) && box.max.equals(this.max);\n    }\n  }\n  const _points = [\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3()\n  ];\n  const _vector$b = /* @__PURE__ */ new Vector3();\n  const _box$4 = /* @__PURE__ */ new Box3();\n  const _v0$2 = /* @__PURE__ */ new Vector3();\n  const _v1$7 = /* @__PURE__ */ new Vector3();\n  const _v2$4 = /* @__PURE__ */ new Vector3();\n  const _f0 = /* @__PURE__ */ new Vector3();\n  const _f1 = /* @__PURE__ */ new Vector3();\n  const _f2 = /* @__PURE__ */ new Vector3();\n  const _center = /* @__PURE__ */ new Vector3();\n  const _extents = /* @__PURE__ */ new Vector3();\n  const _triangleNormal = /* @__PURE__ */ new Vector3();\n  const _testAxis = /* @__PURE__ */ new Vector3();\n  function satForAxes(axes, v0, v1, v2, extents) {\n    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {\n      _testAxis.fromArray(axes, i2);\n      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n      const p0 = v0.dot(_testAxis);\n      const p1 = v1.dot(_testAxis);\n      const p2 = v2.dot(_testAxis);\n      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const _box$3 = /* @__PURE__ */ new Box3();\n  const _v1$6 = /* @__PURE__ */ new Vector3();\n  const _v2$3 = /* @__PURE__ */ new Vector3();\n  class Sphere {\n    constructor(center = new Vector3(), radius = -1) {\n      this.isSphere = true;\n      this.center = center;\n      this.radius = radius;\n    }\n    set(center, radius) {\n      this.center.copy(center);\n      this.radius = radius;\n      return this;\n    }\n    setFromPoints(points, optionalCenter) {\n      const center = this.center;\n      if (optionalCenter !== void 0) {\n        center.copy(optionalCenter);\n      } else {\n        _box$3.setFromPoints(points).getCenter(center);\n      }\n      let maxRadiusSq = 0;\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));\n      }\n      this.radius = Math.sqrt(maxRadiusSq);\n      return this;\n    }\n    copy(sphere) {\n      this.center.copy(sphere.center);\n      this.radius = sphere.radius;\n      return this;\n    }\n    isEmpty() {\n      return this.radius < 0;\n    }\n    makeEmpty() {\n      this.center.set(0, 0, 0);\n      this.radius = -1;\n      return this;\n    }\n    containsPoint(point) {\n      return point.distanceToSquared(this.center) <= this.radius * this.radius;\n    }\n    distanceToPoint(point) {\n      return point.distanceTo(this.center) - this.radius;\n    }\n    intersectsSphere(sphere) {\n      const radiusSum = this.radius + sphere.radius;\n      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n    }\n    intersectsBox(box) {\n      return box.intersectsSphere(this);\n    }\n    intersectsPlane(plane) {\n      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n    }\n    clampPoint(point, target) {\n      const deltaLengthSq = this.center.distanceToSquared(point);\n      target.copy(point);\n      if (deltaLengthSq > this.radius * this.radius) {\n        target.sub(this.center).normalize();\n        target.multiplyScalar(this.radius).add(this.center);\n      }\n      return target;\n    }\n    getBoundingBox(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n        return target;\n      }\n      target.set(this.center, this.center);\n      target.expandByScalar(this.radius);\n      return target;\n    }\n    applyMatrix4(matrix) {\n      this.center.applyMatrix4(matrix);\n      this.radius = this.radius * matrix.getMaxScaleOnAxis();\n      return this;\n    }\n    translate(offset) {\n      this.center.add(offset);\n      return this;\n    }\n    expandByPoint(point) {\n      if (this.isEmpty()) {\n        this.center.copy(point);\n        this.radius = 0;\n        return this;\n      }\n      _v1$6.subVectors(point, this.center);\n      const lengthSq = _v1$6.lengthSq();\n      if (lengthSq > this.radius * this.radius) {\n        const length = Math.sqrt(lengthSq);\n        const delta = (length - this.radius) * 0.5;\n        this.center.addScaledVector(_v1$6, delta / length);\n        this.radius += delta;\n      }\n      return this;\n    }\n    union(sphere) {\n      if (sphere.isEmpty()) {\n        return this;\n      }\n      if (this.isEmpty()) {\n        this.copy(sphere);\n        return this;\n      }\n      if (this.center.equals(sphere.center) === true) {\n        this.radius = Math.max(this.radius, sphere.radius);\n      } else {\n        _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);\n        this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));\n        this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));\n      }\n      return this;\n    }\n    equals(sphere) {\n      return sphere.center.equals(this.center) && sphere.radius === this.radius;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  const _vector$a = /* @__PURE__ */ new Vector3();\n  const _segCenter = /* @__PURE__ */ new Vector3();\n  const _segDir = /* @__PURE__ */ new Vector3();\n  const _diff = /* @__PURE__ */ new Vector3();\n  const _edge1 = /* @__PURE__ */ new Vector3();\n  const _edge2 = /* @__PURE__ */ new Vector3();\n  const _normal$1 = /* @__PURE__ */ new Vector3();\n  class Ray {\n    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n      this.origin = origin;\n      this.direction = direction;\n    }\n    set(origin, direction) {\n      this.origin.copy(origin);\n      this.direction.copy(direction);\n      return this;\n    }\n    copy(ray) {\n      this.origin.copy(ray.origin);\n      this.direction.copy(ray.direction);\n      return this;\n    }\n    at(t, target) {\n      return target.copy(this.origin).addScaledVector(this.direction, t);\n    }\n    lookAt(v) {\n      this.direction.copy(v).sub(this.origin).normalize();\n      return this;\n    }\n    recast(t) {\n      this.origin.copy(this.at(t, _vector$a));\n      return this;\n    }\n    closestPointToPoint(point, target) {\n      target.subVectors(point, this.origin);\n      const directionDistance = target.dot(this.direction);\n      if (directionDistance < 0) {\n        return target.copy(this.origin);\n      }\n      return target.copy(this.origin).addScaledVector(this.direction, directionDistance);\n    }\n    distanceToPoint(point) {\n      return Math.sqrt(this.distanceSqToPoint(point));\n    }\n    distanceSqToPoint(point) {\n      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);\n      if (directionDistance < 0) {\n        return this.origin.distanceToSquared(point);\n      }\n      _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);\n      return _vector$a.distanceToSquared(point);\n    }\n    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n      _segDir.copy(v1).sub(v0).normalize();\n      _diff.copy(this.origin).sub(_segCenter);\n      const segExtent = v0.distanceTo(v1) * 0.5;\n      const a01 = -this.direction.dot(_segDir);\n      const b0 = _diff.dot(this.direction);\n      const b1 = -_diff.dot(_segDir);\n      const c = _diff.lengthSq();\n      const det = Math.abs(1 - a01 * a01);\n      let s0, s1, sqrDist, extDet;\n      if (det > 0) {\n        s0 = a01 * b1 - b0;\n        s1 = a01 * b0 - b1;\n        extDet = segExtent * det;\n        if (s0 >= 0) {\n          if (s1 >= -extDet) {\n            if (s1 <= extDet) {\n              const invDet = 1 / det;\n              s0 *= invDet;\n              s1 *= invDet;\n              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n            } else {\n              s1 = segExtent;\n              s0 = Math.max(0, -(a01 * s1 + b0));\n              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n            }\n          } else {\n            s1 = -segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          if (s1 <= -extDet) {\n            s0 = Math.max(0, -(-a01 * segExtent + b0));\n            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          } else if (s1 <= extDet) {\n            s0 = 0;\n            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = s1 * (s1 + 2 * b1) + c;\n          } else {\n            s0 = Math.max(0, -(a01 * segExtent + b0));\n            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        }\n      } else {\n        s1 = a01 > 0 ? -segExtent : segExtent;\n        s0 = Math.max(0, -(a01 * s1 + b0));\n        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n      }\n      if (optionalPointOnRay) {\n        optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);\n      }\n      if (optionalPointOnSegment) {\n        optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);\n      }\n      return sqrDist;\n    }\n    intersectSphere(sphere, target) {\n      _vector$a.subVectors(sphere.center, this.origin);\n      const tca = _vector$a.dot(this.direction);\n      const d2 = _vector$a.dot(_vector$a) - tca * tca;\n      const radius2 = sphere.radius * sphere.radius;\n      if (d2 > radius2) return null;\n      const thc = Math.sqrt(radius2 - d2);\n      const t0 = tca - thc;\n      const t1 = tca + thc;\n      if (t1 < 0) return null;\n      if (t0 < 0) return this.at(t1, target);\n      return this.at(t0, target);\n    }\n    intersectsSphere(sphere) {\n      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    distanceToPlane(plane) {\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator === 0) {\n        if (plane.distanceToPoint(this.origin) === 0) {\n          return 0;\n        }\n        return null;\n      }\n      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n      return t >= 0 ? t : null;\n    }\n    intersectPlane(plane, target) {\n      const t = this.distanceToPlane(plane);\n      if (t === null) {\n        return null;\n      }\n      return this.at(t, target);\n    }\n    intersectsPlane(plane) {\n      const distToPoint = plane.distanceToPoint(this.origin);\n      if (distToPoint === 0) {\n        return true;\n      }\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator * distToPoint < 0) {\n        return true;\n      }\n      return false;\n    }\n    intersectBox(box, target) {\n      let tmin, tmax, tymin, tymax, tzmin, tzmax;\n      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;\n      const origin = this.origin;\n      if (invdirx >= 0) {\n        tmin = (box.min.x - origin.x) * invdirx;\n        tmax = (box.max.x - origin.x) * invdirx;\n      } else {\n        tmin = (box.max.x - origin.x) * invdirx;\n        tmax = (box.min.x - origin.x) * invdirx;\n      }\n      if (invdiry >= 0) {\n        tymin = (box.min.y - origin.y) * invdiry;\n        tymax = (box.max.y - origin.y) * invdiry;\n      } else {\n        tymin = (box.max.y - origin.y) * invdiry;\n        tymax = (box.min.y - origin.y) * invdiry;\n      }\n      if (tmin > tymax || tymin > tmax) return null;\n      if (tymin > tmin || isNaN(tmin)) tmin = tymin;\n      if (tymax < tmax || isNaN(tmax)) tmax = tymax;\n      if (invdirz >= 0) {\n        tzmin = (box.min.z - origin.z) * invdirz;\n        tzmax = (box.max.z - origin.z) * invdirz;\n      } else {\n        tzmin = (box.max.z - origin.z) * invdirz;\n        tzmax = (box.min.z - origin.z) * invdirz;\n      }\n      if (tmin > tzmax || tzmin > tmax) return null;\n      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n      if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n      if (tmax < 0) return null;\n      return this.at(tmin >= 0 ? tmin : tmax, target);\n    }\n    intersectsBox(box) {\n      return this.intersectBox(box, _vector$a) !== null;\n    }\n    intersectTriangle(a, b, c, backfaceCulling, target) {\n      _edge1.subVectors(b, a);\n      _edge2.subVectors(c, a);\n      _normal$1.crossVectors(_edge1, _edge2);\n      let DdN = this.direction.dot(_normal$1);\n      let sign;\n      if (DdN > 0) {\n        if (backfaceCulling) return null;\n        sign = 1;\n      } else if (DdN < 0) {\n        sign = -1;\n        DdN = -DdN;\n      } else {\n        return null;\n      }\n      _diff.subVectors(this.origin, a);\n      const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n      if (DdQxE2 < 0) {\n        return null;\n      }\n      const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));\n      if (DdE1xQ < 0) {\n        return null;\n      }\n      if (DdQxE2 + DdE1xQ > DdN) {\n        return null;\n      }\n      const QdN = -sign * _diff.dot(_normal$1);\n      if (QdN < 0) {\n        return null;\n      }\n      return this.at(QdN / DdN, target);\n    }\n    applyMatrix4(matrix4) {\n      this.origin.applyMatrix4(matrix4);\n      this.direction.transformDirection(matrix4);\n      return this;\n    }\n    equals(ray) {\n      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class Matrix4 {\n    constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      Matrix4.prototype.isMatrix4 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);\n      }\n    }\n    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      const te = this.elements;\n      te[0] = n11;\n      te[4] = n12;\n      te[8] = n13;\n      te[12] = n14;\n      te[1] = n21;\n      te[5] = n22;\n      te[9] = n23;\n      te[13] = n24;\n      te[2] = n31;\n      te[6] = n32;\n      te[10] = n33;\n      te[14] = n34;\n      te[3] = n41;\n      te[7] = n42;\n      te[11] = n43;\n      te[15] = n44;\n      return this;\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    clone() {\n      return new Matrix4().fromArray(this.elements);\n    }\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      te[9] = me[9];\n      te[10] = me[10];\n      te[11] = me[11];\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      te[15] = me[15];\n      return this;\n    }\n    copyPosition(m) {\n      const te = this.elements, me = m.elements;\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      return this;\n    }\n    setFromMatrix3(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[3],\n        me[6],\n        0,\n        me[1],\n        me[4],\n        me[7],\n        0,\n        me[2],\n        me[5],\n        me[8],\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrixColumn(this, 0);\n      yAxis.setFromMatrixColumn(this, 1);\n      zAxis.setFromMatrixColumn(this, 2);\n      return this;\n    }\n    makeBasis(xAxis, yAxis, zAxis) {\n      this.set(\n        xAxis.x,\n        yAxis.x,\n        zAxis.x,\n        0,\n        xAxis.y,\n        yAxis.y,\n        zAxis.y,\n        0,\n        xAxis.z,\n        yAxis.z,\n        zAxis.z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    extractRotation(m) {\n      const te = this.elements;\n      const me = m.elements;\n      const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n      const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n      te[0] = me[0] * scaleX;\n      te[1] = me[1] * scaleX;\n      te[2] = me[2] * scaleX;\n      te[3] = 0;\n      te[4] = me[4] * scaleY;\n      te[5] = me[5] * scaleY;\n      te[6] = me[6] * scaleY;\n      te[7] = 0;\n      te[8] = me[8] * scaleZ;\n      te[9] = me[9] * scaleZ;\n      te[10] = me[10] * scaleZ;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    makeRotationFromEuler(euler) {\n      const te = this.elements;\n      const x2 = euler.x, y = euler.y, z = euler.z;\n      const a = Math.cos(x2), b = Math.sin(x2);\n      const c = Math.cos(y), d = Math.sin(y);\n      const e = Math.cos(z), f = Math.sin(z);\n      if (euler.order === "XYZ") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = -c * f;\n        te[8] = d;\n        te[1] = af + be * d;\n        te[5] = ae - bf * d;\n        te[9] = -b * c;\n        te[2] = bf - ae * d;\n        te[6] = be + af * d;\n        te[10] = a * c;\n      } else if (euler.order === "YXZ") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce + df * b;\n        te[4] = de * b - cf;\n        te[8] = a * d;\n        te[1] = a * f;\n        te[5] = a * e;\n        te[9] = -b;\n        te[2] = cf * b - de;\n        te[6] = df + ce * b;\n        te[10] = a * c;\n      } else if (euler.order === "ZXY") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce - df * b;\n        te[4] = -a * f;\n        te[8] = de + cf * b;\n        te[1] = cf + de * b;\n        te[5] = a * e;\n        te[9] = df - ce * b;\n        te[2] = -a * d;\n        te[6] = b;\n        te[10] = a * c;\n      } else if (euler.order === "ZYX") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = be * d - af;\n        te[8] = ae * d + bf;\n        te[1] = c * f;\n        te[5] = bf * d + ae;\n        te[9] = af * d - be;\n        te[2] = -d;\n        te[6] = b * c;\n        te[10] = a * c;\n      } else if (euler.order === "YZX") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = bd - ac * f;\n        te[8] = bc * f + ad;\n        te[1] = f;\n        te[5] = a * e;\n        te[9] = -b * e;\n        te[2] = -d * e;\n        te[6] = ad * f + bc;\n        te[10] = ac - bd * f;\n      } else if (euler.order === "XZY") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = -f;\n        te[8] = d * e;\n        te[1] = ac * f + bd;\n        te[5] = a * e;\n        te[9] = ad * f - bc;\n        te[2] = bc * f - ad;\n        te[6] = b * e;\n        te[10] = bd * f + ac;\n      }\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    makeRotationFromQuaternion(q) {\n      return this.compose(_zero, q, _one);\n    }\n    lookAt(eye, target, up) {\n      const te = this.elements;\n      _z.subVectors(eye, target);\n      if (_z.lengthSq() === 0) {\n        _z.z = 1;\n      }\n      _z.normalize();\n      _x.crossVectors(up, _z);\n      if (_x.lengthSq() === 0) {\n        if (Math.abs(up.z) === 1) {\n          _z.x += 1e-4;\n        } else {\n          _z.z += 1e-4;\n        }\n        _z.normalize();\n        _x.crossVectors(up, _z);\n      }\n      _x.normalize();\n      _y.crossVectors(_z, _x);\n      te[0] = _x.x;\n      te[4] = _y.x;\n      te[8] = _z.x;\n      te[1] = _x.y;\n      te[5] = _y.y;\n      te[9] = _z.y;\n      te[2] = _x.z;\n      te[6] = _y.z;\n      te[10] = _z.z;\n      return this;\n    }\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n      return this;\n    }\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[4] *= s;\n      te[8] *= s;\n      te[12] *= s;\n      te[1] *= s;\n      te[5] *= s;\n      te[9] *= s;\n      te[13] *= s;\n      te[2] *= s;\n      te[6] *= s;\n      te[10] *= s;\n      te[14] *= s;\n      te[3] *= s;\n      te[7] *= s;\n      te[11] *= s;\n      te[15] *= s;\n      return this;\n    }\n    determinant() {\n      const te = this.elements;\n      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n    }\n    transpose() {\n      const te = this.elements;\n      let tmp;\n      tmp = te[1];\n      te[1] = te[4];\n      te[4] = tmp;\n      tmp = te[2];\n      te[2] = te[8];\n      te[8] = tmp;\n      tmp = te[6];\n      te[6] = te[9];\n      te[9] = tmp;\n      tmp = te[3];\n      te[3] = te[12];\n      te[12] = tmp;\n      tmp = te[7];\n      te[7] = te[13];\n      te[13] = tmp;\n      tmp = te[11];\n      te[11] = te[14];\n      te[14] = tmp;\n      return this;\n    }\n    setPosition(x2, y, z) {\n      const te = this.elements;\n      if (x2.isVector3) {\n        te[12] = x2.x;\n        te[13] = x2.y;\n        te[14] = x2.z;\n      } else {\n        te[12] = x2;\n        te[13] = y;\n        te[14] = z;\n      }\n      return this;\n    }\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n      te[4] = t12 * detInv;\n      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n      te[8] = t13 * detInv;\n      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n      te[12] = t14 * detInv;\n      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n      return this;\n    }\n    scale(v) {\n      const te = this.elements;\n      const x2 = v.x, y = v.y, z = v.z;\n      te[0] *= x2;\n      te[4] *= y;\n      te[8] *= z;\n      te[1] *= x2;\n      te[5] *= y;\n      te[9] *= z;\n      te[2] *= x2;\n      te[6] *= y;\n      te[10] *= z;\n      te[3] *= x2;\n      te[7] *= y;\n      te[11] *= z;\n      return this;\n    }\n    getMaxScaleOnAxis() {\n      const te = this.elements;\n      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n    }\n    makeTranslation(x2, y, z) {\n      if (x2.isVector3) {\n        this.set(\n          1,\n          0,\n          0,\n          x2.x,\n          0,\n          1,\n          0,\n          x2.y,\n          0,\n          0,\n          1,\n          x2.z,\n          0,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          0,\n          x2,\n          0,\n          1,\n          0,\n          y,\n          0,\n          0,\n          1,\n          z,\n          0,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    makeRotationX(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationY(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        0,\n        s,\n        0,\n        0,\n        1,\n        0,\n        0,\n        -s,\n        0,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationZ(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationAxis(axis, angle) {\n      const c = Math.cos(angle);\n      const s = Math.sin(angle);\n      const t = 1 - c;\n      const x2 = axis.x, y = axis.y, z = axis.z;\n      const tx = t * x2, ty = t * y;\n      this.set(\n        tx * x2 + c,\n        tx * y - s * z,\n        tx * z + s * y,\n        0,\n        tx * y + s * z,\n        ty * y + c,\n        ty * z - s * x2,\n        0,\n        tx * z - s * y,\n        ty * z + s * x2,\n        t * z * z + c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeScale(x2, y, z) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        0,\n        z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeShear(xy, xz, yx, yz, zx, zy) {\n      this.set(\n        1,\n        yx,\n        zx,\n        0,\n        xy,\n        1,\n        zy,\n        0,\n        xz,\n        yz,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    compose(position, quaternion, scale) {\n      const te = this.elements;\n      const x2 = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n      const x22 = x2 + x2, y2 = y + y, z2 = z + z;\n      const xx = x2 * x22, xy = x2 * y2, xz = x2 * z2;\n      const yy = y * y2, yz = y * z2, zz = z * z2;\n      const wx = w * x22, wy = w * y2, wz = w * z2;\n      const sx = scale.x, sy = scale.y, sz = scale.z;\n      te[0] = (1 - (yy + zz)) * sx;\n      te[1] = (xy + wz) * sx;\n      te[2] = (xz - wy) * sx;\n      te[3] = 0;\n      te[4] = (xy - wz) * sy;\n      te[5] = (1 - (xx + zz)) * sy;\n      te[6] = (yz + wx) * sy;\n      te[7] = 0;\n      te[8] = (xz + wy) * sz;\n      te[9] = (yz - wx) * sz;\n      te[10] = (1 - (xx + yy)) * sz;\n      te[11] = 0;\n      te[12] = position.x;\n      te[13] = position.y;\n      te[14] = position.z;\n      te[15] = 1;\n      return this;\n    }\n    decompose(position, quaternion, scale) {\n      const te = this.elements;\n      let sx = _v1$5.set(te[0], te[1], te[2]).length();\n      const sy = _v1$5.set(te[4], te[5], te[6]).length();\n      const sz = _v1$5.set(te[8], te[9], te[10]).length();\n      const det = this.determinant();\n      if (det < 0) sx = -sx;\n      position.x = te[12];\n      position.y = te[13];\n      position.z = te[14];\n      _m1$2.copy(this);\n      const invSX = 1 / sx;\n      const invSY = 1 / sy;\n      const invSZ = 1 / sz;\n      _m1$2.elements[0] *= invSX;\n      _m1$2.elements[1] *= invSX;\n      _m1$2.elements[2] *= invSX;\n      _m1$2.elements[4] *= invSY;\n      _m1$2.elements[5] *= invSY;\n      _m1$2.elements[6] *= invSY;\n      _m1$2.elements[8] *= invSZ;\n      _m1$2.elements[9] *= invSZ;\n      _m1$2.elements[10] *= invSZ;\n      quaternion.setFromRotationMatrix(_m1$2);\n      scale.x = sx;\n      scale.y = sy;\n      scale.z = sz;\n      return this;\n    }\n    makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n      const te = this.elements;\n      const x2 = 2 * near / (right - left);\n      const y = 2 * near / (top - bottom);\n      const a = (right + left) / (right - left);\n      const b = (top + bottom) / (top - bottom);\n      let c, d;\n      if (coordinateSystem === WebGLCoordinateSystem) {\n        c = -(far + near) / (far - near);\n        d = -2 * far * near / (far - near);\n      } else if (coordinateSystem === WebGPUCoordinateSystem) {\n        c = -far / (far - near);\n        d = -far * near / (far - near);\n      } else {\n        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);\n      }\n      te[0] = x2;\n      te[4] = 0;\n      te[8] = a;\n      te[12] = 0;\n      te[1] = 0;\n      te[5] = y;\n      te[9] = b;\n      te[13] = 0;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = c;\n      te[14] = d;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = -1;\n      te[15] = 0;\n      return this;\n    }\n    makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n      const te = this.elements;\n      const w = 1 / (right - left);\n      const h = 1 / (top - bottom);\n      const p = 1 / (far - near);\n      const x2 = (right + left) * w;\n      const y = (top + bottom) * h;\n      let z, zInv;\n      if (coordinateSystem === WebGLCoordinateSystem) {\n        z = (far + near) * p;\n        zInv = -2 * p;\n      } else if (coordinateSystem === WebGPUCoordinateSystem) {\n        z = near * p;\n        zInv = -1 * p;\n      } else {\n        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);\n      }\n      te[0] = 2 * w;\n      te[4] = 0;\n      te[8] = 0;\n      te[12] = -x2;\n      te[1] = 0;\n      te[5] = 2 * h;\n      te[9] = 0;\n      te[13] = -y;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = zInv;\n      te[14] = -z;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[15] = 1;\n      return this;\n    }\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 16; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 16; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      array[offset + 9] = te[9];\n      array[offset + 10] = te[10];\n      array[offset + 11] = te[11];\n      array[offset + 12] = te[12];\n      array[offset + 13] = te[13];\n      array[offset + 14] = te[14];\n      array[offset + 15] = te[15];\n      return array;\n    }\n  }\n  const _v1$5 = /* @__PURE__ */ new Vector3();\n  const _m1$2 = /* @__PURE__ */ new Matrix4();\n  const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);\n  const _one = /* @__PURE__ */ new Vector3(1, 1, 1);\n  const _x = /* @__PURE__ */ new Vector3();\n  const _y = /* @__PURE__ */ new Vector3();\n  const _z = /* @__PURE__ */ new Vector3();\n  const _matrix$2 = /* @__PURE__ */ new Matrix4();\n  const _quaternion$3 = /* @__PURE__ */ new Quaternion();\n  class Euler {\n    constructor(x2 = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {\n      this.isEuler = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n    }\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    get order() {\n      return this._order;\n    }\n    set order(value) {\n      this._order = value;\n      this._onChangeCallback();\n    }\n    set(x2, y, z, order = this._order) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n      this._onChangeCallback();\n      return this;\n    }\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._order);\n    }\n    copy(euler) {\n      this._x = euler._x;\n      this._y = euler._y;\n      this._z = euler._z;\n      this._order = euler._order;\n      this._onChangeCallback();\n      return this;\n    }\n    setFromRotationMatrix(m, order = this._order, update = true) {\n      const te = m.elements;\n      const m11 = te[0], m12 = te[4], m13 = te[8];\n      const m21 = te[1], m22 = te[5], m23 = te[9];\n      const m31 = te[2], m32 = te[6], m33 = te[10];\n      switch (order) {\n        case "XYZ":\n          this._y = Math.asin(clamp(m13, -1, 1));\n          if (Math.abs(m13) < 0.9999999) {\n            this._x = Math.atan2(-m23, m33);\n            this._z = Math.atan2(-m12, m11);\n          } else {\n            this._x = Math.atan2(m32, m22);\n            this._z = 0;\n          }\n          break;\n        case "YXZ":\n          this._x = Math.asin(-clamp(m23, -1, 1));\n          if (Math.abs(m23) < 0.9999999) {\n            this._y = Math.atan2(m13, m33);\n            this._z = Math.atan2(m21, m22);\n          } else {\n            this._y = Math.atan2(-m31, m11);\n            this._z = 0;\n          }\n          break;\n        case "ZXY":\n          this._x = Math.asin(clamp(m32, -1, 1));\n          if (Math.abs(m32) < 0.9999999) {\n            this._y = Math.atan2(-m31, m33);\n            this._z = Math.atan2(-m12, m22);\n          } else {\n            this._y = 0;\n            this._z = Math.atan2(m21, m11);\n          }\n          break;\n        case "ZYX":\n          this._y = Math.asin(-clamp(m31, -1, 1));\n          if (Math.abs(m31) < 0.9999999) {\n            this._x = Math.atan2(m32, m33);\n            this._z = Math.atan2(m21, m11);\n          } else {\n            this._x = 0;\n            this._z = Math.atan2(-m12, m22);\n          }\n          break;\n        case "YZX":\n          this._z = Math.asin(clamp(m21, -1, 1));\n          if (Math.abs(m21) < 0.9999999) {\n            this._x = Math.atan2(-m23, m22);\n            this._y = Math.atan2(-m31, m11);\n          } else {\n            this._x = 0;\n            this._y = Math.atan2(m13, m33);\n          }\n          break;\n        case "XZY":\n          this._z = Math.asin(-clamp(m12, -1, 1));\n          if (Math.abs(m12) < 0.9999999) {\n            this._x = Math.atan2(m32, m22);\n            this._y = Math.atan2(m13, m11);\n          } else {\n            this._x = Math.atan2(-m23, m33);\n            this._y = 0;\n          }\n          break;\n        default:\n          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);\n      }\n      this._order = order;\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    setFromQuaternion(q, order, update) {\n      _matrix$2.makeRotationFromQuaternion(q);\n      return this.setFromRotationMatrix(_matrix$2, order, update);\n    }\n    setFromVector3(v, order = this._order) {\n      return this.set(v.x, v.y, v.z, order);\n    }\n    reorder(newOrder) {\n      _quaternion$3.setFromEuler(this);\n      return this.setFromQuaternion(_quaternion$3, newOrder);\n    }\n    equals(euler) {\n      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n    }\n    fromArray(array) {\n      this._x = array[0];\n      this._y = array[1];\n      this._z = array[2];\n      if (array[3] !== void 0) this._order = array[3];\n      this._onChangeCallback();\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._order;\n      return array;\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._order;\n    }\n  }\n  Euler.DEFAULT_ORDER = "XYZ";\n  class Layers {\n    constructor() {\n      this.mask = 1 | 0;\n    }\n    set(channel) {\n      this.mask = (1 << channel | 0) >>> 0;\n    }\n    enable(channel) {\n      this.mask |= 1 << channel | 0;\n    }\n    enableAll() {\n      this.mask = 4294967295 | 0;\n    }\n    toggle(channel) {\n      this.mask ^= 1 << channel | 0;\n    }\n    disable(channel) {\n      this.mask &= ~(1 << channel | 0);\n    }\n    disableAll() {\n      this.mask = 0;\n    }\n    test(layers) {\n      return (this.mask & layers.mask) !== 0;\n    }\n    isEnabled(channel) {\n      return (this.mask & (1 << channel | 0)) !== 0;\n    }\n  }\n  let _object3DId = 0;\n  const _v1$4 = /* @__PURE__ */ new Vector3();\n  const _q1 = /* @__PURE__ */ new Quaternion();\n  const _m1$1 = /* @__PURE__ */ new Matrix4();\n  const _target = /* @__PURE__ */ new Vector3();\n  const _position$3 = /* @__PURE__ */ new Vector3();\n  const _scale$2 = /* @__PURE__ */ new Vector3();\n  const _quaternion$2 = /* @__PURE__ */ new Quaternion();\n  const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);\n  const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);\n  const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);\n  const _addedEvent = { type: "added" };\n  const _removedEvent = { type: "removed" };\n  const _childaddedEvent = { type: "childadded", child: null };\n  const _childremovedEvent = { type: "childremoved", child: null };\n  class Object3D extends EventDispatcher {\n    constructor() {\n      super();\n      this.isObject3D = true;\n      Object.defineProperty(this, "id", { value: _object3DId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "Object3D";\n      this.parent = null;\n      this.children = [];\n      this.up = Object3D.DEFAULT_UP.clone();\n      const position = new Vector3();\n      const rotation = new Euler();\n      const quaternion = new Quaternion();\n      const scale = new Vector3(1, 1, 1);\n      function onRotationChange() {\n        quaternion.setFromEuler(rotation, false);\n      }\n      function onQuaternionChange() {\n        rotation.setFromQuaternion(quaternion, void 0, false);\n      }\n      rotation._onChange(onRotationChange);\n      quaternion._onChange(onQuaternionChange);\n      Object.defineProperties(this, {\n        position: {\n          configurable: true,\n          enumerable: true,\n          value: position\n        },\n        rotation: {\n          configurable: true,\n          enumerable: true,\n          value: rotation\n        },\n        quaternion: {\n          configurable: true,\n          enumerable: true,\n          value: quaternion\n        },\n        scale: {\n          configurable: true,\n          enumerable: true,\n          value: scale\n        },\n        modelViewMatrix: {\n          value: new Matrix4()\n        },\n        normalMatrix: {\n          value: new Matrix3()\n        }\n      });\n      this.matrix = new Matrix4();\n      this.matrixWorld = new Matrix4();\n      this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n      this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;\n      this.matrixWorldNeedsUpdate = false;\n      this.layers = new Layers();\n      this.visible = true;\n      this.castShadow = false;\n      this.receiveShadow = false;\n      this.frustumCulled = true;\n      this.renderOrder = 0;\n      this.animations = [];\n      this.userData = {};\n    }\n    onBeforeShadow() {\n    }\n    onAfterShadow() {\n    }\n    onBeforeRender() {\n    }\n    onAfterRender() {\n    }\n    applyMatrix4(matrix) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      this.matrix.premultiply(matrix);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n    }\n    applyQuaternion(q) {\n      this.quaternion.premultiply(q);\n      return this;\n    }\n    setRotationFromAxisAngle(axis, angle) {\n      this.quaternion.setFromAxisAngle(axis, angle);\n    }\n    setRotationFromEuler(euler) {\n      this.quaternion.setFromEuler(euler, true);\n    }\n    setRotationFromMatrix(m) {\n      this.quaternion.setFromRotationMatrix(m);\n    }\n    setRotationFromQuaternion(q) {\n      this.quaternion.copy(q);\n    }\n    rotateOnAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.multiply(_q1);\n      return this;\n    }\n    rotateOnWorldAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.premultiply(_q1);\n      return this;\n    }\n    rotateX(angle) {\n      return this.rotateOnAxis(_xAxis, angle);\n    }\n    rotateY(angle) {\n      return this.rotateOnAxis(_yAxis, angle);\n    }\n    rotateZ(angle) {\n      return this.rotateOnAxis(_zAxis, angle);\n    }\n    translateOnAxis(axis, distance) {\n      _v1$4.copy(axis).applyQuaternion(this.quaternion);\n      this.position.add(_v1$4.multiplyScalar(distance));\n      return this;\n    }\n    translateX(distance) {\n      return this.translateOnAxis(_xAxis, distance);\n    }\n    translateY(distance) {\n      return this.translateOnAxis(_yAxis, distance);\n    }\n    translateZ(distance) {\n      return this.translateOnAxis(_zAxis, distance);\n    }\n    localToWorld(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(this.matrixWorld);\n    }\n    worldToLocal(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n    }\n    lookAt(x2, y, z) {\n      if (x2.isVector3) {\n        _target.copy(x2);\n      } else {\n        _target.set(x2, y, z);\n      }\n      const parent = this.parent;\n      this.updateWorldMatrix(true, false);\n      _position$3.setFromMatrixPosition(this.matrixWorld);\n      if (this.isCamera || this.isLight) {\n        _m1$1.lookAt(_position$3, _target, this.up);\n      } else {\n        _m1$1.lookAt(_target, _position$3, this.up);\n      }\n      this.quaternion.setFromRotationMatrix(_m1$1);\n      if (parent) {\n        _m1$1.extractRotation(parent.matrixWorld);\n        _q1.setFromRotationMatrix(_m1$1);\n        this.quaternion.premultiply(_q1.invert());\n      }\n    }\n    add(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.add(arguments[i2]);\n        }\n        return this;\n      }\n      if (object === this) {\n        console.error("THREE.Object3D.add: object can\'t be added as a child of itself.", object);\n        return this;\n      }\n      if (object && object.isObject3D) {\n        object.removeFromParent();\n        object.parent = this;\n        this.children.push(object);\n        object.dispatchEvent(_addedEvent);\n        _childaddedEvent.child = object;\n        this.dispatchEvent(_childaddedEvent);\n        _childaddedEvent.child = null;\n      } else {\n        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);\n      }\n      return this;\n    }\n    remove(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.remove(arguments[i2]);\n        }\n        return this;\n      }\n      const index = this.children.indexOf(object);\n      if (index !== -1) {\n        object.parent = null;\n        this.children.splice(index, 1);\n        object.dispatchEvent(_removedEvent);\n        _childremovedEvent.child = object;\n        this.dispatchEvent(_childremovedEvent);\n        _childremovedEvent.child = null;\n      }\n      return this;\n    }\n    removeFromParent() {\n      const parent = this.parent;\n      if (parent !== null) {\n        parent.remove(this);\n      }\n      return this;\n    }\n    clear() {\n      return this.remove(...this.children);\n    }\n    attach(object) {\n      this.updateWorldMatrix(true, false);\n      _m1$1.copy(this.matrixWorld).invert();\n      if (object.parent !== null) {\n        object.parent.updateWorldMatrix(true, false);\n        _m1$1.multiply(object.parent.matrixWorld);\n      }\n      object.applyMatrix4(_m1$1);\n      object.removeFromParent();\n      object.parent = this;\n      this.children.push(object);\n      object.updateWorldMatrix(false, true);\n      object.dispatchEvent(_addedEvent);\n      _childaddedEvent.child = object;\n      this.dispatchEvent(_childaddedEvent);\n      _childaddedEvent.child = null;\n      return this;\n    }\n    getObjectById(id) {\n      return this.getObjectByProperty("id", id);\n    }\n    getObjectByName(name) {\n      return this.getObjectByProperty("name", name);\n    }\n    getObjectByProperty(name, value) {\n      if (this[name] === value) return this;\n      for (let i2 = 0, l = this.children.length; i2 < l; i2++) {\n        const child = this.children[i2];\n        const object = child.getObjectByProperty(name, value);\n        if (object !== void 0) {\n          return object;\n        }\n      }\n      return void 0;\n    }\n    getObjectsByProperty(name, value, result = []) {\n      if (this[name] === value) result.push(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].getObjectsByProperty(name, value, result);\n      }\n      return result;\n    }\n    getWorldPosition(target) {\n      this.updateWorldMatrix(true, false);\n      return target.setFromMatrixPosition(this.matrixWorld);\n    }\n    getWorldQuaternion(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, target, _scale$2);\n      return target;\n    }\n    getWorldScale(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n      return target;\n    }\n    getWorldDirection(target) {\n      this.updateWorldMatrix(true, false);\n      const e = this.matrixWorld.elements;\n      return target.set(e[8], e[9], e[10]).normalize();\n    }\n    raycast() {\n    }\n    traverse(callback) {\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverse(callback);\n      }\n    }\n    traverseVisible(callback) {\n      if (this.visible === false) return;\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverseVisible(callback);\n      }\n    }\n    traverseAncestors(callback) {\n      const parent = this.parent;\n      if (parent !== null) {\n        callback(parent);\n        parent.traverseAncestors(callback);\n      }\n    }\n    updateMatrix() {\n      this.matrix.compose(this.position, this.quaternion, this.scale);\n      this.matrixWorldNeedsUpdate = true;\n    }\n    updateMatrixWorld(force) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldNeedsUpdate || force) {\n        if (this.matrixWorldAutoUpdate === true) {\n          if (this.parent === null) {\n            this.matrixWorld.copy(this.matrix);\n          } else {\n            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n          }\n        }\n        this.matrixWorldNeedsUpdate = false;\n        force = true;\n      }\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        const child = children[i2];\n        child.updateMatrixWorld(force);\n      }\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n      const parent = this.parent;\n      if (updateParents === true && parent !== null) {\n        parent.updateWorldMatrix(true, false);\n      }\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldAutoUpdate === true) {\n        if (this.parent === null) {\n          this.matrixWorld.copy(this.matrix);\n        } else {\n          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        }\n      }\n      if (updateChildren === true) {\n        const children = this.children;\n        for (let i2 = 0, l = children.length; i2 < l; i2++) {\n          const child = children[i2];\n          child.updateWorldMatrix(false, true);\n        }\n      }\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      const output = {};\n      if (isRootObject) {\n        meta = {\n          geometries: {},\n          materials: {},\n          textures: {},\n          images: {},\n          shapes: {},\n          skeletons: {},\n          animations: {},\n          nodes: {}\n        };\n        output.metadata = {\n          version: 4.6,\n          type: "Object",\n          generator: "Object3D.toJSON"\n        };\n      }\n      const object = {};\n      object.uuid = this.uuid;\n      object.type = this.type;\n      if (this.name !== "") object.name = this.name;\n      if (this.castShadow === true) object.castShadow = true;\n      if (this.receiveShadow === true) object.receiveShadow = true;\n      if (this.visible === false) object.visible = false;\n      if (this.frustumCulled === false) object.frustumCulled = false;\n      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n      if (Object.keys(this.userData).length > 0) object.userData = this.userData;\n      object.layers = this.layers.mask;\n      object.matrix = this.matrix.toArray();\n      object.up = this.up.toArray();\n      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n      if (this.isInstancedMesh) {\n        object.type = "InstancedMesh";\n        object.count = this.count;\n        object.instanceMatrix = this.instanceMatrix.toJSON();\n        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n      }\n      if (this.isBatchedMesh) {\n        object.type = "BatchedMesh";\n        object.perObjectFrustumCulled = this.perObjectFrustumCulled;\n        object.sortObjects = this.sortObjects;\n        object.drawRanges = this._drawRanges;\n        object.reservedRanges = this._reservedRanges;\n        object.visibility = this._visibility;\n        object.active = this._active;\n        object.bounds = this._bounds.map((bound) => ({\n          boxInitialized: bound.boxInitialized,\n          boxMin: bound.box.min.toArray(),\n          boxMax: bound.box.max.toArray(),\n          sphereInitialized: bound.sphereInitialized,\n          sphereRadius: bound.sphere.radius,\n          sphereCenter: bound.sphere.center.toArray()\n        }));\n        object.maxInstanceCount = this._maxInstanceCount;\n        object.maxVertexCount = this._maxVertexCount;\n        object.maxIndexCount = this._maxIndexCount;\n        object.geometryInitialized = this._geometryInitialized;\n        object.geometryCount = this._geometryCount;\n        object.matricesTexture = this._matricesTexture.toJSON(meta);\n        if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);\n        if (this.boundingSphere !== null) {\n          object.boundingSphere = {\n            center: object.boundingSphere.center.toArray(),\n            radius: object.boundingSphere.radius\n          };\n        }\n        if (this.boundingBox !== null) {\n          object.boundingBox = {\n            min: object.boundingBox.min.toArray(),\n            max: object.boundingBox.max.toArray()\n          };\n        }\n      }\n      function serialize(library, element) {\n        if (library[element.uuid] === void 0) {\n          library[element.uuid] = element.toJSON(meta);\n        }\n        return element.uuid;\n      }\n      if (this.isScene) {\n        if (this.background) {\n          if (this.background.isColor) {\n            object.background = this.background.toJSON();\n          } else if (this.background.isTexture) {\n            object.background = this.background.toJSON(meta).uuid;\n          }\n        }\n        if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {\n          object.environment = this.environment.toJSON(meta).uuid;\n        }\n      } else if (this.isMesh || this.isLine || this.isPoints) {\n        object.geometry = serialize(meta.geometries, this.geometry);\n        const parameters = this.geometry.parameters;\n        if (parameters !== void 0 && parameters.shapes !== void 0) {\n          const shapes = parameters.shapes;\n          if (Array.isArray(shapes)) {\n            for (let i2 = 0, l = shapes.length; i2 < l; i2++) {\n              const shape = shapes[i2];\n              serialize(meta.shapes, shape);\n            }\n          } else {\n            serialize(meta.shapes, shapes);\n          }\n        }\n      }\n      if (this.isSkinnedMesh) {\n        object.bindMode = this.bindMode;\n        object.bindMatrix = this.bindMatrix.toArray();\n        if (this.skeleton !== void 0) {\n          serialize(meta.skeletons, this.skeleton);\n          object.skeleton = this.skeleton.uuid;\n        }\n      }\n      if (this.material !== void 0) {\n        if (Array.isArray(this.material)) {\n          const uuids = [];\n          for (let i2 = 0, l = this.material.length; i2 < l; i2++) {\n            uuids.push(serialize(meta.materials, this.material[i2]));\n          }\n          object.material = uuids;\n        } else {\n          object.material = serialize(meta.materials, this.material);\n        }\n      }\n      if (this.children.length > 0) {\n        object.children = [];\n        for (let i2 = 0; i2 < this.children.length; i2++) {\n          object.children.push(this.children[i2].toJSON(meta).object);\n        }\n      }\n      if (this.animations.length > 0) {\n        object.animations = [];\n        for (let i2 = 0; i2 < this.animations.length; i2++) {\n          const animation = this.animations[i2];\n          object.animations.push(serialize(meta.animations, animation));\n        }\n      }\n      if (isRootObject) {\n        const geometries = extractFromCache(meta.geometries);\n        const materials = extractFromCache(meta.materials);\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        const shapes = extractFromCache(meta.shapes);\n        const skeletons = extractFromCache(meta.skeletons);\n        const animations = extractFromCache(meta.animations);\n        const nodes = extractFromCache(meta.nodes);\n        if (geometries.length > 0) output.geometries = geometries;\n        if (materials.length > 0) output.materials = materials;\n        if (textures.length > 0) output.textures = textures;\n        if (images.length > 0) output.images = images;\n        if (shapes.length > 0) output.shapes = shapes;\n        if (skeletons.length > 0) output.skeletons = skeletons;\n        if (animations.length > 0) output.animations = animations;\n        if (nodes.length > 0) output.nodes = nodes;\n      }\n      output.object = object;\n      return output;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data = cache[key];\n          delete data.metadata;\n          values.push(data);\n        }\n        return values;\n      }\n    }\n    clone(recursive) {\n      return new this.constructor().copy(this, recursive);\n    }\n    copy(source, recursive = true) {\n      this.name = source.name;\n      this.up.copy(source.up);\n      this.position.copy(source.position);\n      this.rotation.order = source.rotation.order;\n      this.quaternion.copy(source.quaternion);\n      this.scale.copy(source.scale);\n      this.matrix.copy(source.matrix);\n      this.matrixWorld.copy(source.matrixWorld);\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n      this.layers.mask = source.layers.mask;\n      this.visible = source.visible;\n      this.castShadow = source.castShadow;\n      this.receiveShadow = source.receiveShadow;\n      this.frustumCulled = source.frustumCulled;\n      this.renderOrder = source.renderOrder;\n      this.animations = source.animations.slice();\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      if (recursive === true) {\n        for (let i2 = 0; i2 < source.children.length; i2++) {\n          const child = source.children[i2];\n          this.add(child.clone());\n        }\n      }\n      return this;\n    }\n  }\n  Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);\n  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\n  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n  const _v0$1 = /* @__PURE__ */ new Vector3();\n  const _v1$3 = /* @__PURE__ */ new Vector3();\n  const _v2$2 = /* @__PURE__ */ new Vector3();\n  const _v3$2 = /* @__PURE__ */ new Vector3();\n  const _vab = /* @__PURE__ */ new Vector3();\n  const _vac = /* @__PURE__ */ new Vector3();\n  const _vbc = /* @__PURE__ */ new Vector3();\n  const _vap = /* @__PURE__ */ new Vector3();\n  const _vbp = /* @__PURE__ */ new Vector3();\n  const _vcp = /* @__PURE__ */ new Vector3();\n  const _v40 = /* @__PURE__ */ new Vector4();\n  const _v41 = /* @__PURE__ */ new Vector4();\n  const _v42 = /* @__PURE__ */ new Vector4();\n  class Triangle {\n    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n    static getNormal(a, b, c, target) {\n      target.subVectors(c, b);\n      _v0$1.subVectors(a, b);\n      target.cross(_v0$1);\n      const targetLengthSq = target.lengthSq();\n      if (targetLengthSq > 0) {\n        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n      }\n      return target.set(0, 0, 0);\n    }\n    // static/instance method to calculate barycentric coordinates\n    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n    static getBarycoord(point, a, b, c, target) {\n      _v0$1.subVectors(c, a);\n      _v1$3.subVectors(b, a);\n      _v2$2.subVectors(point, a);\n      const dot00 = _v0$1.dot(_v0$1);\n      const dot01 = _v0$1.dot(_v1$3);\n      const dot02 = _v0$1.dot(_v2$2);\n      const dot11 = _v1$3.dot(_v1$3);\n      const dot12 = _v1$3.dot(_v2$2);\n      const denom = dot00 * dot11 - dot01 * dot01;\n      if (denom === 0) {\n        target.set(0, 0, 0);\n        return null;\n      }\n      const invDenom = 1 / denom;\n      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n      return target.set(1 - u - v, v, u);\n    }\n    static containsPoint(point, a, b, c) {\n      if (this.getBarycoord(point, a, b, c, _v3$2) === null) {\n        return false;\n      }\n      return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;\n    }\n    static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {\n      if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {\n        target.x = 0;\n        target.y = 0;\n        if ("z" in target) target.z = 0;\n        if ("w" in target) target.w = 0;\n        return null;\n      }\n      target.setScalar(0);\n      target.addScaledVector(v1, _v3$2.x);\n      target.addScaledVector(v2, _v3$2.y);\n      target.addScaledVector(v3, _v3$2.z);\n      return target;\n    }\n    static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {\n      _v40.setScalar(0);\n      _v41.setScalar(0);\n      _v42.setScalar(0);\n      _v40.fromBufferAttribute(attr, i1);\n      _v41.fromBufferAttribute(attr, i2);\n      _v42.fromBufferAttribute(attr, i3);\n      target.setScalar(0);\n      target.addScaledVector(_v40, barycoord.x);\n      target.addScaledVector(_v41, barycoord.y);\n      target.addScaledVector(_v42, barycoord.z);\n      return target;\n    }\n    static isFrontFacing(a, b, c, direction) {\n      _v0$1.subVectors(c, b);\n      _v1$3.subVectors(a, b);\n      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n    }\n    set(a, b, c) {\n      this.a.copy(a);\n      this.b.copy(b);\n      this.c.copy(c);\n      return this;\n    }\n    setFromPointsAndIndices(points, i0, i1, i2) {\n      this.a.copy(points[i0]);\n      this.b.copy(points[i1]);\n      this.c.copy(points[i2]);\n      return this;\n    }\n    setFromAttributeAndIndices(attribute, i0, i1, i2) {\n      this.a.fromBufferAttribute(attribute, i0);\n      this.b.fromBufferAttribute(attribute, i1);\n      this.c.fromBufferAttribute(attribute, i2);\n      return this;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(triangle) {\n      this.a.copy(triangle.a);\n      this.b.copy(triangle.b);\n      this.c.copy(triangle.c);\n      return this;\n    }\n    getArea() {\n      _v0$1.subVectors(this.c, this.b);\n      _v1$3.subVectors(this.a, this.b);\n      return _v0$1.cross(_v1$3).length() * 0.5;\n    }\n    getMidpoint(target) {\n      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n    }\n    getNormal(target) {\n      return Triangle.getNormal(this.a, this.b, this.c, target);\n    }\n    getPlane(target) {\n      return target.setFromCoplanarPoints(this.a, this.b, this.c);\n    }\n    getBarycoord(point, target) {\n      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n    }\n    getInterpolation(point, v1, v2, v3, target) {\n      return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);\n    }\n    containsPoint(point) {\n      return Triangle.containsPoint(point, this.a, this.b, this.c);\n    }\n    isFrontFacing(direction) {\n      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n    }\n    intersectsBox(box) {\n      return box.intersectsTriangle(this);\n    }\n    closestPointToPoint(p, target) {\n      const a = this.a, b = this.b, c = this.c;\n      let v, w;\n      _vab.subVectors(b, a);\n      _vac.subVectors(c, a);\n      _vap.subVectors(p, a);\n      const d1 = _vab.dot(_vap);\n      const d2 = _vac.dot(_vap);\n      if (d1 <= 0 && d2 <= 0) {\n        return target.copy(a);\n      }\n      _vbp.subVectors(p, b);\n      const d3 = _vab.dot(_vbp);\n      const d4 = _vac.dot(_vbp);\n      if (d3 >= 0 && d4 <= d3) {\n        return target.copy(b);\n      }\n      const vc = d1 * d4 - d3 * d2;\n      if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n        v = d1 / (d1 - d3);\n        return target.copy(a).addScaledVector(_vab, v);\n      }\n      _vcp.subVectors(p, c);\n      const d5 = _vab.dot(_vcp);\n      const d6 = _vac.dot(_vcp);\n      if (d6 >= 0 && d5 <= d6) {\n        return target.copy(c);\n      }\n      const vb = d5 * d2 - d1 * d6;\n      if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n        w = d2 / (d2 - d6);\n        return target.copy(a).addScaledVector(_vac, w);\n      }\n      const va = d3 * d6 - d5 * d4;\n      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n        _vbc.subVectors(c, b);\n        w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n        return target.copy(b).addScaledVector(_vbc, w);\n      }\n      const denom = 1 / (va + vb + vc);\n      v = vb * denom;\n      w = vc * denom;\n      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n    }\n    equals(triangle) {\n      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n    }\n  }\n  const _colorKeywords = {\n    "aliceblue": 15792383,\n    "antiquewhite": 16444375,\n    "aqua": 65535,\n    "aquamarine": 8388564,\n    "azure": 15794175,\n    "beige": 16119260,\n    "bisque": 16770244,\n    "black": 0,\n    "blanchedalmond": 16772045,\n    "blue": 255,\n    "blueviolet": 9055202,\n    "brown": 10824234,\n    "burlywood": 14596231,\n    "cadetblue": 6266528,\n    "chartreuse": 8388352,\n    "chocolate": 13789470,\n    "coral": 16744272,\n    "cornflowerblue": 6591981,\n    "cornsilk": 16775388,\n    "crimson": 14423100,\n    "cyan": 65535,\n    "darkblue": 139,\n    "darkcyan": 35723,\n    "darkgoldenrod": 12092939,\n    "darkgray": 11119017,\n    "darkgreen": 25600,\n    "darkgrey": 11119017,\n    "darkkhaki": 12433259,\n    "darkmagenta": 9109643,\n    "darkolivegreen": 5597999,\n    "darkorange": 16747520,\n    "darkorchid": 10040012,\n    "darkred": 9109504,\n    "darksalmon": 15308410,\n    "darkseagreen": 9419919,\n    "darkslateblue": 4734347,\n    "darkslategray": 3100495,\n    "darkslategrey": 3100495,\n    "darkturquoise": 52945,\n    "darkviolet": 9699539,\n    "deeppink": 16716947,\n    "deepskyblue": 49151,\n    "dimgray": 6908265,\n    "dimgrey": 6908265,\n    "dodgerblue": 2003199,\n    "firebrick": 11674146,\n    "floralwhite": 16775920,\n    "forestgreen": 2263842,\n    "fuchsia": 16711935,\n    "gainsboro": 14474460,\n    "ghostwhite": 16316671,\n    "gold": 16766720,\n    "goldenrod": 14329120,\n    "gray": 8421504,\n    "green": 32768,\n    "greenyellow": 11403055,\n    "grey": 8421504,\n    "honeydew": 15794160,\n    "hotpink": 16738740,\n    "indianred": 13458524,\n    "indigo": 4915330,\n    "ivory": 16777200,\n    "khaki": 15787660,\n    "lavender": 15132410,\n    "lavenderblush": 16773365,\n    "lawngreen": 8190976,\n    "lemonchiffon": 16775885,\n    "lightblue": 11393254,\n    "lightcoral": 15761536,\n    "lightcyan": 14745599,\n    "lightgoldenrodyellow": 16448210,\n    "lightgray": 13882323,\n    "lightgreen": 9498256,\n    "lightgrey": 13882323,\n    "lightpink": 16758465,\n    "lightsalmon": 16752762,\n    "lightseagreen": 2142890,\n    "lightskyblue": 8900346,\n    "lightslategray": 7833753,\n    "lightslategrey": 7833753,\n    "lightsteelblue": 11584734,\n    "lightyellow": 16777184,\n    "lime": 65280,\n    "limegreen": 3329330,\n    "linen": 16445670,\n    "magenta": 16711935,\n    "maroon": 8388608,\n    "mediumaquamarine": 6737322,\n    "mediumblue": 205,\n    "mediumorchid": 12211667,\n    "mediumpurple": 9662683,\n    "mediumseagreen": 3978097,\n    "mediumslateblue": 8087790,\n    "mediumspringgreen": 64154,\n    "mediumturquoise": 4772300,\n    "mediumvioletred": 13047173,\n    "midnightblue": 1644912,\n    "mintcream": 16121850,\n    "mistyrose": 16770273,\n    "moccasin": 16770229,\n    "navajowhite": 16768685,\n    "navy": 128,\n    "oldlace": 16643558,\n    "olive": 8421376,\n    "olivedrab": 7048739,\n    "orange": 16753920,\n    "orangered": 16729344,\n    "orchid": 14315734,\n    "palegoldenrod": 15657130,\n    "palegreen": 10025880,\n    "paleturquoise": 11529966,\n    "palevioletred": 14381203,\n    "papayawhip": 16773077,\n    "peachpuff": 16767673,\n    "peru": 13468991,\n    "pink": 16761035,\n    "plum": 14524637,\n    "powderblue": 11591910,\n    "purple": 8388736,\n    "rebeccapurple": 6697881,\n    "red": 16711680,\n    "rosybrown": 12357519,\n    "royalblue": 4286945,\n    "saddlebrown": 9127187,\n    "salmon": 16416882,\n    "sandybrown": 16032864,\n    "seagreen": 3050327,\n    "seashell": 16774638,\n    "sienna": 10506797,\n    "silver": 12632256,\n    "skyblue": 8900331,\n    "slateblue": 6970061,\n    "slategray": 7372944,\n    "slategrey": 7372944,\n    "snow": 16775930,\n    "springgreen": 65407,\n    "steelblue": 4620980,\n    "tan": 13808780,\n    "teal": 32896,\n    "thistle": 14204888,\n    "tomato": 16737095,\n    "turquoise": 4251856,\n    "violet": 15631086,\n    "wheat": 16113331,\n    "white": 16777215,\n    "whitesmoke": 16119285,\n    "yellow": 16776960,\n    "yellowgreen": 10145074\n  };\n  const _hslA = { h: 0, s: 0, l: 0 };\n  const _hslB = { h: 0, s: 0, l: 0 };\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n    return p;\n  }\n  class Color {\n    constructor(r, g, b) {\n      this.isColor = true;\n      this.r = 1;\n      this.g = 1;\n      this.b = 1;\n      return this.set(r, g, b);\n    }\n    set(r, g, b) {\n      if (g === void 0 && b === void 0) {\n        const value = r;\n        if (value && value.isColor) {\n          this.copy(value);\n        } else if (typeof value === "number") {\n          this.setHex(value);\n        } else if (typeof value === "string") {\n          this.setStyle(value);\n        }\n      } else {\n        this.setRGB(r, g, b);\n      }\n      return this;\n    }\n    setScalar(scalar) {\n      this.r = scalar;\n      this.g = scalar;\n      this.b = scalar;\n      return this;\n    }\n    setHex(hex, colorSpace = SRGBColorSpace) {\n      hex = Math.floor(hex);\n      this.r = (hex >> 16 & 255) / 255;\n      this.g = (hex >> 8 & 255) / 255;\n      this.b = (hex & 255) / 255;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {\n      this.r = r;\n      this.g = g;\n      this.b = b;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {\n      h = euclideanModulo(h, 1);\n      s = clamp(s, 0, 1);\n      l = clamp(l, 0, 1);\n      if (s === 0) {\n        this.r = this.g = this.b = l;\n      } else {\n        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n        const q = 2 * l - p;\n        this.r = hue2rgb(q, p, h + 1 / 3);\n        this.g = hue2rgb(q, p, h);\n        this.b = hue2rgb(q, p, h - 1 / 3);\n      }\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setStyle(style, colorSpace = SRGBColorSpace) {\n      function handleAlpha(string) {\n        if (string === void 0) return;\n        if (parseFloat(string) < 1) {\n          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");\n        }\n      }\n      let m;\n      if (m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {\n        let color;\n        const name = m[1];\n        const components = m[2];\n        switch (name) {\n          case "rgb":\n          case "rgba":\n            if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(255, parseInt(color[1], 10)) / 255,\n                Math.min(255, parseInt(color[2], 10)) / 255,\n                Math.min(255, parseInt(color[3], 10)) / 255,\n                colorSpace\n              );\n            }\n            if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(100, parseInt(color[1], 10)) / 100,\n                Math.min(100, parseInt(color[2], 10)) / 100,\n                Math.min(100, parseInt(color[3], 10)) / 100,\n                colorSpace\n              );\n            }\n            break;\n          case "hsl":\n          case "hsla":\n            if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setHSL(\n                parseFloat(color[1]) / 360,\n                parseFloat(color[2]) / 100,\n                parseFloat(color[3]) / 100,\n                colorSpace\n              );\n            }\n            break;\n          default:\n            console.warn("THREE.Color: Unknown color model " + style);\n        }\n      } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n        const hex = m[1];\n        const size = hex.length;\n        if (size === 3) {\n          return this.setRGB(\n            parseInt(hex.charAt(0), 16) / 15,\n            parseInt(hex.charAt(1), 16) / 15,\n            parseInt(hex.charAt(2), 16) / 15,\n            colorSpace\n          );\n        } else if (size === 6) {\n          return this.setHex(parseInt(hex, 16), colorSpace);\n        } else {\n          console.warn("THREE.Color: Invalid hex color " + style);\n        }\n      } else if (style && style.length > 0) {\n        return this.setColorName(style, colorSpace);\n      }\n      return this;\n    }\n    setColorName(style, colorSpace = SRGBColorSpace) {\n      const hex = _colorKeywords[style.toLowerCase()];\n      if (hex !== void 0) {\n        this.setHex(hex, colorSpace);\n      } else {\n        console.warn("THREE.Color: Unknown color " + style);\n      }\n      return this;\n    }\n    clone() {\n      return new this.constructor(this.r, this.g, this.b);\n    }\n    copy(color) {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n      return this;\n    }\n    copySRGBToLinear(color) {\n      this.r = SRGBToLinear(color.r);\n      this.g = SRGBToLinear(color.g);\n      this.b = SRGBToLinear(color.b);\n      return this;\n    }\n    copyLinearToSRGB(color) {\n      this.r = LinearToSRGB(color.r);\n      this.g = LinearToSRGB(color.g);\n      this.b = LinearToSRGB(color.b);\n      return this;\n    }\n    convertSRGBToLinear() {\n      this.copySRGBToLinear(this);\n      return this;\n    }\n    convertLinearToSRGB() {\n      this.copyLinearToSRGB(this);\n      return this;\n    }\n    getHex(colorSpace = SRGBColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));\n    }\n    getHexString(colorSpace = SRGBColorSpace) {\n      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);\n    }\n    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      const max2 = Math.max(r, g, b);\n      const min = Math.min(r, g, b);\n      let hue, saturation;\n      const lightness = (min + max2) / 2;\n      if (min === max2) {\n        hue = 0;\n        saturation = 0;\n      } else {\n        const delta = max2 - min;\n        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);\n        switch (max2) {\n          case r:\n            hue = (g - b) / delta + (g < b ? 6 : 0);\n            break;\n          case g:\n            hue = (b - r) / delta + 2;\n            break;\n          case b:\n            hue = (r - g) / delta + 4;\n            break;\n        }\n        hue /= 6;\n      }\n      target.h = hue;\n      target.s = saturation;\n      target.l = lightness;\n      return target;\n    }\n    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      target.r = _color.r;\n      target.g = _color.g;\n      target.b = _color.b;\n      return target;\n    }\n    getStyle(colorSpace = SRGBColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      if (colorSpace !== SRGBColorSpace) {\n        return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;\n      }\n      return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\n    }\n    offsetHSL(h, s, l) {\n      this.getHSL(_hslA);\n      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);\n    }\n    add(color) {\n      this.r += color.r;\n      this.g += color.g;\n      this.b += color.b;\n      return this;\n    }\n    addColors(color1, color2) {\n      this.r = color1.r + color2.r;\n      this.g = color1.g + color2.g;\n      this.b = color1.b + color2.b;\n      return this;\n    }\n    addScalar(s) {\n      this.r += s;\n      this.g += s;\n      this.b += s;\n      return this;\n    }\n    sub(color) {\n      this.r = Math.max(0, this.r - color.r);\n      this.g = Math.max(0, this.g - color.g);\n      this.b = Math.max(0, this.b - color.b);\n      return this;\n    }\n    multiply(color) {\n      this.r *= color.r;\n      this.g *= color.g;\n      this.b *= color.b;\n      return this;\n    }\n    multiplyScalar(s) {\n      this.r *= s;\n      this.g *= s;\n      this.b *= s;\n      return this;\n    }\n    lerp(color, alpha) {\n      this.r += (color.r - this.r) * alpha;\n      this.g += (color.g - this.g) * alpha;\n      this.b += (color.b - this.b) * alpha;\n      return this;\n    }\n    lerpColors(color1, color2, alpha) {\n      this.r = color1.r + (color2.r - color1.r) * alpha;\n      this.g = color1.g + (color2.g - color1.g) * alpha;\n      this.b = color1.b + (color2.b - color1.b) * alpha;\n      return this;\n    }\n    lerpHSL(color, alpha) {\n      this.getHSL(_hslA);\n      color.getHSL(_hslB);\n      const h = lerp(_hslA.h, _hslB.h, alpha);\n      const s = lerp(_hslA.s, _hslB.s, alpha);\n      const l = lerp(_hslA.l, _hslB.l, alpha);\n      this.setHSL(h, s, l);\n      return this;\n    }\n    setFromVector3(v) {\n      this.r = v.x;\n      this.g = v.y;\n      this.b = v.z;\n      return this;\n    }\n    applyMatrix3(m) {\n      const r = this.r, g = this.g, b = this.b;\n      const e = m.elements;\n      this.r = e[0] * r + e[3] * g + e[6] * b;\n      this.g = e[1] * r + e[4] * g + e[7] * b;\n      this.b = e[2] * r + e[5] * g + e[8] * b;\n      return this;\n    }\n    equals(c) {\n      return c.r === this.r && c.g === this.g && c.b === this.b;\n    }\n    fromArray(array, offset = 0) {\n      this.r = array[offset];\n      this.g = array[offset + 1];\n      this.b = array[offset + 2];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.r;\n      array[offset + 1] = this.g;\n      array[offset + 2] = this.b;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.r = attribute.getX(index);\n      this.g = attribute.getY(index);\n      this.b = attribute.getZ(index);\n      return this;\n    }\n    toJSON() {\n      return this.getHex();\n    }\n    *[Symbol.iterator]() {\n      yield this.r;\n      yield this.g;\n      yield this.b;\n    }\n  }\n  const _color = /* @__PURE__ */ new Color();\n  Color.NAMES = _colorKeywords;\n  let _materialId = 0;\n  class Material extends EventDispatcher {\n    constructor() {\n      super();\n      this.isMaterial = true;\n      Object.defineProperty(this, "id", { value: _materialId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "Material";\n      this.blending = NormalBlending;\n      this.side = FrontSide;\n      this.vertexColors = false;\n      this.opacity = 1;\n      this.transparent = false;\n      this.alphaHash = false;\n      this.blendSrc = SrcAlphaFactor;\n      this.blendDst = OneMinusSrcAlphaFactor;\n      this.blendEquation = AddEquation;\n      this.blendSrcAlpha = null;\n      this.blendDstAlpha = null;\n      this.blendEquationAlpha = null;\n      this.blendColor = new Color(0, 0, 0);\n      this.blendAlpha = 0;\n      this.depthFunc = LessEqualDepth;\n      this.depthTest = true;\n      this.depthWrite = true;\n      this.stencilWriteMask = 255;\n      this.stencilFunc = AlwaysStencilFunc;\n      this.stencilRef = 0;\n      this.stencilFuncMask = 255;\n      this.stencilFail = KeepStencilOp;\n      this.stencilZFail = KeepStencilOp;\n      this.stencilZPass = KeepStencilOp;\n      this.stencilWrite = false;\n      this.clippingPlanes = null;\n      this.clipIntersection = false;\n      this.clipShadows = false;\n      this.shadowSide = null;\n      this.colorWrite = true;\n      this.precision = null;\n      this.polygonOffset = false;\n      this.polygonOffsetFactor = 0;\n      this.polygonOffsetUnits = 0;\n      this.dithering = false;\n      this.alphaToCoverage = false;\n      this.premultipliedAlpha = false;\n      this.forceSinglePass = false;\n      this.visible = true;\n      this.toneMapped = true;\n      this.userData = {};\n      this.version = 0;\n      this._alphaTest = 0;\n    }\n    get alphaTest() {\n      return this._alphaTest;\n    }\n    set alphaTest(value) {\n      if (this._alphaTest > 0 !== value > 0) {\n        this.version++;\n      }\n      this._alphaTest = value;\n    }\n    // onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n    onBeforeRender() {\n    }\n    onBeforeCompile() {\n    }\n    customProgramCacheKey() {\n      return this.onBeforeCompile.toString();\n    }\n    setValues(values) {\n      if (values === void 0) return;\n      for (const key in values) {\n        const newValue = values[key];\n        if (newValue === void 0) {\n          console.warn(`THREE.Material: parameter \'${key}\' has value of undefined.`);\n          continue;\n        }\n        const currentValue = this[key];\n        if (currentValue === void 0) {\n          console.warn(`THREE.Material: \'${key}\' is not a property of THREE.${this.type}.`);\n          continue;\n        }\n        if (currentValue && currentValue.isColor) {\n          currentValue.set(newValue);\n        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {\n          currentValue.copy(newValue);\n        } else {\n          this[key] = newValue;\n        }\n      }\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (isRootObject) {\n        meta = {\n          textures: {},\n          images: {}\n        };\n      }\n      const data = {\n        metadata: {\n          version: 4.6,\n          type: "Material",\n          generator: "Material.toJSON"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== "") data.name = this.name;\n      if (this.color && this.color.isColor) data.color = this.color.getHex();\n      if (this.roughness !== void 0) data.roughness = this.roughness;\n      if (this.metalness !== void 0) data.metalness = this.metalness;\n      if (this.sheen !== void 0) data.sheen = this.sheen;\n      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();\n      if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;\n      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n      if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n      if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;\n      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();\n      if (this.shininess !== void 0) data.shininess = this.shininess;\n      if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;\n      if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;\n      if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n      }\n      if (this.dispersion !== void 0) data.dispersion = this.dispersion;\n      if (this.iridescence !== void 0) data.iridescence = this.iridescence;\n      if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;\n      if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n      if (this.iridescenceMap && this.iridescenceMap.isTexture) {\n        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;\n      }\n      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {\n        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;\n      }\n      if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;\n      if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;\n      if (this.anisotropyMap && this.anisotropyMap.isTexture) {\n        data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;\n      }\n      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n      if (this.lightMap && this.lightMap.isTexture) {\n        data.lightMap = this.lightMap.toJSON(meta).uuid;\n        data.lightMapIntensity = this.lightMapIntensity;\n      }\n      if (this.aoMap && this.aoMap.isTexture) {\n        data.aoMap = this.aoMap.toJSON(meta).uuid;\n        data.aoMapIntensity = this.aoMapIntensity;\n      }\n      if (this.bumpMap && this.bumpMap.isTexture) {\n        data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n        data.bumpScale = this.bumpScale;\n      }\n      if (this.normalMap && this.normalMap.isTexture) {\n        data.normalMap = this.normalMap.toJSON(meta).uuid;\n        data.normalMapType = this.normalMapType;\n        data.normalScale = this.normalScale.toArray();\n      }\n      if (this.displacementMap && this.displacementMap.isTexture) {\n        data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n        data.displacementScale = this.displacementScale;\n        data.displacementBias = this.displacementBias;\n      }\n      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;\n      if (this.envMap && this.envMap.isTexture) {\n        data.envMap = this.envMap.toJSON(meta).uuid;\n        if (this.combine !== void 0) data.combine = this.combine;\n      }\n      if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();\n      if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;\n      if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;\n      if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;\n      if (this.gradientMap && this.gradientMap.isTexture) {\n        data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n      }\n      if (this.transmission !== void 0) data.transmission = this.transmission;\n      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n      if (this.thickness !== void 0) data.thickness = this.thickness;\n      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n      if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;\n      if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();\n      if (this.size !== void 0) data.size = this.size;\n      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n      if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;\n      if (this.blending !== NormalBlending) data.blending = this.blending;\n      if (this.side !== FrontSide) data.side = this.side;\n      if (this.vertexColors === true) data.vertexColors = true;\n      if (this.opacity < 1) data.opacity = this.opacity;\n      if (this.transparent === true) data.transparent = true;\n      if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;\n      if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;\n      if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;\n      if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;\n      if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;\n      if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;\n      if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();\n      if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;\n      if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;\n      if (this.depthTest === false) data.depthTest = this.depthTest;\n      if (this.depthWrite === false) data.depthWrite = this.depthWrite;\n      if (this.colorWrite === false) data.colorWrite = this.colorWrite;\n      if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;\n      if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;\n      if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;\n      if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;\n      if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;\n      if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;\n      if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;\n      if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;\n      if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;\n      if (this.polygonOffset === true) data.polygonOffset = true;\n      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n      if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;\n      if (this.dashSize !== void 0) data.dashSize = this.dashSize;\n      if (this.gapSize !== void 0) data.gapSize = this.gapSize;\n      if (this.scale !== void 0) data.scale = this.scale;\n      if (this.dithering === true) data.dithering = true;\n      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n      if (this.alphaHash === true) data.alphaHash = true;\n      if (this.alphaToCoverage === true) data.alphaToCoverage = true;\n      if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;\n      if (this.forceSinglePass === true) data.forceSinglePass = true;\n      if (this.wireframe === true) data.wireframe = true;\n      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n      if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;\n      if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;\n      if (this.flatShading === true) data.flatShading = true;\n      if (this.visible === false) data.visible = false;\n      if (this.toneMapped === false) data.toneMapped = false;\n      if (this.fog === false) data.fog = false;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data2 = cache[key];\n          delete data2.metadata;\n          values.push(data2);\n        }\n        return values;\n      }\n      if (isRootObject) {\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        if (textures.length > 0) data.textures = textures;\n        if (images.length > 0) data.images = images;\n      }\n      return data;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.name = source.name;\n      this.blending = source.blending;\n      this.side = source.side;\n      this.vertexColors = source.vertexColors;\n      this.opacity = source.opacity;\n      this.transparent = source.transparent;\n      this.blendSrc = source.blendSrc;\n      this.blendDst = source.blendDst;\n      this.blendEquation = source.blendEquation;\n      this.blendSrcAlpha = source.blendSrcAlpha;\n      this.blendDstAlpha = source.blendDstAlpha;\n      this.blendEquationAlpha = source.blendEquationAlpha;\n      this.blendColor.copy(source.blendColor);\n      this.blendAlpha = source.blendAlpha;\n      this.depthFunc = source.depthFunc;\n      this.depthTest = source.depthTest;\n      this.depthWrite = source.depthWrite;\n      this.stencilWriteMask = source.stencilWriteMask;\n      this.stencilFunc = source.stencilFunc;\n      this.stencilRef = source.stencilRef;\n      this.stencilFuncMask = source.stencilFuncMask;\n      this.stencilFail = source.stencilFail;\n      this.stencilZFail = source.stencilZFail;\n      this.stencilZPass = source.stencilZPass;\n      this.stencilWrite = source.stencilWrite;\n      const srcPlanes = source.clippingPlanes;\n      let dstPlanes = null;\n      if (srcPlanes !== null) {\n        const n = srcPlanes.length;\n        dstPlanes = new Array(n);\n        for (let i2 = 0; i2 !== n; ++i2) {\n          dstPlanes[i2] = srcPlanes[i2].clone();\n        }\n      }\n      this.clippingPlanes = dstPlanes;\n      this.clipIntersection = source.clipIntersection;\n      this.clipShadows = source.clipShadows;\n      this.shadowSide = source.shadowSide;\n      this.colorWrite = source.colorWrite;\n      this.precision = source.precision;\n      this.polygonOffset = source.polygonOffset;\n      this.polygonOffsetFactor = source.polygonOffsetFactor;\n      this.polygonOffsetUnits = source.polygonOffsetUnits;\n      this.dithering = source.dithering;\n      this.alphaTest = source.alphaTest;\n      this.alphaHash = source.alphaHash;\n      this.alphaToCoverage = source.alphaToCoverage;\n      this.premultipliedAlpha = source.premultipliedAlpha;\n      this.forceSinglePass = source.forceSinglePass;\n      this.visible = source.visible;\n      this.toneMapped = source.toneMapped;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    onBuild() {\n      console.warn("Material: onBuild() has been removed.");\n    }\n  }\n  class MeshBasicMaterial extends Material {\n    constructor(parameters) {\n      super();\n      this.isMeshBasicMaterial = true;\n      this.type = "MeshBasicMaterial";\n      this.color = new Color(16777215);\n      this.map = null;\n      this.lightMap = null;\n      this.lightMapIntensity = 1;\n      this.aoMap = null;\n      this.aoMapIntensity = 1;\n      this.specularMap = null;\n      this.alphaMap = null;\n      this.envMap = null;\n      this.envMapRotation = new Euler();\n      this.combine = MultiplyOperation;\n      this.reflectivity = 1;\n      this.refractionRatio = 0.98;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.wireframeLinecap = "round";\n      this.wireframeLinejoin = "round";\n      this.fog = true;\n      this.setValues(parameters);\n    }\n    copy(source) {\n      super.copy(source);\n      this.color.copy(source.color);\n      this.map = source.map;\n      this.lightMap = source.lightMap;\n      this.lightMapIntensity = source.lightMapIntensity;\n      this.aoMap = source.aoMap;\n      this.aoMapIntensity = source.aoMapIntensity;\n      this.specularMap = source.specularMap;\n      this.alphaMap = source.alphaMap;\n      this.envMap = source.envMap;\n      this.envMapRotation.copy(source.envMapRotation);\n      this.combine = source.combine;\n      this.reflectivity = source.reflectivity;\n      this.refractionRatio = source.refractionRatio;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.wireframeLinecap = source.wireframeLinecap;\n      this.wireframeLinejoin = source.wireframeLinejoin;\n      this.fog = source.fog;\n      return this;\n    }\n  }\n  const _vector$9 = /* @__PURE__ */ new Vector3();\n  const _vector2$1 = /* @__PURE__ */ new Vector2();\n  class BufferAttribute {\n    constructor(array, itemSize, normalized = false) {\n      if (Array.isArray(array)) {\n        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");\n      }\n      this.isBufferAttribute = true;\n      this.name = "";\n      this.array = array;\n      this.itemSize = itemSize;\n      this.count = array !== void 0 ? array.length / itemSize : 0;\n      this.normalized = normalized;\n      this.usage = StaticDrawUsage;\n      this.updateRanges = [];\n      this.gpuType = FloatType;\n      this.version = 0;\n    }\n    onUploadCallback() {\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    setUsage(value) {\n      this.usage = value;\n      return this;\n    }\n    addUpdateRange(start, count) {\n      this.updateRanges.push({ start, count });\n    }\n    clearUpdateRanges() {\n      this.updateRanges.length = 0;\n    }\n    copy(source) {\n      this.name = source.name;\n      this.array = new source.array.constructor(source.array);\n      this.itemSize = source.itemSize;\n      this.count = source.count;\n      this.normalized = source.normalized;\n      this.usage = source.usage;\n      this.gpuType = source.gpuType;\n      return this;\n    }\n    copyAt(index1, attribute, index2) {\n      index1 *= this.itemSize;\n      index2 *= attribute.itemSize;\n      for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {\n        this.array[index1 + i2] = attribute.array[index2 + i2];\n      }\n      return this;\n    }\n    copyArray(array) {\n      this.array.set(array);\n      return this;\n    }\n    applyMatrix3(m) {\n      if (this.itemSize === 2) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector2$1.fromBufferAttribute(this, i2);\n          _vector2$1.applyMatrix3(m);\n          this.setXY(i2, _vector2$1.x, _vector2$1.y);\n        }\n      } else if (this.itemSize === 3) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector$9.fromBufferAttribute(this, i2);\n          _vector$9.applyMatrix3(m);\n          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n        }\n      }\n      return this;\n    }\n    applyMatrix4(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyMatrix4(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    applyNormalMatrix(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyNormalMatrix(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    transformDirection(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.transformDirection(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    set(value, offset = 0) {\n      this.array.set(value, offset);\n      return this;\n    }\n    getComponent(index, component) {\n      let value = this.array[index * this.itemSize + component];\n      if (this.normalized) value = denormalize(value, this.array);\n      return value;\n    }\n    setComponent(index, component, value) {\n      if (this.normalized) value = normalize$1(value, this.array);\n      this.array[index * this.itemSize + component] = value;\n      return this;\n    }\n    getX(index) {\n      let x2 = this.array[index * this.itemSize];\n      if (this.normalized) x2 = denormalize(x2, this.array);\n      return x2;\n    }\n    setX(index, x2) {\n      if (this.normalized) x2 = normalize$1(x2, this.array);\n      this.array[index * this.itemSize] = x2;\n      return this;\n    }\n    getY(index) {\n      let y = this.array[index * this.itemSize + 1];\n      if (this.normalized) y = denormalize(y, this.array);\n      return y;\n    }\n    setY(index, y) {\n      if (this.normalized) y = normalize$1(y, this.array);\n      this.array[index * this.itemSize + 1] = y;\n      return this;\n    }\n    getZ(index) {\n      let z = this.array[index * this.itemSize + 2];\n      if (this.normalized) z = denormalize(z, this.array);\n      return z;\n    }\n    setZ(index, z) {\n      if (this.normalized) z = normalize$1(z, this.array);\n      this.array[index * this.itemSize + 2] = z;\n      return this;\n    }\n    getW(index) {\n      let w = this.array[index * this.itemSize + 3];\n      if (this.normalized) w = denormalize(w, this.array);\n      return w;\n    }\n    setW(index, w) {\n      if (this.normalized) w = normalize$1(w, this.array);\n      this.array[index * this.itemSize + 3] = w;\n      return this;\n    }\n    setXY(index, x2, y) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      return this;\n    }\n    setXYZ(index, x2, y, z) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n        z = normalize$1(z, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      return this;\n    }\n    setXYZW(index, x2, y, z, w) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n        z = normalize$1(z, this.array);\n        w = normalize$1(w, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      this.array[index + 3] = w;\n      return this;\n    }\n    onUpload(callback) {\n      this.onUploadCallback = callback;\n      return this;\n    }\n    clone() {\n      return new this.constructor(this.array, this.itemSize).copy(this);\n    }\n    toJSON() {\n      const data = {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array: Array.from(this.array),\n        normalized: this.normalized\n      };\n      if (this.name !== "") data.name = this.name;\n      if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n      return data;\n    }\n  }\n  class Uint16BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Uint16Array(array), itemSize, normalized);\n    }\n  }\n  class Uint32BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Uint32Array(array), itemSize, normalized);\n    }\n  }\n  class Float32BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Float32Array(array), itemSize, normalized);\n    }\n  }\n  let _id$1 = 0;\n  const _m1 = /* @__PURE__ */ new Matrix4();\n  const _obj = /* @__PURE__ */ new Object3D();\n  const _offset = /* @__PURE__ */ new Vector3();\n  const _box$2 = /* @__PURE__ */ new Box3();\n  const _boxMorphTargets = /* @__PURE__ */ new Box3();\n  const _vector$8 = /* @__PURE__ */ new Vector3();\n  class BufferGeometry extends EventDispatcher {\n    constructor() {\n      super();\n      this.isBufferGeometry = true;\n      Object.defineProperty(this, "id", { value: _id$1++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "BufferGeometry";\n      this.index = null;\n      this.indirect = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.morphTargetsRelative = false;\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      this.drawRange = { start: 0, count: Infinity };\n      this.userData = {};\n    }\n    getIndex() {\n      return this.index;\n    }\n    setIndex(index) {\n      if (Array.isArray(index)) {\n        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n      } else {\n        this.index = index;\n      }\n      return this;\n    }\n    setIndirect(indirect) {\n      this.indirect = indirect;\n      return this;\n    }\n    getIndirect() {\n      return this.indirect;\n    }\n    getAttribute(name) {\n      return this.attributes[name];\n    }\n    setAttribute(name, attribute) {\n      this.attributes[name] = attribute;\n      return this;\n    }\n    deleteAttribute(name) {\n      delete this.attributes[name];\n      return this;\n    }\n    hasAttribute(name) {\n      return this.attributes[name] !== void 0;\n    }\n    addGroup(start, count, materialIndex = 0) {\n      this.groups.push({\n        start,\n        count,\n        materialIndex\n      });\n    }\n    clearGroups() {\n      this.groups = [];\n    }\n    setDrawRange(start, count) {\n      this.drawRange.start = start;\n      this.drawRange.count = count;\n    }\n    applyMatrix4(matrix) {\n      const position = this.attributes.position;\n      if (position !== void 0) {\n        position.applyMatrix4(matrix);\n        position.needsUpdate = true;\n      }\n      const normal = this.attributes.normal;\n      if (normal !== void 0) {\n        const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n        normal.applyNormalMatrix(normalMatrix);\n        normal.needsUpdate = true;\n      }\n      const tangent = this.attributes.tangent;\n      if (tangent !== void 0) {\n        tangent.transformDirection(matrix);\n        tangent.needsUpdate = true;\n      }\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n      return this;\n    }\n    applyQuaternion(q) {\n      _m1.makeRotationFromQuaternion(q);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateX(angle) {\n      _m1.makeRotationX(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateY(angle) {\n      _m1.makeRotationY(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateZ(angle) {\n      _m1.makeRotationZ(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    translate(x2, y, z) {\n      _m1.makeTranslation(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    scale(x2, y, z) {\n      _m1.makeScale(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    lookAt(vector) {\n      _obj.lookAt(vector);\n      _obj.updateMatrix();\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n    center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n    setFromPoints(points) {\n      const positionAttribute = this.getAttribute("position");\n      if (positionAttribute === void 0) {\n        const position = [];\n        for (let i2 = 0, l = points.length; i2 < l; i2++) {\n          const point = points[i2];\n          position.push(point.x, point.y, point.z || 0);\n        }\n        this.setAttribute("position", new Float32BufferAttribute(position, 3));\n      } else {\n        const l = Math.min(points.length, positionAttribute.count);\n        for (let i2 = 0; i2 < l; i2++) {\n          const point = points[i2];\n          positionAttribute.setXYZ(i2, point.x, point.y, point.z || 0);\n        }\n        if (points.length > positionAttribute.count) {\n          console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");\n        }\n        positionAttribute.needsUpdate = true;\n      }\n      return this;\n    }\n    computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);\n        this.boundingBox.set(\n          new Vector3(-Infinity, -Infinity, -Infinity),\n          new Vector3(Infinity, Infinity, Infinity)\n        );\n        return;\n      }\n      if (position !== void 0) {\n        this.boundingBox.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _box$2.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(this.boundingBox.min, _box$2.min);\n              this.boundingBox.expandByPoint(_vector$8);\n              _vector$8.addVectors(this.boundingBox.max, _box$2.max);\n              this.boundingBox.expandByPoint(_vector$8);\n            } else {\n              this.boundingBox.expandByPoint(_box$2.min);\n              this.boundingBox.expandByPoint(_box$2.max);\n            }\n          }\n        }\n      } else {\n        this.boundingBox.makeEmpty();\n      }\n      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n        console.error(\'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.\', this);\n      }\n    }\n    computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);\n        this.boundingSphere.set(new Vector3(), Infinity);\n        return;\n      }\n      if (position) {\n        const center = this.boundingSphere.center;\n        _box$2.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);\n              _box$2.expandByPoint(_vector$8);\n              _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);\n              _box$2.expandByPoint(_vector$8);\n            } else {\n              _box$2.expandByPoint(_boxMorphTargets.min);\n              _box$2.expandByPoint(_boxMorphTargets.max);\n            }\n          }\n        }\n        _box$2.getCenter(center);\n        let maxRadiusSq = 0;\n        for (let i2 = 0, il = position.count; i2 < il; i2++) {\n          _vector$8.fromBufferAttribute(position, i2);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n        }\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            const morphTargetsRelative = this.morphTargetsRelative;\n            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n              _vector$8.fromBufferAttribute(morphAttribute, j);\n              if (morphTargetsRelative) {\n                _offset.fromBufferAttribute(position, j);\n                _vector$8.add(_offset);\n              }\n              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n            }\n          }\n        }\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error(\'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.\', this);\n        }\n      }\n    }\n    computeTangents() {\n      const index = this.index;\n      const attributes = this.attributes;\n      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {\n        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");\n        return;\n      }\n      const positionAttribute = attributes.position;\n      const normalAttribute = attributes.normal;\n      const uvAttribute = attributes.uv;\n      if (this.hasAttribute("tangent") === false) {\n        this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));\n      }\n      const tangentAttribute = this.getAttribute("tangent");\n      const tan1 = [], tan2 = [];\n      for (let i2 = 0; i2 < positionAttribute.count; i2++) {\n        tan1[i2] = new Vector3();\n        tan2[i2] = new Vector3();\n      }\n      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();\n      function handleTriangle(a, b, c) {\n        vA.fromBufferAttribute(positionAttribute, a);\n        vB.fromBufferAttribute(positionAttribute, b);\n        vC.fromBufferAttribute(positionAttribute, c);\n        uvA.fromBufferAttribute(uvAttribute, a);\n        uvB.fromBufferAttribute(uvAttribute, b);\n        uvC.fromBufferAttribute(uvAttribute, c);\n        vB.sub(vA);\n        vC.sub(vA);\n        uvB.sub(uvA);\n        uvC.sub(uvA);\n        const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);\n        if (!isFinite(r)) return;\n        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n        tan1[a].add(sdir);\n        tan1[b].add(sdir);\n        tan1[c].add(sdir);\n        tan2[a].add(tdir);\n        tan2[b].add(tdir);\n        tan2[c].add(tdir);\n      }\n      let groups = this.groups;\n      if (groups.length === 0) {\n        groups = [{\n          start: 0,\n          count: index.count\n        }];\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleTriangle(\n            index.getX(j + 0),\n            index.getX(j + 1),\n            index.getX(j + 2)\n          );\n        }\n      }\n      const tmp = new Vector3(), tmp2 = new Vector3();\n      const n = new Vector3(), n2 = new Vector3();\n      function handleVertex(v) {\n        n.fromBufferAttribute(normalAttribute, v);\n        n2.copy(n);\n        const t = tan1[v];\n        tmp.copy(t);\n        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n        tmp2.crossVectors(n2, t);\n        const test = tmp2.dot(tan2[v]);\n        const w = test < 0 ? -1 : 1;\n        tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleVertex(index.getX(j + 0));\n          handleVertex(index.getX(j + 1));\n          handleVertex(index.getX(j + 2));\n        }\n      }\n    }\n    computeVertexNormals() {\n      const index = this.index;\n      const positionAttribute = this.getAttribute("position");\n      if (positionAttribute !== void 0) {\n        let normalAttribute = this.getAttribute("normal");\n        if (normalAttribute === void 0) {\n          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n          this.setAttribute("normal", normalAttribute);\n        } else {\n          for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {\n            normalAttribute.setXYZ(i2, 0, 0, 0);\n          }\n        }\n        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n        const cb = new Vector3(), ab = new Vector3();\n        if (index) {\n          for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {\n            const vA = index.getX(i2 + 0);\n            const vB = index.getX(i2 + 1);\n            const vC = index.getX(i2 + 2);\n            pA.fromBufferAttribute(positionAttribute, vA);\n            pB.fromBufferAttribute(positionAttribute, vB);\n            pC.fromBufferAttribute(positionAttribute, vC);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            nA.fromBufferAttribute(normalAttribute, vA);\n            nB.fromBufferAttribute(normalAttribute, vB);\n            nC.fromBufferAttribute(normalAttribute, vC);\n            nA.add(cb);\n            nB.add(cb);\n            nC.add(cb);\n            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n          }\n        } else {\n          for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {\n            pA.fromBufferAttribute(positionAttribute, i2 + 0);\n            pB.fromBufferAttribute(positionAttribute, i2 + 1);\n            pC.fromBufferAttribute(positionAttribute, i2 + 2);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);\n          }\n        }\n        this.normalizeNormals();\n        normalAttribute.needsUpdate = true;\n      }\n    }\n    normalizeNormals() {\n      const normals = this.attributes.normal;\n      for (let i2 = 0, il = normals.count; i2 < il; i2++) {\n        _vector$8.fromBufferAttribute(normals, i2);\n        _vector$8.normalize();\n        normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);\n      }\n    }\n    toNonIndexed() {\n      function convertBufferAttribute(attribute, indices2) {\n        const array = attribute.array;\n        const itemSize = attribute.itemSize;\n        const normalized = attribute.normalized;\n        const array2 = new array.constructor(indices2.length * itemSize);\n        let index = 0, index2 = 0;\n        for (let i2 = 0, l = indices2.length; i2 < l; i2++) {\n          if (attribute.isInterleavedBufferAttribute) {\n            index = indices2[i2] * attribute.data.stride + attribute.offset;\n          } else {\n            index = indices2[i2] * itemSize;\n          }\n          for (let j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n        return new BufferAttribute(array2, itemSize, normalized);\n      }\n      if (this.index === null) {\n        console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");\n        return this;\n      }\n      const geometry2 = new BufferGeometry();\n      const indices = this.index.array;\n      const attributes = this.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        geometry2.setAttribute(name, newAttribute);\n      }\n      const morphAttributes = this.morphAttributes;\n      for (const name in morphAttributes) {\n        const morphArray = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {\n          const attribute = morphAttribute[i2];\n          const newAttribute = convertBufferAttribute(attribute, indices);\n          morphArray.push(newAttribute);\n        }\n        geometry2.morphAttributes[name] = morphArray;\n      }\n      geometry2.morphTargetsRelative = this.morphTargetsRelative;\n      const groups = this.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        geometry2.addGroup(group.start, group.count, group.materialIndex);\n      }\n      return geometry2;\n    }\n    toJSON() {\n      const data = {\n        metadata: {\n          version: 4.6,\n          type: "BufferGeometry",\n          generator: "BufferGeometry.toJSON"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== "") data.name = this.name;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      if (this.parameters !== void 0) {\n        const parameters = this.parameters;\n        for (const key in parameters) {\n          if (parameters[key] !== void 0) data[key] = parameters[key];\n        }\n        return data;\n      }\n      data.data = { attributes: {} };\n      const index = this.index;\n      if (index !== null) {\n        data.data.index = {\n          type: index.array.constructor.name,\n          array: Array.prototype.slice.call(index.array)\n        };\n      }\n      const attributes = this.attributes;\n      for (const key in attributes) {\n        const attribute = attributes[key];\n        data.data.attributes[key] = attribute.toJSON(data.data);\n      }\n      const morphAttributes = {};\n      let hasMorphAttributes = false;\n      for (const key in this.morphAttributes) {\n        const attributeArray = this.morphAttributes[key];\n        const array = [];\n        for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {\n          const attribute = attributeArray[i2];\n          array.push(attribute.toJSON(data.data));\n        }\n        if (array.length > 0) {\n          morphAttributes[key] = array;\n          hasMorphAttributes = true;\n        }\n      }\n      if (hasMorphAttributes) {\n        data.data.morphAttributes = morphAttributes;\n        data.data.morphTargetsRelative = this.morphTargetsRelative;\n      }\n      const groups = this.groups;\n      if (groups.length > 0) {\n        data.data.groups = JSON.parse(JSON.stringify(groups));\n      }\n      const boundingSphere = this.boundingSphere;\n      if (boundingSphere !== null) {\n        data.data.boundingSphere = {\n          center: boundingSphere.center.toArray(),\n          radius: boundingSphere.radius\n        };\n      }\n      return data;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.index = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      const data = {};\n      this.name = source.name;\n      const index = source.index;\n      if (index !== null) {\n        this.setIndex(index.clone(data));\n      }\n      const attributes = source.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        this.setAttribute(name, attribute.clone(data));\n      }\n      const morphAttributes = source.morphAttributes;\n      for (const name in morphAttributes) {\n        const array = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {\n          array.push(morphAttribute[i2].clone(data));\n        }\n        this.morphAttributes[name] = array;\n      }\n      this.morphTargetsRelative = source.morphTargetsRelative;\n      const groups = source.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        this.addGroup(group.start, group.count, group.materialIndex);\n      }\n      const boundingBox = source.boundingBox;\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      }\n      const boundingSphere = source.boundingSphere;\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      }\n      this.drawRange.start = source.drawRange.start;\n      this.drawRange.count = source.drawRange.count;\n      this.userData = source.userData;\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n  }\n  const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();\n  const _ray$3 = /* @__PURE__ */ new Ray();\n  const _sphere$6 = /* @__PURE__ */ new Sphere();\n  const _sphereHitAt = /* @__PURE__ */ new Vector3();\n  const _vA$1 = /* @__PURE__ */ new Vector3();\n  const _vB$1 = /* @__PURE__ */ new Vector3();\n  const _vC$1 = /* @__PURE__ */ new Vector3();\n  const _tempA = /* @__PURE__ */ new Vector3();\n  const _morphA = /* @__PURE__ */ new Vector3();\n  const _intersectionPoint = /* @__PURE__ */ new Vector3();\n  const _intersectionPointWorld = /* @__PURE__ */ new Vector3();\n  class Mesh extends Object3D {\n    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n      super();\n      this.isMesh = true;\n      this.type = "Mesh";\n      this.geometry = geometry;\n      this.material = material;\n      this.updateMorphTargets();\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      if (source.morphTargetInfluences !== void 0) {\n        this.morphTargetInfluences = source.morphTargetInfluences.slice();\n      }\n      if (source.morphTargetDictionary !== void 0) {\n        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n      }\n      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n      this.geometry = source.geometry;\n      return this;\n    }\n    updateMorphTargets() {\n      const geometry = this.geometry;\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n        if (morphAttribute !== void 0) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    }\n    getVertexPosition(index, target) {\n      const geometry = this.geometry;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      target.fromBufferAttribute(position, index);\n      const morphInfluences = this.morphTargetInfluences;\n      if (morphPosition && morphInfluences) {\n        _morphA.set(0, 0, 0);\n        for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {\n          const influence = morphInfluences[i2];\n          const morphAttribute = morphPosition[i2];\n          if (influence === 0) continue;\n          _tempA.fromBufferAttribute(morphAttribute, index);\n          if (morphTargetsRelative) {\n            _morphA.addScaledVector(_tempA, influence);\n          } else {\n            _morphA.addScaledVector(_tempA.sub(target), influence);\n          }\n        }\n        target.add(_morphA);\n      }\n      return target;\n    }\n    raycast(raycaster, intersects) {\n      const geometry = this.geometry;\n      const material = this.material;\n      const matrixWorld = this.matrixWorld;\n      if (material === void 0) return;\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n      _sphere$6.copy(geometry.boundingSphere);\n      _sphere$6.applyMatrix4(matrixWorld);\n      _ray$3.copy(raycaster.ray).recast(raycaster.near);\n      if (_sphere$6.containsPoint(_ray$3.origin) === false) {\n        if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;\n        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;\n      }\n      _inverseMatrix$3.copy(matrixWorld).invert();\n      _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);\n      if (geometry.boundingBox !== null) {\n        if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;\n      }\n      this._computeIntersections(raycaster, intersects, _ray$3);\n    }\n    _computeIntersections(raycaster, intersects, rayLocalSpace) {\n      let intersection;\n      const geometry = this.geometry;\n      const material = this.material;\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const uv = geometry.attributes.uv;\n      const uv1 = geometry.attributes.uv1;\n      const normal = geometry.attributes.normal;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n      if (index !== null) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = index.getX(i2);\n            const b = index.getX(i2 + 1);\n            const c = index.getX(i2 + 2);\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== void 0) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(position.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = i2;\n            const b = i2 + 1;\n            const c = i2 + 2;\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    }\n  }\n  function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {\n    let intersect;\n    if (material.side === BackSide) {\n      intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n    } else {\n      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);\n    }\n    if (intersect === null) return null;\n    _intersectionPointWorld.copy(point);\n    _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n    if (distance < raycaster.near || distance > raycaster.far) return null;\n    return {\n      distance,\n      point: _intersectionPointWorld.clone(),\n      object\n    };\n  }\n  function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {\n    object.getVertexPosition(a, _vA$1);\n    object.getVertexPosition(b, _vB$1);\n    object.getVertexPosition(c, _vC$1);\n    const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n    if (intersection) {\n      const barycoord = new Vector3();\n      Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);\n      if (uv) {\n        intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());\n      }\n      if (uv1) {\n        intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());\n      }\n      if (normal) {\n        intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());\n        if (intersection.normal.dot(ray.direction) > 0) {\n          intersection.normal.multiplyScalar(-1);\n        }\n      }\n      const face = {\n        a,\n        b,\n        c,\n        normal: new Vector3(),\n        materialIndex: 0\n      };\n      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n      intersection.face = face;\n      intersection.barycoord = barycoord;\n    }\n    return intersection;\n  }\n  function cloneUniforms(src) {\n    const dst = {};\n    for (const u in src) {\n      dst[u] = {};\n      for (const p in src[u]) {\n        const property = src[u][p];\n        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n          if (property.isRenderTargetTexture) {\n            console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");\n            dst[u][p] = null;\n          } else {\n            dst[u][p] = property.clone();\n          }\n        } else if (Array.isArray(property)) {\n          dst[u][p] = property.slice();\n        } else {\n          dst[u][p] = property;\n        }\n      }\n    }\n    return dst;\n  }\n  function cloneUniformsGroups(src) {\n    const dst = [];\n    for (let u = 0; u < src.length; u++) {\n      dst.push(src[u].clone());\n    }\n    return dst;\n  }\n  var default_vertex = "void main() {\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}";\n  var default_fragment = "void main() {\\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}";\n  class ShaderMaterial extends Material {\n    constructor(parameters) {\n      super();\n      this.isShaderMaterial = true;\n      this.type = "ShaderMaterial";\n      this.defines = {};\n      this.uniforms = {};\n      this.uniformsGroups = [];\n      this.vertexShader = default_vertex;\n      this.fragmentShader = default_fragment;\n      this.linewidth = 1;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.fog = false;\n      this.lights = false;\n      this.clipping = false;\n      this.forceSinglePass = true;\n      this.extensions = {\n        clipCullDistance: false,\n        // set to use vertex shader clipping\n        multiDraw: false\n        // set to use vertex shader multi_draw / enable gl_DrawID\n      };\n      this.defaultAttributeValues = {\n        "color": [1, 1, 1],\n        "uv": [0, 0],\n        "uv1": [0, 0]\n      };\n      this.index0AttributeName = void 0;\n      this.uniformsNeedUpdate = false;\n      this.glslVersion = null;\n      if (parameters !== void 0) {\n        this.setValues(parameters);\n      }\n    }\n    copy(source) {\n      super.copy(source);\n      this.fragmentShader = source.fragmentShader;\n      this.vertexShader = source.vertexShader;\n      this.uniforms = cloneUniforms(source.uniforms);\n      this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);\n      this.defines = Object.assign({}, source.defines);\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.fog = source.fog;\n      this.lights = source.lights;\n      this.clipping = source.clipping;\n      this.extensions = Object.assign({}, source.extensions);\n      this.glslVersion = source.glslVersion;\n      return this;\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      data.glslVersion = this.glslVersion;\n      data.uniforms = {};\n      for (const name in this.uniforms) {\n        const uniform = this.uniforms[name];\n        const value = uniform.value;\n        if (value && value.isTexture) {\n          data.uniforms[name] = {\n            type: "t",\n            value: value.toJSON(meta).uuid\n          };\n        } else if (value && value.isColor) {\n          data.uniforms[name] = {\n            type: "c",\n            value: value.getHex()\n          };\n        } else if (value && value.isVector2) {\n          data.uniforms[name] = {\n            type: "v2",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector3) {\n          data.uniforms[name] = {\n            type: "v3",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector4) {\n          data.uniforms[name] = {\n            type: "v4",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix3) {\n          data.uniforms[name] = {\n            type: "m3",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix4) {\n          data.uniforms[name] = {\n            type: "m4",\n            value: value.toArray()\n          };\n        } else {\n          data.uniforms[name] = {\n            value\n          };\n        }\n      }\n      if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n      data.vertexShader = this.vertexShader;\n      data.fragmentShader = this.fragmentShader;\n      data.lights = this.lights;\n      data.clipping = this.clipping;\n      const extensions = {};\n      for (const key in this.extensions) {\n        if (this.extensions[key] === true) extensions[key] = true;\n      }\n      if (Object.keys(extensions).length > 0) data.extensions = extensions;\n      return data;\n    }\n  }\n  class Camera extends Object3D {\n    constructor() {\n      super();\n      this.isCamera = true;\n      this.type = "Camera";\n      this.matrixWorldInverse = new Matrix4();\n      this.projectionMatrix = new Matrix4();\n      this.projectionMatrixInverse = new Matrix4();\n      this.coordinateSystem = WebGLCoordinateSystem;\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      this.matrixWorldInverse.copy(source.matrixWorldInverse);\n      this.projectionMatrix.copy(source.projectionMatrix);\n      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n      this.coordinateSystem = source.coordinateSystem;\n      return this;\n    }\n    getWorldDirection(target) {\n      return super.getWorldDirection(target).negate();\n    }\n    updateMatrixWorld(force) {\n      super.updateMatrixWorld(force);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n      super.updateWorldMatrix(updateParents, updateChildren);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class Scene extends Object3D {\n    constructor() {\n      super();\n      this.isScene = true;\n      this.type = "Scene";\n      this.background = null;\n      this.environment = null;\n      this.fog = null;\n      this.backgroundBlurriness = 0;\n      this.backgroundIntensity = 1;\n      this.backgroundRotation = new Euler();\n      this.environmentIntensity = 1;\n      this.environmentRotation = new Euler();\n      this.overrideMaterial = null;\n      if (typeof __THREE_DEVTOOLS__ !== "undefined") {\n        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));\n      }\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      if (source.background !== null) this.background = source.background.clone();\n      if (source.environment !== null) this.environment = source.environment.clone();\n      if (source.fog !== null) this.fog = source.fog.clone();\n      this.backgroundBlurriness = source.backgroundBlurriness;\n      this.backgroundIntensity = source.backgroundIntensity;\n      this.backgroundRotation.copy(source.backgroundRotation);\n      this.environmentIntensity = source.environmentIntensity;\n      this.environmentRotation.copy(source.environmentRotation);\n      if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      return this;\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      if (this.fog !== null) data.object.fog = this.fog.toJSON();\n      if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;\n      if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;\n      data.object.backgroundRotation = this.backgroundRotation.toArray();\n      if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;\n      data.object.environmentRotation = this.environmentRotation.toArray();\n      return data;\n    }\n  }\n  class DataTexture extends Texture {\n    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {\n      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n      this.isDataTexture = true;\n      this.image = { data, width, height };\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n    }\n  }\n  class PlaneGeometry extends BufferGeometry {\n    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n      super();\n      this.type = "PlaneGeometry";\n      this.parameters = {\n        width,\n        height,\n        widthSegments,\n        heightSegments\n      };\n      const width_half = width / 2;\n      const height_half = height / 2;\n      const gridX = Math.floor(widthSegments);\n      const gridY = Math.floor(heightSegments);\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      const segment_width = width / gridX;\n      const segment_height = height / gridY;\n      const indices = [];\n      const vertices = [];\n      const normals = [];\n      const uvs = [];\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segment_height - height_half;\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x2 = ix * segment_width - width_half;\n          vertices.push(x2, -y, 0);\n          normals.push(0, 0, 1);\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n        }\n      }\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = ix + gridX1 * iy;\n          const b = ix + gridX1 * (iy + 1);\n          const c = ix + 1 + gridX1 * (iy + 1);\n          const d = ix + 1 + gridX1 * iy;\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n      this.setIndex(indices);\n      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));\n      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));\n      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));\n    }\n    copy(source) {\n      super.copy(source);\n      this.parameters = Object.assign({}, source.parameters);\n      return this;\n    }\n    static fromJSON(data) {\n      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);\n    }\n  }\n  class RawShaderMaterial extends ShaderMaterial {\n    constructor(parameters) {\n      super(parameters);\n      this.isRawShaderMaterial = true;\n      this.type = "RawShaderMaterial";\n    }\n  }\n  const Cache = {\n    enabled: false,\n    files: {},\n    add: function(key, file) {\n      if (this.enabled === false) return;\n      this.files[key] = file;\n    },\n    get: function(key) {\n      if (this.enabled === false) return;\n      return this.files[key];\n    },\n    remove: function(key) {\n      delete this.files[key];\n    },\n    clear: function() {\n      this.files = {};\n    }\n  };\n  class LoadingManager {\n    constructor(onLoad, onProgress, onError) {\n      const scope = this;\n      let isLoading = false;\n      let itemsLoaded = 0;\n      let itemsTotal = 0;\n      let urlModifier = void 0;\n      const handlers = [];\n      this.onStart = void 0;\n      this.onLoad = onLoad;\n      this.onProgress = onProgress;\n      this.onError = onError;\n      this.itemStart = function(url) {\n        itemsTotal++;\n        if (isLoading === false) {\n          if (scope.onStart !== void 0) {\n            scope.onStart(url, itemsLoaded, itemsTotal);\n          }\n        }\n        isLoading = true;\n      };\n      this.itemEnd = function(url) {\n        itemsLoaded++;\n        if (scope.onProgress !== void 0) {\n          scope.onProgress(url, itemsLoaded, itemsTotal);\n        }\n        if (itemsLoaded === itemsTotal) {\n          isLoading = false;\n          if (scope.onLoad !== void 0) {\n            scope.onLoad();\n          }\n        }\n      };\n      this.itemError = function(url) {\n        if (scope.onError !== void 0) {\n          scope.onError(url);\n        }\n      };\n      this.resolveURL = function(url) {\n        if (urlModifier) {\n          return urlModifier(url);\n        }\n        return url;\n      };\n      this.setURLModifier = function(transform) {\n        urlModifier = transform;\n        return this;\n      };\n      this.addHandler = function(regex, loader) {\n        handlers.push(regex, loader);\n        return this;\n      };\n      this.removeHandler = function(regex) {\n        const index = handlers.indexOf(regex);\n        if (index !== -1) {\n          handlers.splice(index, 2);\n        }\n        return this;\n      };\n      this.getHandler = function(file) {\n        for (let i2 = 0, l = handlers.length; i2 < l; i2 += 2) {\n          const regex = handlers[i2];\n          const loader = handlers[i2 + 1];\n          if (regex.global) regex.lastIndex = 0;\n          if (regex.test(file)) {\n            return loader;\n          }\n        }\n        return null;\n      };\n    }\n  }\n  const DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();\n  class Loader {\n    constructor(manager) {\n      this.manager = manager !== void 0 ? manager : DefaultLoadingManager;\n      this.crossOrigin = "anonymous";\n      this.withCredentials = false;\n      this.path = "";\n      this.resourcePath = "";\n      this.requestHeader = {};\n    }\n    load() {\n    }\n    loadAsync(url, onProgress) {\n      const scope = this;\n      return new Promise(function(resolve, reject) {\n        scope.load(url, resolve, onProgress, reject);\n      });\n    }\n    parse() {\n    }\n    setCrossOrigin(crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    }\n    setWithCredentials(value) {\n      this.withCredentials = value;\n      return this;\n    }\n    setPath(path) {\n      this.path = path;\n      return this;\n    }\n    setResourcePath(resourcePath) {\n      this.resourcePath = resourcePath;\n      return this;\n    }\n    setRequestHeader(requestHeader) {\n      this.requestHeader = requestHeader;\n      return this;\n    }\n  }\n  Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";\n  const loading = {};\n  class HttpError extends Error {\n    constructor(message, response) {\n      super(message);\n      this.response = response;\n    }\n  }\n  class FileLoader extends Loader {\n    constructor(manager) {\n      super(manager);\n    }\n    load(url, onLoad, onProgress, onError) {\n      if (url === void 0) url = "";\n      if (this.path !== void 0) url = this.path + url;\n      url = this.manager.resolveURL(url);\n      const cached = Cache.get(url);\n      if (cached !== void 0) {\n        this.manager.itemStart(url);\n        setTimeout(() => {\n          if (onLoad) onLoad(cached);\n          this.manager.itemEnd(url);\n        }, 0);\n        return cached;\n      }\n      if (loading[url] !== void 0) {\n        loading[url].push({\n          onLoad,\n          onProgress,\n          onError\n        });\n        return;\n      }\n      loading[url] = [];\n      loading[url].push({\n        onLoad,\n        onProgress,\n        onError\n      });\n      const req = new Request(url, {\n        headers: new Headers(this.requestHeader),\n        credentials: this.withCredentials ? "include" : "same-origin"\n        // An abort controller could be added within a future PR\n      });\n      const mimeType = this.mimeType;\n      const responseType = this.responseType;\n      fetch(req).then((response) => {\n        if (response.status === 200 || response.status === 0) {\n          if (response.status === 0) {\n            console.warn("THREE.FileLoader: HTTP Status 0 received.");\n          }\n          if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {\n            return response;\n          }\n          const callbacks = loading[url];\n          const reader = response.body.getReader();\n          const contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length");\n          const total = contentLength ? parseInt(contentLength) : 0;\n          const lengthComputable = total !== 0;\n          let loaded = 0;\n          const stream = new ReadableStream({\n            start(controller) {\n              readData();\n              function readData() {\n                reader.read().then(({ done, value }) => {\n                  if (done) {\n                    controller.close();\n                  } else {\n                    loaded += value.byteLength;\n                    const event = new ProgressEvent("progress", { lengthComputable, loaded, total });\n                    for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n                      const callback = callbacks[i2];\n                      if (callback.onProgress) callback.onProgress(event);\n                    }\n                    controller.enqueue(value);\n                    readData();\n                  }\n                }, (e) => {\n                  controller.error(e);\n                });\n              }\n            }\n          });\n          return new Response(stream);\n        } else {\n          throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);\n        }\n      }).then((response) => {\n        switch (responseType) {\n          case "arraybuffer":\n            return response.arrayBuffer();\n          case "blob":\n            return response.blob();\n          case "document":\n            return response.text().then((text) => {\n              const parser = new DOMParser();\n              return parser.parseFromString(text, mimeType);\n            });\n          case "json":\n            return response.json();\n          default:\n            if (mimeType === void 0) {\n              return response.text();\n            } else {\n              const re = /charset="?([^;"\\s]*)"?/i;\n              const exec = re.exec(mimeType);\n              const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;\n              const decoder = new TextDecoder(label);\n              return response.arrayBuffer().then((ab) => decoder.decode(ab));\n            }\n        }\n      }).then((data) => {\n        Cache.add(url, data);\n        const callbacks = loading[url];\n        delete loading[url];\n        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n          const callback = callbacks[i2];\n          if (callback.onLoad) callback.onLoad(data);\n        }\n      }).catch((err2) => {\n        const callbacks = loading[url];\n        if (callbacks === void 0) {\n          this.manager.itemError(url);\n          throw err2;\n        }\n        delete loading[url];\n        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n          const callback = callbacks[i2];\n          if (callback.onError) callback.onError(err2);\n        }\n        this.manager.itemError(url);\n      }).finally(() => {\n        this.manager.itemEnd(url);\n      });\n      this.manager.itemStart(url);\n    }\n    setResponseType(value) {\n      this.responseType = value;\n      return this;\n    }\n    setMimeType(value) {\n      this.mimeType = value;\n      return this;\n    }\n  }\n  class Matrix2 {\n    constructor(n11, n12, n21, n22) {\n      Matrix2.prototype.isMatrix2 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n21, n22);\n      }\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 4; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    set(n11, n12, n21, n22) {\n      const te = this.elements;\n      te[0] = n11;\n      te[2] = n12;\n      te[1] = n21;\n      te[3] = n22;\n      return this;\n    }\n  }\n  if (typeof __THREE_DEVTOOLS__ !== "undefined") {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {\n      revision: REVISION\n    } }));\n  }\n  if (typeof window !== "undefined") {\n    if (window.__THREE__) {\n      console.warn("WARNING: Multiple instances of Three.js being imported.");\n    } else {\n      window.__THREE__ = REVISION;\n    }\n  }\n  const LN_SCALE_MIN = -12;\n  const LN_SCALE_MAX = 9;\n  const LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254;\n  const LN_SCALE_ZERO = -30;\n  const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);\n  const SPLAT_TEX_WIDTH_BITS = 11;\n  const SPLAT_TEX_HEIGHT_BITS = 11;\n  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\n  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;\n  const SPLAT_TEX_MIN_HEIGHT = 1;\n  const WASM_SPLAT_SORT = true;\n  function isIntType(type) {\n    return type === "int" || type === "ivec2" || type === "ivec3" || type === "ivec4";\n  }\n  function isUintType(type) {\n    return type === "uint" || type === "uvec2" || type === "uvec3" || type === "uvec4";\n  }\n  function isFloatType(type) {\n    return type === "float" || type === "vec2" || type === "vec3" || type === "vec4";\n  }\n  function isMatFloatType(type) {\n    return type === "mat2" || type === "mat2x2" || type === "mat2x3" || type === "mat2x4" || type === "mat3" || type === "mat3x2" || type === "mat3x3" || type === "mat3x4" || type === "mat4" || type === "mat4x2" || type === "mat4x3" || type === "mat4x4";\n  }\n  function isAllFloatType(type) {\n    return isFloatType(type) || isMatFloatType(type);\n  }\n  function isMat2(type) {\n    return type === "mat2" || type === "mat2x2";\n  }\n  function isMat3(type) {\n    return type === "mat3" || type === "mat3x3";\n  }\n  function isMat4(type) {\n    return type === "mat4" || type === "mat4x4";\n  }\n  function numberAsInt(value) {\n    return Math.trunc(value).toString();\n  }\n  function numberAsUint(value) {\n    const v = Math.max(0, Math.trunc(value));\n    return `${v.toString()}u`;\n  }\n  function numberAsFloat(value) {\n    return value === Number.POSITIVE_INFINITY ? "INFINITY" : value === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(value) ? value.toFixed(1) : value.toString();\n  }\n  function valType(val) {\n    if (val instanceof DynoValue) {\n      return val.type;\n    }\n    const value = val.dynoOut();\n    return value.type;\n  }\n  class DynoValue {\n    constructor(type) {\n      this.__isDynoValue = true;\n      this.type = type;\n    }\n  }\n  class DynoOutput extends DynoValue {\n    constructor(dyno2, key) {\n      super(dyno2.outTypes[key]);\n      this.dyno = dyno2;\n      this.key = key;\n    }\n  }\n  class DynoLiteral extends DynoValue {\n    constructor(type, literal) {\n      super(type);\n      this.literal = literal;\n    }\n    getLiteral() {\n      return this.literal;\n    }\n  }\n  class DynoConst extends DynoLiteral {\n    constructor(type, value) {\n      super(type, "");\n      this.value = value;\n    }\n    getLiteral() {\n      const { type, value } = this;\n      switch (type) {\n        case "bool":\n          return value ? "true" : "false";\n        case "uint":\n          return numberAsUint(value);\n        case "int":\n          return numberAsInt(value);\n        case "float":\n          return numberAsFloat(value);\n        case "bvec2": {\n          const v = value;\n          return `bvec2(${v[0]}, ${v[1]})`;\n        }\n        case "uvec2": {\n          if (value instanceof Vector2) {\n            return `uvec2(${numberAsUint(value.x)}, ${numberAsUint(value.y)})`;\n          }\n          const v = value;\n          return `uvec2(${numberAsUint(v[0])}, ${numberAsUint(v[1])})`;\n        }\n        case "ivec2": {\n          if (value instanceof Vector2) {\n            return `ivec2(${numberAsInt(value.x)}, ${numberAsInt(value.y)})`;\n          }\n          const v = value;\n          return `ivec2(${numberAsInt(v[0])}, ${numberAsInt(v[1])})`;\n        }\n        case "vec2": {\n          if (value instanceof Vector2) {\n            return `vec2(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)})`;\n          }\n          const v = value;\n          return `vec2(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])})`;\n        }\n        case "bvec3": {\n          const v = value;\n          return `bvec3(${v[0]}, ${v[1]}, ${v[2]})`;\n        }\n        case "uvec3": {\n          if (value instanceof Vector3) {\n            return `uvec3(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)})`;\n          }\n          const v = value;\n          return `uvec3(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])})`;\n        }\n        case "ivec3": {\n          if (value instanceof Vector3) {\n            return `ivec3(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)})`;\n          }\n          const v = value;\n          return `ivec3(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])})`;\n        }\n        case "vec3": {\n          if (value instanceof Vector3) {\n            return `vec3(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)})`;\n          }\n          const v = value;\n          return `vec3(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])})`;\n        }\n        case "bvec4": {\n          const v = value;\n          return `bvec4(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]})`;\n        }\n        case "uvec4": {\n          if (value instanceof Vector4) {\n            return `uvec4(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)}, ${numberAsUint(value.w)})`;\n          }\n          const v = value;\n          return `uvec4(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])}, ${numberAsUint(v[3])})`;\n        }\n        case "ivec4": {\n          if (value instanceof Vector4) {\n            return `ivec4(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)}, ${numberAsInt(value.w)})`;\n          }\n          const v = value;\n          return `ivec4(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])}, ${numberAsInt(v[3])})`;\n        }\n        case "vec4": {\n          if (value instanceof Vector4) {\n            return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n          }\n          if (value instanceof Quaternion) {\n            return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n          }\n          const v = value;\n          return `vec4(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])}, ${numberAsFloat(v[3])})`;\n        }\n        case "mat2":\n        case "mat2x2": {\n          const m = value;\n          const e = m instanceof Matrix2 ? m.elements : value;\n          const arg = new Array(4).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat2x3": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat2x4": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3":\n        case "mat3x3": {\n          const m = value;\n          const e = m instanceof Matrix3 ? m.elements : value;\n          const arg = new Array(9).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3x2": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3x4": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4":\n        case "mat4x4": {\n          const m = value;\n          const e = m instanceof Matrix4 ? m.elements : value;\n          const arg = new Array(16).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4x2": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4x3": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        default:\n          throw new Error(`Type not implemented: ${String(type)}`);\n      }\n    }\n  }\n  function dynoConst(type, value) {\n    return new DynoConst(type, value);\n  }\n  const DEFAULT_INDENT = "    ";\n  class Compilation {\n    constructor({ indent } = {}) {\n      this.globals = /* @__PURE__ */ new Set();\n      this.statements = [];\n      this.uniforms = {};\n      this.declares = /* @__PURE__ */ new Set();\n      this.updaters = [];\n      this.sequence = 0;\n      this.indent = DEFAULT_INDENT;\n      this.indent = indent ?? DEFAULT_INDENT;\n    }\n    nextSequence() {\n      return this.sequence++;\n    }\n  }\n  class Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    }) {\n      this.inTypes = inTypes ?? {};\n      this.outTypes = outTypes ?? {};\n      this.inputs = inputs ?? {};\n      this.update = update;\n      this.globals = globals;\n      this.statements = statements;\n      this.generate = generate ?? (({ inputs: inputs2, outputs, compile }) => {\n        var _a2, _b2;\n        return {\n          globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: inputs2, outputs, compile }),\n          statements: (_b2 = this.statements) == null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })\n        };\n      });\n    }\n    get outputs() {\n      const outputs = {};\n      for (const key in this.outTypes) {\n        outputs[key] = new DynoOutput(this, key);\n      }\n      return outputs;\n    }\n    apply(inputs) {\n      Object.assign(this.inputs, inputs);\n      return this.outputs;\n    }\n    compile({\n      inputs,\n      outputs,\n      compile\n    }) {\n      const result = [\n        `// ${this.constructor.name}(${Object.values(inputs).join(", ")}) => (${Object.values(outputs).join(", ")})`\n      ];\n      const declares = [];\n      for (const key in outputs) {\n        const name = outputs[key];\n        if (name && !compile.declares.has(name)) {\n          compile.declares.add(name);\n          declares.push(key);\n        }\n      }\n      const { globals, statements, uniforms } = this.generate({\n        inputs,\n        outputs,\n        compile\n      });\n      for (const global of globals ?? []) {\n        compile.globals.add(global);\n      }\n      for (const key in uniforms) {\n        compile.uniforms[key] = uniforms[key];\n      }\n      if (this.update) {\n        compile.updaters.push(this.update);\n      }\n      for (const key of declares) {\n        const name = outputs[key];\n        if (name) {\n          if (!compile.uniforms[name]) {\n            result.push(`${dynoDeclare(name, this.outTypes[key])};`);\n          }\n        }\n      }\n      if (statements == null ? void 0 : statements.length) {\n        result.push("{");\n        result.push(...statements.map((line) => compile.indent + line));\n        result.push("}");\n      }\n      return result;\n    }\n  }\n  class DynoBlock extends Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      construct\n    }) {\n      super({\n        inTypes,\n        outTypes,\n        inputs,\n        update,\n        globals,\n        generate: (args) => this.generateBlock(args)\n      });\n      this.construct = construct;\n    }\n    generateBlock({\n      inputs,\n      outputs,\n      compile\n    }) {\n      var _a2, _b2;\n      const blockInputs = {};\n      const blockOutputs = {};\n      for (const key in inputs) {\n        if (inputs[key] != null) {\n          blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);\n        }\n      }\n      for (const key in outputs) {\n        if (outputs[key] != null) {\n          blockOutputs[key] = new DynoValue(this.outTypes[key]);\n        }\n      }\n      const options = { roots: [] };\n      const returned = this.construct(blockInputs, blockOutputs, options);\n      for (const global of ((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, compile })) ?? []) {\n        compile.globals.add(global);\n      }\n      const ordering = [];\n      const nodeOuts = /* @__PURE__ */ new Map();\n      function visit(node, outKey, outName) {\n        let outs = nodeOuts.get(node);\n        if (!outs) {\n          outs = {\n            sequence: compile.nextSequence(),\n            outNames: /* @__PURE__ */ new Map(),\n            newOuts: /* @__PURE__ */ new Set()\n          };\n          nodeOuts.set(node, outs);\n          for (const key in node.inputs) {\n            let input = node.inputs[key];\n            while (input) {\n              if (input instanceof DynoValue) {\n                if (input instanceof DynoOutput) {\n                  visit(input.dyno, input.key);\n                }\n                break;\n              }\n              input = input.dynoOut();\n            }\n          }\n          ordering.push(node);\n        }\n        if (outKey) {\n          if (!outName) {\n            outs.newOuts.add(outKey);\n          }\n          outs.outNames.set(outKey, outName ?? `${outKey}_${outs.sequence}`);\n        }\n      }\n      for (const root of options.roots) {\n        visit(root);\n      }\n      for (const key in blockOutputs) {\n        let value = (returned == null ? void 0 : returned[key]) ?? blockOutputs[key];\n        while (value) {\n          if (value instanceof DynoValue) {\n            if (value instanceof DynoOutput) {\n              visit(value.dyno, value.key, outputs[key]);\n            }\n            break;\n          }\n          value = value.dynoOut();\n        }\n        blockOutputs[key] = value;\n      }\n      const steps = [];\n      for (const dyno2 of ordering) {\n        const inputs2 = {};\n        const outputs2 = {};\n        for (const key in dyno2.inputs) {\n          let value = dyno2.inputs[key];\n          while (value) {\n            if (value instanceof DynoValue) {\n              if (value instanceof DynoLiteral) {\n                inputs2[key] = value.getLiteral();\n              } else if (value instanceof DynoOutput) {\n                const source = (_b2 = nodeOuts.get(value.dyno)) == null ? void 0 : _b2.outNames.get(value.key);\n                if (!source) {\n                  throw new Error(\n                    `Source not found for ${value.dyno.constructor.name}.${value.key}`\n                  );\n                }\n                inputs2[key] = source;\n              }\n              break;\n            }\n            value = value.dynoOut();\n          }\n        }\n        const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new Map() };\n        for (const [key, name] of outs.outNames.entries()) {\n          outputs2[key] = name;\n        }\n        const newSteps = dyno2.compile({ inputs: inputs2, outputs: outputs2, compile });\n        steps.push(newSteps);\n      }\n      const literalOutputs = [];\n      for (const key in outputs) {\n        if (blockOutputs[key] instanceof DynoLiteral) {\n          literalOutputs.push(\n            `${outputs[key]} = ${blockOutputs[key].getLiteral()};`\n          );\n        }\n      }\n      if (literalOutputs.length > 0) {\n        steps.push(literalOutputs);\n      }\n      const statements = steps.flatMap((step, index) => {\n        return index === 0 ? step : ["", ...step];\n      });\n      return { statements };\n    }\n  }\n  function dynoBlock(inTypes, outTypes, construct, { update, globals } = {}) {\n    return new DynoBlock({ inTypes, outTypes, construct, update, globals });\n  }\n  function dyno({\n    inTypes,\n    outTypes,\n    inputs,\n    update,\n    globals,\n    statements,\n    generate\n  }) {\n    return new Dyno({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    });\n  }\n  function dynoDeclare(name, type, count) {\n    const typeStr = typeof type === "string" ? type : type.type;\n    if (!typeStr) {\n      throw new Error(`Invalid DynoType: ${String(type)}`);\n    }\n    return `${typeStr} ${name}${count != null ? `[${count}]` : ""}`;\n  }\n  function unindentLines(s) {\n    var _a2;\n    let seenNonEmpty = false;\n    const lines = s.split("\\n").map((line) => {\n      const trimmedLine = line.trimEnd();\n      if (seenNonEmpty) {\n        return trimmedLine;\n      }\n      if (trimmedLine.length > 0) {\n        seenNonEmpty = true;\n        return trimmedLine;\n      }\n      return null;\n    }).filter((line) => line != null);\n    while (lines.length > 0 && lines[lines.length - 1].length === 0) {\n      lines.pop();\n    }\n    if (lines.length === 0) {\n      return [];\n    }\n    const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? void 0 : _a2[0];\n    if (!indent) {\n      return lines;\n    }\n    const regex = new RegExp(`^${indent}`);\n    return lines.map((line) => line.replace(regex, ""));\n  }\n  function unindent(s) {\n    return unindentLines(s).join("\\n");\n  }\n  class UnaryOp extends Dyno {\n    constructor({\n      a,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a) };\n      const outType = outTypeFunc(valType(a));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class BinaryOp extends Dyno {\n    constructor({\n      a,\n      b,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a), b: valType(b) };\n      const outType = outTypeFunc(valType(a), valType(b));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a, b } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  const f32buffer = new Float32Array(1);\n  const u32buffer = new Uint32Array(f32buffer.buffer);\n  function toHalf(f) {\n    f32buffer[0] = f;\n    const bits2 = u32buffer[0];\n    const sign = bits2 >> 31 & 1;\n    const exp = bits2 >> 23 & 255;\n    const frac = bits2 & 8388607;\n    const halfSign = sign << 15;\n    if (exp === 255) {\n      if (frac !== 0) {\n        return halfSign | 32767;\n      }\n      return halfSign | 31744;\n    }\n    const newExp = exp - 127 + 15;\n    if (newExp >= 31) {\n      return halfSign | 31744;\n    }\n    if (newExp <= 0) {\n      if (newExp < -10) {\n        return halfSign;\n      }\n      const subFrac = (frac | 8388608) >> 1 - newExp + 13;\n      return halfSign | subFrac;\n    }\n    const halfFrac = frac >> 13;\n    return halfSign | newExp << 10 | halfFrac;\n  }\n  function fromHalf(h) {\n    const sign = h >> 15 & 1;\n    const exp = h >> 10 & 31;\n    const frac = h & 1023;\n    let f32bits;\n    if (exp === 0) {\n      if (frac === 0) {\n        f32bits = sign << 31;\n      } else {\n        let mant = frac;\n        let e = -14;\n        while ((mant & 1024) === 0) {\n          mant <<= 1;\n          e--;\n        }\n        mant &= 1023;\n        const newExp = e + 127;\n        const newFrac = mant << 13;\n        f32bits = sign << 31 | newExp << 23 | newFrac;\n      }\n    } else if (exp === 31) {\n      if (frac === 0) {\n        f32bits = sign << 31 | 2139095040;\n      } else {\n        f32bits = sign << 31 | 2143289344;\n      }\n    } else {\n      const newExp = exp - 15 + 127;\n      const newFrac = frac << 13;\n      f32bits = sign << 31 | newExp << 23 | newFrac;\n    }\n    u32buffer[0] = f32bits;\n    return f32buffer[0];\n  }\n  function floatToUint8(v) {\n    return Math.max(0, Math.min(255, Math.round(v * 255)));\n  }\n  function getArrayBuffers(ctx) {\n    const buffers = [];\n    const seen = /* @__PURE__ */ new Set();\n    function traverse(obj) {\n      if (obj && typeof obj === "object" && !seen.has(obj)) {\n        seen.add(obj);\n        if (obj instanceof ArrayBuffer) {\n          buffers.push(obj);\n        } else if (ArrayBuffer.isView(obj)) {\n          buffers.push(obj.buffer);\n        } else if (Array.isArray(obj)) {\n          obj.forEach(traverse);\n        } else {\n          Object.values(obj).forEach(traverse);\n        }\n      }\n    }\n    traverse(ctx);\n    return buffers;\n  }\n  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const uA = floatToUint8(opacity);\n    const uQuat = encodeQuatOctXy88R8(\n      new Quaternion(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\n  }\n  function setPackedSplatCenter(packedSplats, index, x2, y, z) {\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;\n  }\n  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ) {\n    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const i4 = index * 4;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\n  }\n  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {\n    const uQuat = encodeQuatOctXy88R8(\n      new Quaternion(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const i4 = index * 4;\n    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\n  }\n  function setPackedSplatRgba(packedSplats, index, r, g, b, a) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const uA = floatToUint8(a);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n  }\n  function setPackedSplatRgb(packedSplats, index, r, g, b) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;\n  }\n  function setPackedSplatOpacity(packedSplats, index, opacity) {\n    const uA = floatToUint8(opacity);\n    const i4 = index * 4;\n    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\n  }\n  const packedCenter = new Vector3();\n  const packedScales = new Vector3();\n  const packedQuaternion = new Quaternion();\n  const packedColor = new Color();\n  const packedFields = {\n    center: packedCenter,\n    scales: packedScales,\n    quaternion: packedQuaternion,\n    color: packedColor,\n    opacity: 0\n  };\n  function unpackSplat(packedSplats, index) {\n    const result = packedFields;\n    const i4 = index * 4;\n    const word0 = packedSplats[i4];\n    const word1 = packedSplats[i4 + 1];\n    const word2 = packedSplats[i4 + 2];\n    const word3 = packedSplats[i4 + 3];\n    result.color.set(\n      (word0 & 255) / 255,\n      (word0 >>> 8 & 255) / 255,\n      (word0 >>> 16 & 255) / 255\n    );\n    result.opacity = (word0 >>> 24 & 255) / 255;\n    result.center.set(\n      fromHalf(word1 & 65535),\n      fromHalf(word1 >>> 16 & 65535),\n      fromHalf(word2 & 65535)\n    );\n    const uScalesX = word3 & 255;\n    result.scales.x = uScalesX === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesX - 1) * LN_RESCALE);\n    const uScalesY = word3 >>> 8 & 255;\n    result.scales.y = uScalesY === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesY - 1) * LN_RESCALE);\n    const uScalesZ = word3 >>> 16 & 255;\n    result.scales.z = uScalesZ === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesZ - 1) * LN_RESCALE);\n    const uQuat = word2 >>> 16 & 65535 | word3 >>> 8 & 16711680;\n    decodeQuatOctXy88R8(uQuat, result.quaternion);\n    return result;\n  }\n  function getTextureSize(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    const maxSplats = width * height * depth;\n    return { width, height, depth, maxSplats };\n  }\n  function computeMaxSplats(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    return width * height * depth;\n  }\n  const IDENT_VERTEX_SHADER = unindent(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);\n  function encodeQuatOctXy88R8(q) {\n    const qnorm = q.clone().normalize();\n    if (qnorm.w < 0) {\n      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\n    }\n    const theta = 2 * Math.acos(qnorm.w);\n    const xyz_norm = Math.sqrt(\n      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\n    );\n    const axis = xyz_norm < 1e-6 ? new Vector3(1, 0, 0) : new Vector3(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);\n    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);\n    let p_x = axis.x / sum;\n    let p_y = axis.y / sum;\n    if (axis.z < 0) {\n      const tmp = p_x;\n      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\n      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\n    }\n    const u_f = p_x * 0.5 + 0.5;\n    const v_f = p_y * 0.5 + 0.5;\n    const quantU = Math.round(u_f * 255);\n    const quantV = Math.round(v_f * 255);\n    const angleInt = Math.round(theta * (255 / Math.PI));\n    return angleInt << 16 | quantV << 8 | quantU;\n  }\n  function decodeQuatOctXy88R8(encoded, out) {\n    const quantU = encoded & 255;\n    const quantV = encoded >>> 8 & 255;\n    const angleInt = encoded >>> 16 & 255;\n    const u_f = quantU / 255;\n    const v_f = quantV / 255;\n    let f_x = (u_f - 0.5) * 2;\n    let f_y = (v_f - 0.5) * 2;\n    const f_z = 1 - (Math.abs(f_x) + Math.abs(f_y));\n    const t = Math.max(-f_z, 0);\n    f_x += f_x >= 0 ? -t : t;\n    f_y += f_y >= 0 ? -t : t;\n    const axis = new Vector3(f_x, f_y, f_z).normalize();\n    const theta = angleInt / 255 * Math.PI;\n    const halfTheta = theta * 0.5;\n    const s = Math.sin(halfTheta);\n    const w = Math.cos(halfTheta);\n    out.set(axis.x * s, axis.y * s, axis.z * s, w);\n    return out;\n  }\n  function packSint8Bytes(b0, b1, b22, b3) {\n    const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\n    const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));\n    const clampedB2 = Math.max(-127, Math.min(127, b22 * 127));\n    const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\n    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;\n  }\n  function encodeSh1Rgb(sh1Array, index, sh1Rgb) {\n    const base = index * 2;\n    for (let i2 = 0; i2 < 9; ++i2) {\n      const value = Math.max(-63, Math.min(63, sh1Rgb[i2] * 63)) & 127;\n      const bitStart = i2 * 7;\n      const bitEnd = bitStart + 7;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh1Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh1Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function encodeSh2Rgb(sh2Array, index, sh2Rgb) {\n    sh2Array[index * 4 + 0] = packSint8Bytes(\n      sh2Rgb[0],\n      sh2Rgb[1],\n      sh2Rgb[2],\n      sh2Rgb[3]\n    );\n    sh2Array[index * 4 + 1] = packSint8Bytes(\n      sh2Rgb[4],\n      sh2Rgb[5],\n      sh2Rgb[6],\n      sh2Rgb[7]\n    );\n    sh2Array[index * 4 + 2] = packSint8Bytes(\n      sh2Rgb[8],\n      sh2Rgb[9],\n      sh2Rgb[10],\n      sh2Rgb[11]\n    );\n    sh2Array[index * 4 + 3] = packSint8Bytes(\n      sh2Rgb[12],\n      sh2Rgb[13],\n      sh2Rgb[14],\n      0\n    );\n  }\n  function encodeSh3Rgb(sh3Array, index, sh3Rgb) {\n    const base = index * 4;\n    for (let i2 = 0; i2 < 21; ++i2) {\n      const value = Math.max(-31, Math.min(31, sh3Rgb[i2] * 31)) & 63;\n      const bitStart = i2 * 6;\n      const bitEnd = bitStart + 6;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh3Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh3Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function decompressPartialGzip(fileBytes, numBytes) {\n    const chunks = [];\n    let totalBytes = 0;\n    let result = null;\n    const gunzip = new Gunzip((data, final) => {\n      chunks.push(data);\n      totalBytes += data.length;\n      if (final || totalBytes >= numBytes) {\n        const allBytes = new Uint8Array(totalBytes);\n        let offset2 = 0;\n        for (const chunk of chunks) {\n          allBytes.set(chunk, offset2);\n          offset2 += chunk.length;\n        }\n        result = allBytes.slice(0, numBytes);\n      }\n    });\n    const CHUNK_SIZE = 1024;\n    let offset = 0;\n    while (result == null && offset < fileBytes.length) {\n      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);\n      gunzip.push(chunk, false);\n      offset += CHUNK_SIZE;\n    }\n    if (result == null) {\n      gunzip.push(new Uint8Array(), true);\n      if (result == null) {\n        throw new Error("Failed to decompress partial gzip");\n      }\n    }\n    return result;\n  }\n  class GunzipReader {\n    constructor({\n      fileBytes,\n      chunkBytes = 64 * 1024\n    }) {\n      this.fileBytes = fileBytes;\n      this.chunkBytes = chunkBytes;\n      this.offset = 0;\n      this.chunks = [];\n      this.totalBytes = 0;\n      this.gunzip = new Gunzip((chunk, _final) => {\n        this.chunks.push(chunk);\n        this.totalBytes += chunk.length;\n      });\n    }\n    read(numBytes) {\n      while (this.totalBytes < numBytes && this.offset < this.fileBytes.length) {\n        const end = Math.min(\n          this.offset + this.chunkBytes,\n          this.fileBytes.length\n        );\n        this.gunzip.push(this.fileBytes.subarray(this.offset, end), false);\n        this.offset = end;\n      }\n      if (this.totalBytes < numBytes && this.offset >= this.fileBytes.length) {\n        this.gunzip.push(new Uint8Array(0), true);\n      }\n      if (this.totalBytes < numBytes) {\n        throw new Error(\n          `Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`\n        );\n      }\n      const allBytes = new Uint8Array(this.totalBytes);\n      let outOffset = 0;\n      for (const chunk of this.chunks) {\n        allBytes.set(chunk, outOffset);\n        outOffset += chunk.length;\n      }\n      const result = allBytes.subarray(0, numBytes);\n      this.chunks = [allBytes.subarray(numBytes)];\n      this.totalBytes -= numBytes;\n      return result;\n    }\n  }\n  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {\n    const numSplats = Math.floor(fileBytes.length / 32);\n    if (numSplats * 32 !== fileBytes.length) {\n      throw new Error("Invalid .splat file size");\n    }\n    initNumSplats(numSplats);\n    const f32 = new Float32Array(fileBytes.buffer);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i322 = i2 * 32;\n      const i8 = i2 * 8;\n      const x2 = f32[i8 + 0];\n      const y = f32[i8 + 1];\n      const z = f32[i8 + 2];\n      const scaleX = f32[i8 + 3];\n      const scaleY = f32[i8 + 4];\n      const scaleZ = f32[i8 + 5];\n      const r = fileBytes[i322 + 24] / 255;\n      const g = fileBytes[i322 + 25] / 255;\n      const b = fileBytes[i322 + 26] / 255;\n      const opacity = fileBytes[i322 + 27] / 255;\n      const quatW = (fileBytes[i322 + 28] - 128) / 128;\n      const quatX = (fileBytes[i322 + 29] - 128) / 128;\n      const quatY = (fileBytes[i322 + 30] - 128) / 128;\n      const quatZ = (fileBytes[i322 + 31] - 128) / 128;\n      splatCallback(\n        i2,\n        x2,\n        y,\n        z,\n        scaleX,\n        scaleY,\n        scaleZ,\n        quatX,\n        quatY,\n        quatZ,\n        quatW,\n        opacity,\n        r,\n        g,\n        b\n      );\n    }\n  }\n  function unpackAntiSplat(fileBytes) {\n    let numSplats = 0;\n    let maxSplats = 0;\n    let packedArray = new Uint32Array(0);\n    decodeAntiSplat(\n      fileBytes,\n      (cbNumSplats) => {\n        numSplats = cbNumSplats;\n        maxSplats = computeMaxSplats(numSplats);\n        packedArray = new Uint32Array(maxSplats * 4);\n      },\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n      }\n    );\n    return { packedArray, numSplats };\n  }\n  const KSPLAT_COMPRESSION = {\n    0: {\n      bytesPerCenter: 12,\n      bytesPerScale: 12,\n      bytesPerRotation: 16,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 4,\n      scaleOffsetBytes: 12,\n      rotationOffsetBytes: 24,\n      colorOffsetBytes: 40,\n      sphericalHarmonicsOffsetBytes: 44,\n      scaleRange: 1\n    },\n    1: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 2,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    },\n    2: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 1,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    }\n  };\n  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        splatCallback(\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1 && sh1) {\n          for (const [i22, key] of sh1Index.entries()) {\n            sh1[i22] = getSh(splatOffset, key);\n          }\n          if (sh2) {\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n          }\n          if (sh3) {\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n  }\n  function unpackKsplat(fileBytes) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    const splatCount = header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    const numSplats = splatCount;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        setPackedSplat(\n          packedArray,\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1) {\n          if (sh1) {\n            if (!extra.sh1) {\n              extra.sh1 = new Uint32Array(numSplats * 2);\n            }\n            for (const [i22, key] of sh1Index.entries()) {\n              sh1[i22] = getSh(splatOffset, key);\n            }\n            encodeSh1Rgb(extra.sh1, i2, sh1);\n          }\n          if (sh2) {\n            if (!extra.sh2) {\n              extra.sh2 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n            encodeSh2Rgb(extra.sh2, i2, sh2);\n          }\n          if (sh3) {\n            if (!extra.sh3) {\n              extra.sh3 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n            encodeSh3Rgb(extra.sh3, i2, sh3);\n          }\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n    return { packedArray, numSplats, extra };\n  }\n  const Gsplat = { type: "Gsplat" };\n  const TPackedSplats = { type: "PackedSplats" };\n  const readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ packedSplats, index });\n  const readPackedSplatRange = (packedSplats, index, base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count });\n  const splitGsplat = (gsplat) => new SplitGsplat({ gsplat });\n  const combineGsplat = ({\n    gsplat,\n    flags,\n    index,\n    center,\n    scales,\n    quaternion,\n    rgba,\n    rgb,\n    opacity,\n    x: x2,\n    y,\n    z,\n    r,\n    g,\n    b\n  }) => {\n    return new CombineGsplat({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    });\n  };\n  const transformGsplat = (gsplat, {\n    scale,\n    rotate,\n    translate,\n    recolor\n  }) => {\n    return new TransformGsplat({ gsplat, scale, rotate, translate, recolor });\n  };\n  const defineGsplat = unindent(`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`);\n  const definePackedSplats = unindent(`\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n`);\n  const defineReadPackedSplat = unindent(`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n`);\n  class ReadPackedSplat extends Dyno {\n    constructor({\n      packedSplats,\n      index\n    }) {\n      super({\n        inTypes: { packedSplats: TPackedSplats, index: "int" },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2) {\n            statements = unindentLines(`\n            if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${index2}, ${gsplat})) {\n              bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n              ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${gsplat}.flags = 0u;\n            }\n          `);\n          } else {\n            statements = [`${gsplat}.flags = 0u;`];\n          }\n          statements.push(`${gsplat}.index = ${index2 ?? "0"};`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  class ReadPackedSplatRange extends Dyno {\n    constructor({\n      packedSplats,\n      index,\n      base,\n      count\n    }) {\n      super({\n        inTypes: {\n          packedSplats: TPackedSplats,\n          index: "int",\n          base: "int",\n          count: "int"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index, base, count },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2, base: base2, count: count2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2 && base2 && count2) {\n            statements = unindentLines(`\n            ${gsplat}.flags = 0u;\n            if ((${index2} >= ${base2}) && (${index2} < (${base2} + ${count2}))) {\n              if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${index2}, ${gsplat})) {\n                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `);\n          } else {\n            statements = [`${gsplat}.flags = 0u;`];\n          }\n          statements.push(`${gsplat}.index = ${index2 ?? "0"};`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  class SplitGsplat extends Dyno {\n    constructor({ gsplat }) {\n      super({\n        inTypes: { gsplat: Gsplat },\n        outTypes: {\n          flags: "uint",\n          active: "bool",\n          index: "int",\n          center: "vec3",\n          scales: "vec3",\n          quaternion: "vec4",\n          rgba: "vec4",\n          rgb: "vec3",\n          opacity: "float",\n          x: "float",\n          y: "float",\n          z: "float",\n          r: "float",\n          g: "float",\n          b: "float"\n        },\n        inputs: { gsplat },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: gsplat2 } = inputs;\n          const {\n            flags,\n            active,\n            index,\n            center,\n            scales,\n            quaternion,\n            rgba,\n            rgb,\n            opacity,\n            x: x2,\n            y,\n            z,\n            r,\n            g,\n            b\n          } = outputs;\n          return [\n            !flags ? null : `${flags} = ${gsplat2 ? `${gsplat2}.flags` : "0u"};`,\n            !active ? null : `${active} = isGsplatActive(${gsplat2 ? `${gsplat2}.flags` : "0u"});`,\n            !index ? null : `${index} = ${gsplat2 ? `${gsplat2}.index` : "0"};`,\n            !center ? null : `${center} = ${gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)"};`,\n            !scales ? null : `${scales} = ${gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)"};`,\n            !quaternion ? null : `${quaternion} = ${gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};`,\n            !rgba ? null : `${rgba} = ${gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};`,\n            !rgb ? null : `${rgb} = ${gsplat2 ? `${gsplat2}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};`,\n            !opacity ? null : `${opacity} = ${gsplat2 ? `${gsplat2}.rgba.a` : "0.0"};`,\n            !x2 ? null : `${x2} = ${gsplat2 ? `${gsplat2}.center.x` : "0.0"};`,\n            !y ? null : `${y} = ${gsplat2 ? `${gsplat2}.center.y` : "0.0"};`,\n            !z ? null : `${z} = ${gsplat2 ? `${gsplat2}.center.z` : "0.0"};`,\n            !r ? null : `${r} = ${gsplat2 ? `${gsplat2}.rgba.r` : "0.0"};`,\n            !g ? null : `${g} = ${gsplat2 ? `${gsplat2}.rgba.g` : "0.0"};`,\n            !b ? null : `${b} = ${gsplat2 ? `${gsplat2}.rgba.b` : "0.0"};`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class CombineGsplat extends Dyno {\n    constructor({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          flags: "uint",\n          index: "int",\n          center: "vec3",\n          scales: "vec3",\n          quaternion: "vec4",\n          rgba: "vec4",\n          rgb: "vec3",\n          opacity: "float",\n          x: "float",\n          y: "float",\n          z: "float",\n          r: "float",\n          g: "float",\n          b: "float"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: {\n          gsplat,\n          flags,\n          index,\n          center,\n          scales,\n          quaternion,\n          rgba,\n          rgb,\n          opacity,\n          x: x2,\n          y,\n          z,\n          r,\n          g,\n          b\n        },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: outGsplat } = outputs;\n          if (!outGsplat) {\n            return [];\n          }\n          const {\n            gsplat: gsplat2,\n            flags: flags2,\n            index: index2,\n            center: center2,\n            scales: scales2,\n            quaternion: quaternion2,\n            rgba: rgba2,\n            rgb: rgb2,\n            opacity: opacity2,\n            x: x22,\n            y: y2,\n            z: z2,\n            r: r2,\n            g: g2,\n            b: b22\n          } = inputs;\n          return [\n            `${outGsplat}.flags = ${flags2 ?? (gsplat2 ? `${gsplat2}.flags` : "0u")};`,\n            `${outGsplat}.index = ${index2 ?? (gsplat2 ? `${gsplat2}.index` : "0")};`,\n            `${outGsplat}.center = ${center2 ?? (gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)")};`,\n            `${outGsplat}.scales = ${scales2 ?? (gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)")};`,\n            `${outGsplat}.quaternion = ${quaternion2 ?? (gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,\n            `${outGsplat}.rgba = ${rgba2 ?? (gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,\n            !rgb2 ? null : `${outGsplat}.rgba.rgb = ${rgb2};`,\n            !opacity2 ? null : `${outGsplat}.rgba.a = ${opacity2};`,\n            !x22 ? null : `${outGsplat}.center.x = ${x22};`,\n            !y2 ? null : `${outGsplat}.center.y = ${y2};`,\n            !z2 ? null : `${outGsplat}.center.z = ${z2};`,\n            !r2 ? null : `${outGsplat}.rgba.r = ${r2};`,\n            !g2 ? null : `${outGsplat}.rgba.g = ${g2};`,\n            !b22 ? null : `${outGsplat}.rgba.b = ${b22};`\n          ].filter(Boolean);\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  unindent(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n`);\n  class TransformGsplat extends Dyno {\n    constructor({\n      gsplat,\n      scale,\n      rotate,\n      translate,\n      recolor\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          scale: "float",\n          rotate: "vec4",\n          translate: "vec3",\n          recolor: "vec4"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { gsplat, scale, rotate, translate, recolor },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs, compile }) => {\n          const { gsplat: gsplat2 } = outputs;\n          if (!gsplat2 || !inputs.gsplat) {\n            return [];\n          }\n          const { scale: scale2, rotate: rotate2, translate: translate2, recolor: recolor2 } = inputs;\n          const indent = compile.indent;\n          const statements = [\n            `${gsplat2} = ${inputs.gsplat};`,\n            `if (isGsplatActive(${gsplat2}.flags)) {`,\n            scale2 ? `${indent}${gsplat2}.center *= ${scale2};` : null,\n            rotate2 ? `${indent}${gsplat2}.center = quatVec(${rotate2}, ${gsplat2}.center);` : null,\n            translate2 ? `${indent}${gsplat2}.center += ${translate2};` : null,\n            scale2 ? `${indent}${gsplat2}.scales *= ${scale2};` : null,\n            rotate2 ? `${indent}${gsplat2}.quaternion = quatQuat(${rotate2}, ${gsplat2}.quaternion);` : null,\n            recolor2 ? `${indent}${gsplat2}.rgba *= ${recolor2};` : null,\n            "}"\n          ].filter(Boolean);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  const outputPackedSplat = (gsplat) => new OutputPackedSplat({ gsplat });\n  class OutputPackedSplat extends Dyno {\n    constructor({ gsplat }) {\n      super({\n        inTypes: { gsplat: Gsplat },\n        inputs: { gsplat },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { output } = outputs;\n          if (!output) {\n            return [];\n          }\n          const { gsplat: gsplat2 } = inputs;\n          if (gsplat2) {\n            return unindentLines(`\n            if (isGsplatActive(${gsplat2}.flags)) {\n              ${output} = packSplat(${gsplat2}.center, ${gsplat2}.scales, ${gsplat2}.quaternion, ${gsplat2}.rgba);\n            } else {\n              ${output} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `);\n          }\n          return [`${output} = uvec4(0u, 0u, 0u, 0u);`];\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "output");\n    }\n  }\n  class OutputRgba8 extends Dyno {\n    constructor({ rgba8 }) {\n      super({\n        inTypes: { rgba8: "vec4" },\n        inputs: { rgba8 },\n        statements: ({ inputs, outputs }) => [\n          `target = ${inputs.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`\n        ]\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "rgba8");\n    }\n  }\n  class DynoUniform extends Dyno {\n    constructor({\n      key,\n      type,\n      count,\n      value,\n      update,\n      globals\n    }) {\n      key = key ?? "value";\n      super({\n        outTypes: { [key]: type },\n        update: () => {\n          if (update) {\n            const value2 = update(this.value);\n            if (value2 !== void 0) {\n              this.value = value2;\n            }\n          }\n          this.uniform.value = this.value;\n        },\n        generate: ({ inputs, outputs }) => {\n          const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) ?? [];\n          const uniforms = {};\n          const name = outputs[key];\n          if (name) {\n            allGlobals.push(`uniform ${dynoDeclare(name, type, count)};`);\n            uniforms[name] = this.uniform;\n          }\n          return { globals: allGlobals, uniforms };\n        }\n      });\n      this.type = type;\n      this.count = count;\n      this.value = value;\n      this.uniform = { value };\n      this.outKey = key;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class DynoInt extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "int", value, update });\n    }\n  }\n  class DynoFloat extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "float", value, update });\n    }\n  }\n  class DynoVec3 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "vec3", value, update });\n    }\n  }\n  class DynoVec4 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "vec4", value, update });\n    }\n  }\n  class DynoUsampler2DArray extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "usampler2DArray", value, update });\n    }\n  }\n  class DynoProgram {\n    constructor({\n      graph,\n      inputs,\n      outputs,\n      template\n    }) {\n      this.graph = graph;\n      this.template = template;\n      this.inputs = inputs ?? {};\n      this.outputs = outputs ?? {};\n      const compile = new Compilation({ indent: this.template.indent });\n      for (const key in this.outputs) {\n        if (this.outputs[key]) {\n          compile.declares.add(this.outputs[key]);\n        }\n      }\n      const statements = graph.compile({\n        inputs: this.inputs,\n        outputs: this.outputs,\n        compile\n      });\n      this.shader = template.generate({ globals: compile.globals, statements });\n      this.uniforms = compile.uniforms;\n      this.updaters = compile.updaters;\n    }\n    prepareMaterial() {\n      return getMaterial(this);\n    }\n    update() {\n      for (const updater of this.updaters) {\n        updater();\n      }\n    }\n  }\n  class DynoProgramTemplate {\n    constructor(template) {\n      const globals = template.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m);\n      const statements = template.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);\n      if (!globals || !statements) {\n        throw new Error(\n          "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"\n        );\n      }\n      this.before = template.substring(0, globals.index);\n      this.between = template.substring(\n        globals.index + globals[0].length,\n        statements.index\n      );\n      this.after = template.substring(\n        statements.index + statements[0].length\n      );\n      this.indent = statements[1];\n    }\n    generate({\n      globals,\n      statements\n    }) {\n      return this.before + Array.from(globals).join("\\n\\n") + this.between + statements.map((s) => this.indent + s).join("\\n") + this.after;\n    }\n  }\n  const programMaterial = /* @__PURE__ */ new Map();\n  function getMaterial(program) {\n    let material = programMaterial.get(program);\n    if (material) {\n      return material;\n    }\n    material = new RawShaderMaterial({\n      glslVersion: GLSL3,\n      vertexShader: IDENT_VERTEX_SHADER,\n      fragmentShader: program.shader,\n      uniforms: program.uniforms\n    });\n    programMaterial.set(program, material);\n    return material;\n  }\n  function addOutputType(a, b, operation = "add") {\n    const error = () => {\n      throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n    };\n    if (a === b) return a;\n    if (a === "int") {\n      if (isIntType(b)) return b;\n      error();\n    }\n    if (b === "int") {\n      if (isIntType(a)) return a;\n      error();\n    }\n    if (a === "uint") {\n      if (isUintType(b)) return b;\n      error();\n    }\n    if (b === "uint") {\n      if (isUintType(a)) return a;\n      error();\n    }\n    if (a === "float") {\n      if (isAllFloatType(b)) return b;\n      error();\n    }\n    if (b === "float") {\n      if (isAllFloatType(a)) return a;\n      error();\n    }\n    throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n  }\n  function subOutputType(a, b) {\n    return addOutputType(a, b, "sub");\n  }\n  function mulOutputType(a, b) {\n    const error = () => {\n      throw new Error(`Invalid mul types: ${a}, ${b}`);\n    };\n    const result = (value) => value;\n    if (a === "int") {\n      if (isIntType(b)) return result(b);\n      error();\n    }\n    if (b === "int") {\n      if (isIntType(a)) return result(a);\n      error();\n    }\n    if (a === "uint") {\n      if (isUintType(b)) return result(b);\n      error();\n    }\n    if (b === "uint") {\n      if (isUintType(a)) return result(a);\n      error();\n    }\n    if (a === "float") {\n      if (isAllFloatType(b)) return result(b);\n      error();\n    }\n    if (b === "float") {\n      if (isAllFloatType(a)) return result(a);\n      error();\n    }\n    if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {\n      if (a === b) return result(a);\n      error();\n    }\n    if (a === "vec2") {\n      if (b === "vec2" || isMat2(b)) return result("vec2");\n      if (b === "mat3x2") return result("vec3");\n      if (b === "mat4x2") return result("vec4");\n      error();\n    }\n    if (a === "vec3") {\n      if (b === "mat2x3") return result("vec2");\n      if (b === "vec3" || isMat3(b)) return result("vec3");\n      if (b === "mat4x3") return result("vec4");\n      error();\n    }\n    if (a === "vec4") {\n      if (b === "mat2x4") return result("vec2");\n      if (b === "mat3x4") return result("vec3");\n      if (b === "vec4" || isMat4(b)) return result("vec4");\n      error();\n    }\n    if (b === "vec2") {\n      if (isMat2(a)) return result("vec2");\n      if (a === "mat2x3") return result("vec3");\n      if (a === "mat2x4") return result("vec4");\n      error();\n    }\n    if (b === "vec3") {\n      if (a === "mat3x2") return result("vec2");\n      if (isMat3(a)) return result("vec3");\n      if (a === "mat3x4") return result("vec4");\n      error();\n    }\n    if (b === "vec4") {\n      if (a === "mat4x2") return result("vec2");\n      if (a === "mat4x3") return result("vec3");\n      if (isMat4(a)) return result("vec4");\n      error();\n    }\n    if (isMat2(a)) {\n      if (isMat2(b)) return result("mat2");\n      if (b === "mat3x2") return result("mat3x2");\n      if (b === "mat4x2") return result("mat4x2");\n      error();\n    }\n    if (a === "mat2x3") {\n      if (isMat2(b)) return result("mat2x3");\n      if (b === "mat3x2") return result("mat3");\n      if (b === "mat4x2") return result("mat4x3");\n      error();\n    }\n    if (a === "mat2x4") {\n      if (isMat2(b)) return result("mat2x4");\n      if (b === "mat3x2") return result("mat3x4");\n      if (b === "mat4x2") return result("mat4");\n      error();\n    }\n    if (a === "mat3x2") {\n      if (b === "mat2x3") return result("mat2");\n      if (isMat3(b)) return result("mat3x2");\n      if (b === "mat4x3") return result("mat4x2");\n      error();\n    }\n    if (isMat3(a)) {\n      if (b === "mat2x3") return result("mat2x3");\n      if (isMat3(b)) return result("mat3");\n      if (b === "mat4x3") return result("mat4x3");\n      error();\n    }\n    if (a === "mat3x4") {\n      if (b === "mat2x3") return result("mat2x4");\n      if (isMat3(b)) return result("mat3x4");\n      if (b === "mat4x3") return result("mat4");\n      error();\n    }\n    if (a === "mat4x2") {\n      if (b === "mat2x4") return result("mat2");\n      if (b === "mat3x4") return result("mat3x2");\n      if (isMat4(b)) return result("mat4x2");\n      error();\n    }\n    if (a === "mat4x3") {\n      if (b === "mat2x4") return result("mat2x3");\n      if (b === "mat3x4") return result("mat3");\n      if (isMat4(b)) return result("mat4x3");\n      error();\n    }\n    if (isMat4(a)) {\n      if (b === "mat2x4") return result("mat2x4");\n      if (b === "mat3x4") return result("mat3x4");\n      if (isMat4(b)) return result("mat4");\n      error();\n    }\n    throw new Error(`Invalid mul types: ${a}, ${b}`);\n  }\n  const add = (a, b) => new Add({ a, b });\n  const sub = (a, b) => new Sub({ a, b });\n  const mul = (a, b) => new Mul({ a, b });\n  class Add extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "sum", outTypeFunc: addOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.sum} = ${inputs.a} + ${inputs.b};`];\n      };\n    }\n  }\n  class Sub extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "difference", outTypeFunc: subOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.difference} = ${inputs.a} - ${inputs.b};`];\n      };\n    }\n  }\n  class Mul extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "product", outTypeFunc: mulOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.product} = ${inputs.a} * ${inputs.b};`];\n      };\n    }\n  }\n  const normalize = (a) => new Normalize({ a });\n  const extendVec = (a, b) => new ExtendVec({ a, b });\n  class Normalize extends UnaryOp {\n    constructor({ a }) {\n      super({ a, outTypeFunc: (aType) => aType, outKey: "normalize" });\n      this.statements = ({ inputs, outputs }) => [\n        `${outputs.normalize} = normalize(${inputs.a});`\n      ];\n    }\n  }\n  function extendVecOutputType(type) {\n    if (type === "float") return "vec2";\n    if (type === "vec2") return "vec3";\n    if (type === "vec3") return "vec4";\n    throw new Error("Invalid type");\n  }\n  class ExtendVec extends BinaryOp {\n    constructor({ a, b }) {\n      const type = valType(a);\n      const outType = extendVecOutputType(type);\n      super({ a, b, outKey: "extend", outTypeFunc: () => outType });\n      this.statements = ({ inputs, outputs }) => [\n        `${outputs.extend} = ${outType}(${inputs.a}, ${inputs.b});`\n      ];\n    }\n  }\n  const transformPos = (position, {\n    scale,\n    scales,\n    rotate,\n    translate\n  }) => {\n    return new TransformPosition({ position, scale, scales, rotate, translate }).outputs.position;\n  };\n  const transformDir = (dir, {\n    scale,\n    scales,\n    rotate\n  }) => {\n    return new TransformDir({ dir, scale, scales, rotate }).outputs.dir;\n  };\n  class TransformPosition extends Dyno {\n    constructor({\n      position,\n      scale,\n      scales,\n      rotate,\n      translate\n    }) {\n      super({\n        inTypes: {\n          position: "vec3",\n          scale: "float",\n          scales: "vec3",\n          rotate: "vec4",\n          translate: "vec3"\n        },\n        outTypes: { position: "vec3" },\n        inputs: { position, scale, scales, rotate, translate },\n        statements: ({ inputs, outputs }) => {\n          const { position: position2 } = outputs;\n          if (!position2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2, translate: translate2 } = inputs;\n          return [\n            `${position2} = ${inputs.position ?? "vec3(0.0, 0.0, 0.0)"};`,\n            !scale2 ? null : `${position2} *= ${scale2};`,\n            !scales2 ? null : `${position2} *= ${scales2};`,\n            !rotate2 ? null : `${position2} = quatVec(${rotate2}, ${position2});`,\n            !translate2 ? null : `${position2} += ${translate2};`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class TransformDir extends Dyno {\n    constructor({\n      dir,\n      scale,\n      scales,\n      rotate\n    }) {\n      super({\n        inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },\n        outTypes: { dir: "vec3" },\n        inputs: { dir, scale, scales, rotate },\n        statements: ({ inputs, outputs }) => {\n          const { dir: dir2 } = outputs;\n          if (!dir2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2 } = inputs;\n          return [\n            `${dir2} = ${inputs.dir ?? "vec3(0.0, 0.0, 0.0)"};`,\n            !scale2 ? null : `${dir2} *= ${scale2};`,\n            !scales2 ? null : `${dir2} *= ${scales2};`,\n            !rotate2 ? null : `${dir2} = quatVec(${rotate2}, ${dir2});`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  var computeUvec4_default = "precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout uvec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid produceSplat(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if ((index >= 0) && (index < targetCount)) {\\n        produceSplat(index);\\n    } else {\\n        target = uvec4(0u, 0u, 0u, 0u);\\n    }\\n}";\n  const _PackedSplats = class _PackedSplats {\n    constructor(options = {}) {\n      this.maxSplats = 0;\n      this.numSplats = 0;\n      this.packedArray = null;\n      this.isInitialized = false;\n      this.target = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.extra = {};\n      this.dyno = new DynoPackedSplats({ packedSplats: this });\n      this.initialized = Promise.resolve(this);\n      this.reinitialize(options);\n    }\n    reinitialize(options) {\n      this.isInitialized = false;\n      if (options.url || options.fileBytes || options.construct) {\n        this.initialized = this.asyncInitialize(options).then(() => {\n          this.isInitialized = true;\n          return this;\n        });\n      } else {\n        this.initialize(options);\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n      }\n    }\n    initialize(options) {\n      if (options.packedArray) {\n        this.packedArray = options.packedArray;\n        this.maxSplats = Math.floor(this.packedArray.length / 4);\n        this.maxSplats = Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        this.numSplats = Math.min(\n          this.maxSplats,\n          options.numSplats ?? Number.POSITIVE_INFINITY\n        );\n      } else {\n        this.maxSplats = options.maxSplats ?? 0;\n        this.numSplats = 0;\n      }\n      this.extra = options.extra ?? {};\n    }\n    async asyncInitialize(options) {\n      const { url, fileBytes, construct } = options;\n      if (url) {\n        const loader = new SplatLoader();\n        loader.packedSplats = this;\n        await loader.loadAsync(url);\n      } else if (fileBytes) {\n        const unpacked = await unpackSplats({\n          input: fileBytes,\n          fileType: options.fileType,\n          pathOrUrl: options.fileName ?? url\n        });\n        this.initialize(unpacked);\n      }\n      if (construct) {\n        const maybePromise = construct(this);\n        if (maybePromise instanceof Promise) {\n          await maybePromise;\n        }\n      }\n    }\n    // Call this when you are finished with the PackedSplats and want to free\n    // any buffers it holds.\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n    }\n    // Ensures that this.packedArray can fit numSplats Gsplats. If it\'s too small,\n    // resize exponentially and copy over the original data.\n    //\n    // Typically you don\'t need to call this, because calling this.setSplat(index, ...)\n    // and this.pushSplat(...) will automatically call ensureSplats() so we have\n    // enough splats.\n    ensureSplats(numSplats) {\n      const targetSize = numSplats <= this.maxSplats ? this.maxSplats : (\n        // Grow exponentially to avoid frequent reallocations\n        Math.max(numSplats, 2 * this.maxSplats)\n      );\n      const currentSize = !this.packedArray ? 0 : this.packedArray.length / 4;\n      if (!this.packedArray || targetSize > currentSize) {\n        this.maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(this.maxSplats * 4);\n        if (this.packedArray) {\n          newArray.set(this.packedArray);\n        }\n        this.packedArray = newArray;\n      }\n      return this.packedArray;\n    }\n    // Ensure the extra array for the given level is large enough to hold numSplats\n    ensureSplatsSh(level, numSplats) {\n      let wordsPerSplat;\n      let key;\n      if (level === 0) {\n        return this.ensureSplats(numSplats);\n      }\n      if (level === 1) {\n        wordsPerSplat = 2;\n        key = "sh1";\n      } else if (level === 2) {\n        wordsPerSplat = 4;\n        key = "sh2";\n      } else if (level === 3) {\n        wordsPerSplat = 4;\n        key = "sh3";\n      } else {\n        throw new Error(`Invalid level: ${level}`);\n      }\n      let maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;\n      const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, 2 * maxSplats);\n      if (!this.extra[key] || targetSize > maxSplats) {\n        maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(maxSplats * wordsPerSplat);\n        if (this.extra[key]) {\n          newArray.set(this.extra[key]);\n        }\n        this.extra[key] = newArray;\n      }\n      return this.extra[key];\n    }\n    // Unpack the 16-byte Gsplat data at index into the Three.js components\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number 0..1, color: THREE.Color 0..1.\n    getSplat(index) {\n      if (!this.packedArray || index >= this.numSplats) {\n        throw new Error("Invalid index");\n      }\n      return unpackSplat(this.packedArray, index);\n    }\n    // Set all PackedSplat components at index with the provided Gsplat attributes\n    // (can be the same objects returned by getSplat). Ensures there is capacity\n    // for at least index+1 Gsplats.\n    setSplat(index, center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(index + 1);\n      setPackedSplat(\n        packedSplats,\n        index,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      this.numSplats = Math.max(this.numSplats, index + 1);\n    }\n    // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on\n    // construction where you just want to iterate and create a collection of Gsplats.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(this.numSplats + 1);\n      setPackedSplat(\n        packedSplats,\n        this.numSplats,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      ++this.numSplats;\n    }\n    // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\n    // and invoke the callback function with the Gsplat attributes.\n    forEachSplat(callback) {\n      if (!this.packedArray || !this.numSplats) {\n        return;\n      }\n      for (let i2 = 0; i2 < this.numSplats; ++i2) {\n        const unpacked = unpackSplat(this.packedArray, i2);\n        callback(\n          i2,\n          unpacked.center,\n          unpacked.scales,\n          unpacked.quaternion,\n          unpacked.opacity,\n          unpacked.color\n        );\n      }\n    }\n    // Ensures our PackedSplats.target render target has enough space to generate\n    // maxSplats total Gsplats, and reallocate if not large enough.\n    ensureGenerate(maxSplats) {\n      if (this.target && (maxSplats ?? 1) <= this.maxSplats) {\n        return false;\n      }\n      this.dispose();\n      const textureSize = getTextureSize(maxSplats ?? 1);\n      const { width, height, depth } = textureSize;\n      this.maxSplats = textureSize.maxSplats;\n      this.target = new WebGLArrayRenderTarget(width, height, depth, {\n        depthBuffer: false,\n        stencilBuffer: false,\n        generateMipmaps: false,\n        magFilter: NearestFilter,\n        minFilter: NearestFilter\n      });\n      this.target.texture.format = RGBAIntegerFormat;\n      this.target.texture.type = UnsignedIntType;\n      this.target.texture.internalFormat = "RGBA32UI";\n      this.target.scissorTest = true;\n      return true;\n    }\n    // Given an array of splatCounts (.numSplats for each\n    // SplatGenerator/SplatMesh in the scene), compute a\n    // "mapping layout" in the composite array of generated outputs.\n    generateMapping(splatCounts) {\n      let maxSplats = 0;\n      const mapping = splatCounts.map((numSplats) => {\n        const base = maxSplats;\n        const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        maxSplats += rounded;\n        return { base, count: numSplats };\n      });\n      return { maxSplats, mapping };\n    }\n    // Returns a THREE.DataArrayTexture representing the PackedSplats content as\n    // a Uint32x4 data array texture (2048 x 2048 x depth in size)\n    getTexture() {\n      if (this.target) {\n        return this.target.texture;\n      }\n      if (this.source || this.packedArray) {\n        const source = this.maybeUpdateSource();\n        return source;\n      }\n      return _PackedSplats.getEmpty();\n    }\n    // Check if source texture needs to be created/updated\n    maybeUpdateSource() {\n      if (!this.packedArray) {\n        throw new Error("No packed splats");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.maxSplats !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.maxSplats);\n          this.source = new DataArrayTexture(\n            this.packedArray,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAIntegerFormat;\n          this.source.type = UnsignedIntType;\n          this.source.internalFormat = "RGBA32UI";\n          this.source.needsUpdate = true;\n        } else if (this.packedArray.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.packedArray.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Can be used where you need an uninitialized THREE.DataArrayTexture like\n    // a uniform you will update with the result of this.getTexture() later.\n    static getEmpty() {\n      if (!_PackedSplats.emptySource) {\n        const { width, height, depth, maxSplats } = getTextureSize(1);\n        const emptyArray = new Uint32Array(maxSplats * 4);\n        _PackedSplats.emptySource = new DataArrayTexture(\n          emptyArray,\n          width,\n          height,\n          depth\n        );\n        _PackedSplats.emptySource.format = RGBAIntegerFormat;\n        _PackedSplats.emptySource.type = UnsignedIntType;\n        _PackedSplats.emptySource.internalFormat = "RGBA32UI";\n        _PackedSplats.emptySource.needsUpdate = true;\n      }\n      return _PackedSplats.emptySource;\n    }\n    // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(generator) {\n      let program = _PackedSplats.generatorProgram.get(generator);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: "int" },\n          { output: "uvec4" },\n          ({ index }) => {\n            generator.inputs.index = index;\n            const gsplat = generator.outputs.gsplat;\n            const output = outputPackedSplat(gsplat);\n            return { output };\n          }\n        );\n        if (!_PackedSplats.programTemplate) {\n          _PackedSplats.programTemplate = new DynoProgramTemplate(\n            computeUvec4_default\n          );\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: "index" },\n          outputs: { output: "target" },\n          template: _PackedSplats.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _PackedSplats.generatorProgram.set(generator, program);\n      }\n      const material = program.prepareMaterial();\n      _PackedSplats.mesh.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrEnabled: renderer.xr.enabled,\n        autoClear: renderer.autoClear\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.xr.enabled = state.xrEnabled;\n      renderer.autoClear = state.autoClear;\n    }\n    // Executes a dyno program specified by generator which is any DynoBlock that\n    // maps { index: "int" } to { gsplat: Gsplat }. This is called in\n    // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\n    // SplatGenerator instances whose version is newer than what was generated\n    // for it last time.\n    generate({\n      generator,\n      base,\n      count,\n      renderer\n    }) {\n      if (!this.target) {\n        throw new Error("Target must be initialized with ensureSplats");\n      }\n      if (base + count > this.maxSplats) {\n        throw new Error("Base + count exceeds maxSplats");\n      }\n      const { program, material } = this.prepareProgramMaterial(generator);\n      program.update();\n      const renderState = this.saveRenderState(renderer);\n      const nextBase = Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = base;\n      material.uniforms.targetCount.value = count;\n      while (base < nextBase) {\n        const layer = Math.floor(base / layerSize);\n        material.uniforms.targetLayer.value = layer;\n        const layerBase = layer * layerSize;\n        const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH);\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        this.target.scissor.set(\n          0,\n          layerYStart,\n          SPLAT_TEX_WIDTH,\n          layerYEnd - layerYStart\n        );\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.enabled = false;\n        renderer.autoClear = false;\n        renderer.render(_PackedSplats.scene, _PackedSplats.camera);\n        base += SPLAT_TEX_WIDTH * (layerYEnd - layerYStart);\n      }\n      this.resetRenderState(renderer, renderState);\n      return { nextBase };\n    }\n  };\n  _PackedSplats.emptySource = null;\n  _PackedSplats.programTemplate = null;\n  _PackedSplats.generatorProgram = /* @__PURE__ */ new Map();\n  _PackedSplats.geometry = new PlaneGeometry(2, 2);\n  _PackedSplats.mesh = new Mesh(\n    _PackedSplats.geometry,\n    new RawShaderMaterial({ visible: false })\n  );\n  _PackedSplats.scene = new Scene().add(_PackedSplats.mesh);\n  _PackedSplats.camera = new Camera();\n  let PackedSplats = _PackedSplats;\n  class DynoPackedSplats extends DynoUniform {\n    constructor({ packedSplats } = {}) {\n      super({\n        key: "packedSplats",\n        type: TPackedSplats,\n        globals: () => [definePackedSplats],\n        value: {\n          texture: PackedSplats.getEmpty(),\n          numSplats: 0\n        },\n        update: (value) => {\n          var _a2, _b2;\n          value.texture = ((_a2 = this.packedSplats) == null ? void 0 : _a2.getTexture()) ?? PackedSplats.getEmpty();\n          value.numSplats = ((_b2 = this.packedSplats) == null ? void 0 : _b2.numSplats) ?? 0;\n          return value;\n        }\n      });\n      this.packedSplats = packedSplats;\n    }\n  }\n  var computeVec4_default = "precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout vec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid computeReadback(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if ((index >= 0) && (index < targetCount)) {\\n        computeReadback(index);\\n    } else {\\n        target = vec4(0.0, 0.0, 0.0, 0.0);\\n    }\\n}";\n  const _Readback = class _Readback {\n    constructor({ renderer } = {}) {\n      this.renderer = renderer;\n      this.capacity = 0;\n      this.count = 0;\n    }\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = void 0;\n      }\n    }\n    // Ensure we have a buffer large enough for the readback of count indices.\n    // Pass in previous bufer of the desired type.\n    ensureBuffer(count, buffer) {\n      const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const bytes = roundedCount * 4;\n      if (buffer.byteLength >= bytes) {\n        return buffer;\n      }\n      const newBuffer = new ArrayBuffer(bytes);\n      if (buffer instanceof ArrayBuffer) {\n        return newBuffer;\n      }\n      const ctor = buffer.constructor;\n      return new ctor(newBuffer);\n    }\n    // Ensure our render target is large enough for the readback of capacity indices.\n    ensureCapacity(capacity) {\n      const { width, height, depth, maxSplats } = getTextureSize(capacity);\n      if (!this.target || maxSplats > this.capacity) {\n        this.dispose();\n        this.capacity = maxSplats;\n        this.target = new WebGLArrayRenderTarget(width, height, depth, {\n          depthBuffer: false,\n          stencilBuffer: false,\n          generateMipmaps: false,\n          magFilter: NearestFilter,\n          minFilter: NearestFilter\n        });\n        this.target.texture.format = RGBAFormat;\n        this.target.texture.type = UnsignedByteType;\n        this.target.texture.internalFormat = "RGBA8";\n        this.target.scissorTest = true;\n      }\n    }\n    // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(reader) {\n      let program = _Readback.readbackProgram.get(reader);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: "int" },\n          { rgba8: "vec4" },\n          ({ index }) => {\n            reader.inputs.index = index;\n            const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 });\n            return { rgba8 };\n          }\n        );\n        if (!_Readback.programTemplate) {\n          _Readback.programTemplate = new DynoProgramTemplate(computeVec4_default);\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: "index" },\n          outputs: { rgba8: "target" },\n          template: _Readback.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _Readback.readbackProgram.set(reader, program);\n      }\n      const material = program.prepareMaterial();\n      _Readback.mesh.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrEnabled: renderer.xr.enabled,\n        autoClear: renderer.autoClear\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.xr.enabled = state.xrEnabled;\n      renderer.autoClear = state.autoClear;\n    }\n    process({\n      count,\n      material\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error("No renderer");\n      }\n      if (!this.target) {\n        throw new Error("No target");\n      }\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = 0;\n      material.uniforms.targetCount.value = count;\n      let baseIndex = 0;\n      while (baseIndex < count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        material.uniforms.targetLayer.value = layer;\n        this.target.scissor.set(0, 0, SPLAT_TEX_WIDTH, layerYEnd);\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.enabled = false;\n        renderer.autoClear = false;\n        renderer.render(_Readback.scene, _Readback.camera);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      this.count = count;\n    }\n    async read({\n      readback\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error("No renderer");\n      }\n      if (!this.target) {\n        throw new Error("No target");\n      }\n      const roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      if (readback.byteLength < roundedCount * 4) {\n        throw new Error(\n          `Readback buffer too small: ${readback.byteLength} < ${roundedCount * 4}`\n        );\n      }\n      const readbackUint8 = new Uint8Array(\n        readback instanceof ArrayBuffer ? readback : readback.buffer\n      );\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      let baseIndex = 0;\n      const promises = [];\n      while (baseIndex < this.count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        renderer.setRenderTarget(this.target, layer);\n        const readbackSize = SPLAT_TEX_WIDTH * layerYEnd * 4;\n        const subReadback = readbackUint8.subarray(\n          layerBase * 4,\n          layerBase * 4 + readbackSize\n        );\n        const promise = renderer == null ? void 0 : renderer.readRenderTargetPixelsAsync(\n          this.target,\n          0,\n          0,\n          SPLAT_TEX_WIDTH,\n          layerYEnd,\n          subReadback\n        );\n        promises.push(promise);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      return Promise.all(promises).then(() => readback);\n    }\n    // Perform render operation to run the Rgba8Readback program\n    // but don\'t perform the readback yet.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      this.resetRenderState(this.renderer, renderState);\n    }\n    // Perform a readback of the render target, returning a buffer of the\n    // given type.\n    async readback({\n      readback\n    }) {\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      const renderState = this.saveRenderState(this.renderer);\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    // Perform a render and readback operation for the given Rgba8Readback,\n    // and readback buffer (call ensureBuffer first).\n    async renderReadback({\n      reader,\n      count,\n      renderer,\n      readback\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    getTexture() {\n      var _a2;\n      return (_a2 = this.target) == null ? void 0 : _a2.texture;\n    }\n  };\n  _Readback.programTemplate = null;\n  _Readback.readbackProgram = /* @__PURE__ */ new Map();\n  _Readback.geometry = new PlaneGeometry(2, 2);\n  _Readback.mesh = new Mesh(\n    _Readback.geometry,\n    new RawShaderMaterial({ visible: false })\n  );\n  _Readback.scene = new Scene().add(_Readback.mesh);\n  _Readback.camera = new Camera();\n  let Readback = _Readback;\n  const _RgbaArray = class _RgbaArray {\n    constructor(options = {}) {\n      this.capacity = 0;\n      this.count = 0;\n      this.array = null;\n      this.readback = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.dyno = new DynoUniform({\n        key: "rgbaArray",\n        type: TRgbaArray,\n        globals: () => [defineRgbaArray],\n        value: {\n          texture: _RgbaArray.getEmpty(),\n          count: 0\n        },\n        update: (value) => {\n          var _a2;\n          value.texture = ((_a2 = this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? _RgbaArray.getEmpty();\n          value.count = this.count;\n          return value;\n        }\n      });\n      if (options.array) {\n        this.array = options.array;\n        this.capacity = Math.floor(this.array.length / 4);\n        this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        this.count = Math.min(\n          this.capacity,\n          options.count ?? Number.POSITIVE_INFINITY\n        );\n      } else {\n        this.capacity = options.capacity ?? 0;\n        this.count = 0;\n      }\n    }\n    // Free up resources\n    dispose() {\n      if (this.readback) {\n        this.readback.dispose();\n        this.readback = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n    }\n    // Ensure that our array is large enough to hold capacity RGBA8 values.\n    ensureCapacity(capacity) {\n      var _a2;\n      if (!this.array || capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {\n        this.capacity = getTextureSize(capacity).maxSplats;\n        const newArray = new Uint8Array(this.capacity * 4);\n        if (this.array) {\n          newArray.set(this.array);\n        }\n        this.array = newArray;\n      }\n      return this.array;\n    }\n    // Get the THREE.DataArrayTexture from either the readback or the source.\n    getTexture() {\n      var _a2;\n      let texture = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();\n      if (this.source || this.array) {\n        texture = this.maybeUpdateSource();\n      }\n      return texture ?? _RgbaArray.getEmpty();\n    }\n    // Create or get a THREE.DataArrayTexture from the data array.\n    maybeUpdateSource() {\n      if (!this.array) {\n        throw new Error("No array");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.capacity !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.capacity);\n          this.source = new DataArrayTexture(\n            this.array,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAFormat;\n          this.source.type = UnsignedByteType;\n          this.source.internalFormat = "RGBA8";\n          this.source.needsUpdate = true;\n        } else if (this.array.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.array.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Generate the RGBA8 values from a Rgba8Readback dyno program.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      if (!this.readback) {\n        this.readback = new Readback({ renderer });\n      }\n      this.readback.render({ reader, count, renderer });\n      this.capacity = this.readback.capacity;\n      this.count = this.readback.count;\n    }\n    // Extract the RGBA8 values from a PackedSplats collection.\n    fromPackedSplats({\n      packedSplats,\n      base,\n      count,\n      renderer\n    }) {\n      const { dynoSplats, dynoBase, dynoCount, reader } = _RgbaArray.makeDynos();\n      dynoSplats.packedSplats = packedSplats;\n      dynoBase.value = base;\n      dynoCount.value = count;\n      this.render({ reader, count, renderer });\n      return this;\n    }\n    // Read back the RGBA8 values from the readback buffer.\n    async read() {\n      if (!this.readback) {\n        throw new Error("No readback");\n      }\n      if (!this.array || this.array.length < this.count * 4) {\n        this.array = new Uint8Array(this.capacity * 4);\n      }\n      const result = await this.readback.readback({ readback: this.array });\n      return result.subarray(0, this.count * 4);\n    }\n    // Can be used where you need an uninitialized THREE.DataArrayTexture like\n    // a uniform you will update with the result of this.getTexture() later.\n    static getEmpty() {\n      if (!_RgbaArray.emptySource) {\n        const emptyArray = new Uint8Array(1 * 4);\n        _RgbaArray.emptySource = new DataArrayTexture(emptyArray, 1, 1, 1);\n        _RgbaArray.emptySource.format = RGBAFormat;\n        _RgbaArray.emptySource.type = UnsignedByteType;\n        _RgbaArray.emptySource.internalFormat = "RGBA8";\n        _RgbaArray.emptySource.needsUpdate = true;\n      }\n      return _RgbaArray.emptySource;\n    }\n    // Create a dyno program that can extract RGBA8 values from a PackedSplats\n    static makeDynos() {\n      if (!_RgbaArray.dynos) {\n        const dynoSplats = new DynoPackedSplats();\n        const dynoBase = new DynoInt({ value: 0 });\n        const dynoCount = new DynoInt({ value: 0 });\n        const reader = dynoBlock(\n          { index: "int" },\n          { rgba8: "vec4" },\n          ({ index }) => {\n            if (!index) {\n              throw new Error("index is undefined");\n            }\n            index = add(index, dynoBase);\n            const gsplat = readPackedSplatRange(\n              dynoSplats,\n              index,\n              dynoBase,\n              dynoCount\n            );\n            return { rgba8: splitGsplat(gsplat).outputs.rgba };\n          }\n        );\n        _RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };\n      }\n      return _RgbaArray.dynos;\n    }\n  };\n  _RgbaArray.emptySource = null;\n  _RgbaArray.dynos = null;\n  let RgbaArray = _RgbaArray;\n  const TRgbaArray = { type: "RgbaArray" };\n  const defineRgbaArray = unindent(`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n`);\n  function readRgbaArray(rgba, index) {\n    const dyno2 = new Dyno({\n      inTypes: { rgba: TRgbaArray, index: "int" },\n      outTypes: { rgba: "vec4" },\n      inputs: { rgba, index },\n      globals: () => [defineRgbaArray],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if ((index >= 0) && (index < ${inputs.rgba}.count)) {\n          ${outputs.rgba} = texelFetch(${inputs.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${outputs.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)\n    });\n    return dyno2.outputs.rgba;\n  }\n  function sdfTypeToNumber(type) {\n    switch (type) {\n      case "all":\n        return 0;\n      case "plane":\n        return 1;\n      case "sphere":\n        return 2;\n      case "box":\n        return 3;\n      case "ellipsoid":\n        return 4;\n      case "cylinder":\n        return 5;\n      case "capsule":\n        return 6;\n      case "infinite_cone":\n        return 7;\n      default:\n        throw new Error(`Unknown SDF type: ${type}`);\n    }\n  }\n  function rgbaBlendModeToNumber(mode) {\n    switch (mode) {\n      case "multiply":\n        return 0;\n      case "set_rgb":\n        return 1;\n      case "add_rgba":\n        return 2;\n      default:\n        throw new Error(`Unknown blend mode: ${mode}`);\n    }\n  }\n  class SplatEditSdf extends Object3D {\n    constructor(options = {}) {\n      super();\n      const { type, invert, opacity, color, displace, radius } = options;\n      this.type = type ?? "sphere";\n      this.invert = invert ?? false;\n      this.opacity = opacity ?? 1;\n      this.color = color ?? new Color(1, 1, 1);\n      this.displace = displace ?? new Vector3(0, 0, 0);\n      this.radius = radius ?? 0;\n    }\n  }\n  const _SplatEdit = class _SplatEdit extends Object3D {\n    constructor(options = {}) {\n      const {\n        name,\n        rgbaBlendMode = "multiply",\n        sdfSmooth = 0,\n        softEdge = 0,\n        invert = false,\n        sdfs = null\n      } = options;\n      super();\n      this.rgbaBlendMode = rgbaBlendMode;\n      this.sdfSmooth = sdfSmooth;\n      this.softEdge = softEdge;\n      this.invert = invert;\n      this.sdfs = sdfs;\n      this.ordering = _SplatEdit.nextOrdering++;\n      this.name = name ?? `Edit ${this.ordering}`;\n    }\n    addSdf(sdf) {\n      if (this.sdfs == null) {\n        this.sdfs = [];\n      }\n      if (!this.sdfs.includes(sdf)) {\n        this.sdfs.push(sdf);\n      }\n    }\n    removeSdf(sdf) {\n      if (this.sdfs == null) {\n        return;\n      }\n      this.sdfs = this.sdfs.filter((s) => s !== sdf);\n    }\n  };\n  _SplatEdit.nextOrdering = 1;\n  let SplatEdit = _SplatEdit;\n  class SplatEdits {\n    constructor({ maxSdfs, maxEdits }) {\n      this.maxSdfs = Math.max(16, maxSdfs ?? 0);\n      this.numSdfs = 0;\n      this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n      this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n      this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      this.dynoSdfArray = new DynoUniform({\n        key: "sdfArray",\n        type: SdfArray,\n        globals: () => [defineSdfArray],\n        value: {\n          numSdfs: 0,\n          sdfTexture: this.sdfTexture\n        },\n        update: (uniform) => {\n          uniform.numSdfs = this.numSdfs;\n          uniform.sdfTexture = this.sdfTexture;\n          return uniform;\n        }\n      });\n      this.maxEdits = Math.max(16, maxEdits ?? 0);\n      this.numEdits = 0;\n      this.editData = new Uint32Array(this.maxEdits * 4);\n      this.editFloatData = new Float32Array(this.editData.buffer);\n      this.dynoNumEdits = new DynoInt({ value: 0 });\n      this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n    }\n    newSdfTexture(data, maxSdfs) {\n      const texture = new DataTexture(\n        data,\n        8,\n        maxSdfs,\n        RGBAIntegerFormat,\n        UnsignedIntType\n      );\n      texture.internalFormat = "RGBA32UI";\n      texture.needsUpdate = true;\n      return texture;\n    }\n    newEdits(data, maxEdits) {\n      return new DynoUniform({\n        key: "edits",\n        type: "uvec4",\n        count: maxEdits,\n        globals: () => [defineEdit],\n        value: data\n      });\n    }\n    // Ensure our SDF texture and edits uniform array have enough capacity.\n    // Reallocate if not.\n    ensureCapacity({\n      maxSdfs,\n      maxEdits\n    }) {\n      let dynoUpdated = false;\n      if (maxSdfs > this.sdfTexture.image.height) {\n        this.sdfTexture.dispose();\n        this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);\n        this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n        this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n        this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      }\n      if (maxEdits > (this.dynoEdits.count ?? 0)) {\n        this.maxEdits = Math.max(this.maxEdits * 2, maxEdits);\n        this.editData = new Uint32Array(this.maxEdits * 4);\n        this.editFloatData = new Float32Array(this.editData.buffer);\n        this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n        dynoUpdated = true;\n      }\n      return dynoUpdated;\n    }\n    updateEditData(offset, value) {\n      const updated = this.editData[offset] !== value;\n      this.editData[offset] = value;\n      return updated;\n    }\n    updateEditFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.editFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.editFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeEdit(editIndex, {\n      sdfFirst,\n      sdfCount,\n      invert,\n      rgbaBlendMode,\n      softEdge,\n      sdfSmooth\n    }) {\n      const base = editIndex * 4;\n      let updated = false;\n      updated = this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || updated;\n      updated = this.updateEditData(base + 1, sdfFirst | sdfCount << 16) || updated;\n      updated = this.updateEditFloatData(base + 2, softEdge) || updated;\n      updated = this.updateEditFloatData(base + 3, sdfSmooth) || updated;\n      return updated;\n    }\n    updateSdfData(offset, value) {\n      const updated = this.sdfData[offset] !== value;\n      this.sdfData[offset] = value;\n      return updated;\n    }\n    updateSdfFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.sdfFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.sdfFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeSdf(sdfIndex, {\n      sdfType,\n      invert,\n      center,\n      quaternion,\n      scale,\n      sizes\n    }, values) {\n      const base = sdfIndex * (8 * 4);\n      const flags = sdfType | (invert ? 1 << 8 : 0);\n      let updated = false;\n      updated = this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 1, (center == null ? void 0 : center.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 3, flags) || updated;\n      updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : quaternion.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : quaternion.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : scale.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 9, (scale == null ? void 0 : scale.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 11, 0) || updated;\n      updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : sizes.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 13, (sizes == null ? void 0 : sizes.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 15, (sizes == null ? void 0 : sizes.w) ?? 0) || updated;\n      const nValues = Math.min(4, values.length);\n      for (let i2 = 0; i2 < nValues; ++i2) {\n        const vBase = base + 16 + i2 * 4;\n        updated = this.updateSdfFloatData(vBase + 0, values[i2].x) || updated;\n        updated = this.updateSdfFloatData(vBase + 1, values[i2].y) || updated;\n        updated = this.updateSdfFloatData(vBase + 2, values[i2].z) || updated;\n        updated = this.updateSdfFloatData(vBase + 3, values[i2].w) || updated;\n      }\n      return updated;\n    }\n    // Update the SDFs and edits from an array of SplatEdits and their\n    // associated SplatEditSdfs, updating it for the dyno shader program.\n    update(edits) {\n      const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, 0);\n      const dynoUpdated = this.ensureCapacity({\n        maxEdits: edits.length,\n        maxSdfs: sdfCount\n      });\n      const values = [new Vector4(), new Vector4()];\n      const center = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      const sizes = new Vector4();\n      let sdfIndex = 0;\n      let updated = dynoUpdated;\n      if (edits.length !== this.dynoNumEdits.value) {\n        this.dynoNumEdits.value = edits.length;\n        this.numEdits = edits.length;\n        updated = true;\n      }\n      for (const [editIndex, { edit, sdfs }] of edits.entries()) {\n        updated = this.encodeEdit(editIndex, {\n          sdfFirst: sdfIndex,\n          sdfCount: sdfs.length,\n          invert: edit.invert,\n          rgbaBlendMode: rgbaBlendModeToNumber(edit.rgbaBlendMode),\n          softEdge: edit.softEdge,\n          sdfSmooth: edit.sdfSmooth\n        }) || updated;\n        let sdfUpdated = false;\n        for (const sdf of sdfs) {\n          sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);\n          sdf.scale.setScalar(1);\n          sdf.updateMatrixWorld();\n          const worldToSdf = sdf.matrixWorld.clone().invert();\n          worldToSdf.decompose(center, quaternion, scale);\n          sdf.scale.set(sizes.x, sizes.y, sizes.z);\n          sdf.updateMatrixWorld();\n          values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);\n          values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);\n          sdfUpdated = this.encodeSdf(\n            sdfIndex,\n            {\n              sdfType: sdfTypeToNumber(sdf.type),\n              invert: sdf.invert,\n              center,\n              quaternion,\n              scale,\n              sizes\n            },\n            values\n          ) || sdfUpdated;\n          sdfIndex += 1;\n        }\n        this.numSdfs = sdfIndex;\n        if (sdfUpdated) {\n          this.sdfTexture.needsUpdate = true;\n        }\n        updated || (updated = sdfUpdated);\n      }\n      return { updated, dynoUpdated };\n    }\n    // Modify a Gsplat in a dyno shader program using the current edits and SDFs.\n    modify(gsplat) {\n      return applyGsplatRgbaDisplaceEdits(\n        gsplat,\n        this.dynoSdfArray,\n        this.dynoNumEdits,\n        this.dynoEdits\n      );\n    }\n  }\n  const SdfArray = { type: "SdfArray" };\n  const defineSdfArray = unindent(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n`);\n  const defineEdit = unindent(`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n`);\n  function applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, numEdits, rgbaDisplaceEdits) {\n    const dyno2 = new Dyno({\n      inTypes: {\n        gsplat: Gsplat,\n        sdfArray: SdfArray,\n        numEdits: "int",\n        rgbaDisplaceEdits: "uvec4"\n      },\n      outTypes: { gsplat: Gsplat },\n      globals: () => [defineSdfArray, defineEdit],\n      inputs: { gsplat, sdfArray, numEdits, rgbaDisplaceEdits },\n      statements: ({ inputs, outputs }) => {\n        const { sdfArray: sdfArray2, numEdits: numEdits2, rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;\n        const { gsplat: gsplat2 } = outputs;\n        return unindentLines(`\n        ${gsplat2} = ${inputs.gsplat};\n        if (isGsplatActive(${gsplat2}.flags)) {\n          for (int editIndex = 0; editIndex < ${numEdits2}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${rgbaDisplaceEdits2}[editIndex], ${sdfArray2}.sdfTexture, ${sdfArray2}.numSdfs,\n              ${gsplat2}.center, ${gsplat2}.rgba\n            );\n          }\n        }\n      `);\n      }\n    });\n    return dyno2.outputs.gsplat;\n  }\n  const tempFloat32 = new Float32Array(1);\n  class SplatTransformer {\n    // Create the dyno uniforms that parameterize the transform, setting them\n    // to initial values that are different from any valid transform.\n    constructor() {\n      this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });\n      this.rotate = new DynoVec4({\n        value: new Quaternion(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n      this.translate = new DynoVec3({\n        value: new Vector3(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n    }\n    // Apply the transform to a Vec3 position in a dyno program.\n    apply(position) {\n      return transformPos(position, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    applyDir(dir) {\n      return transformDir(dir, {\n        rotate: this.rotate\n      });\n    }\n    // Apply the transform to a Gsplat in a dyno program.\n    applyGsplat(gsplat) {\n      return transformGsplat(gsplat, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    // Update the uniforms to match the given transform matrix.\n    updateFromMatrix(transform) {\n      const scale = new Vector3();\n      const quaternion = new Quaternion();\n      const position = new Vector3();\n      transform.decompose(position, quaternion, scale);\n      const newScale = (scale.x + scale.y + scale.z) / 3;\n      let updated = false;\n      if (newScale !== this.scale.value) {\n        this.scale.value = newScale;\n        updated = true;\n      }\n      if (!position.equals(this.translate.value)) {\n        this.translate.value.copy(position);\n        updated = true;\n      }\n      if (!quaternion.equals(this.rotate.value)) {\n        this.rotate.value.copy(quaternion);\n        updated = true;\n      }\n      return updated;\n    }\n    // Update this transform to match the object\'s to-world transform.\n    update(object) {\n      object.updateMatrixWorld();\n      return this.updateFromMatrix(object.matrixWorld);\n    }\n  }\n  class SplatGenerator extends Object3D {\n    constructor({\n      numSplats,\n      generator,\n      construct,\n      update\n    }) {\n      super();\n      this.numSplats = numSplats ?? 0;\n      this.generator = generator;\n      this.frameUpdate = update;\n      this.version = 0;\n      if (construct) {\n        const constructed = construct(this);\n        Object.assign(this, constructed);\n      }\n    }\n    updateVersion() {\n      this.version += 1;\n    }\n    set needsUpdate(value) {\n      if (value) {\n        this.updateVersion();\n      }\n    }\n  }\n  const _SplatMesh = class _SplatMesh extends SplatGenerator {\n    constructor(options = {}) {\n      const transform = new SplatTransformer();\n      const viewToWorld = new SplatTransformer();\n      const worldToView = new SplatTransformer();\n      const viewToObject = new SplatTransformer();\n      const recolor = new DynoVec4({\n        value: new Vector4(\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY\n        )\n      });\n      const time = new DynoFloat({ value: 0 });\n      const deltaTime = new DynoFloat({ value: 0 });\n      const context = {\n        transform,\n        viewToWorld,\n        worldToView,\n        viewToObject,\n        recolor,\n        time,\n        deltaTime\n      };\n      super({\n        update: ({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits }) => this.update({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits })\n      });\n      this.isInitialized = false;\n      this.recolor = new Color(1, 1, 1);\n      this.opacity = 1;\n      this.enableViewToObject = false;\n      this.enableViewToWorld = false;\n      this.enableWorldToView = false;\n      this.skinning = null;\n      this.edits = null;\n      this.rgbaDisplaceEdits = null;\n      this.splatRgba = null;\n      this.maxSh = 3;\n      this.packedSplats = options.packedSplats ?? new PackedSplats();\n      this.numSplats = this.packedSplats.numSplats;\n      this.editable = options.editable ?? true;\n      this.onFrame = options.onFrame;\n      this.context = context;\n      this.objectModifier = options.objectModifier;\n      this.worldModifier = options.worldModifier;\n      this.updateGenerator();\n      if (options.url || options.fileBytes || options.constructSplats || options.packedSplats && !options.packedSplats.isInitialized) {\n        this.initialized = this.asyncInitialize(options).then(async () => {\n          this.updateGenerator();\n          this.isInitialized = true;\n          if (options.onLoad) {\n            const maybePromise = options.onLoad(this);\n            if (maybePromise instanceof Promise) {\n              await maybePromise;\n            }\n          }\n          return this;\n        });\n      } else {\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n        if (options.onLoad) {\n          const maybePromise = options.onLoad(this);\n          if (maybePromise instanceof Promise) {\n            this.initialized = maybePromise.then(() => this);\n          }\n        }\n      }\n    }\n    async asyncInitialize(options) {\n      const { url, fileBytes, fileType, fileName, maxSplats, constructSplats } = options;\n      if (url || fileBytes || constructSplats) {\n        const packedSplatsOptions = {\n          url,\n          fileBytes,\n          fileType,\n          fileName,\n          maxSplats,\n          construct: constructSplats\n        };\n        this.packedSplats.reinitialize(packedSplatsOptions);\n      }\n      if (this.packedSplats) {\n        await this.packedSplats.initialized;\n        this.numSplats = this.packedSplats.numSplats;\n        this.updateGenerator();\n      }\n    }\n    static async staticInitialize() {\n      await __wbg_init();\n      _SplatMesh.isStaticInitialized = true;\n    }\n    // Creates a new Gsplat with the provided parameters (all values in "float" space,\n    // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,\n    // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential\n    // doubling strategy to fit the new data, so it\'s fairly efficient to just\n    // pushSplat(...) each Gsplat you want to create in a loop.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      this.packedSplats.pushSplat(center, scales, quaternion, opacity, color);\n    }\n    // This method iterates over all Gsplats in this instance\'s packedSplats,\n    // invoking the provided callback with index: number in 0..=(this.numSplats-1) and\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).\n    // Note that the objects passed in as center etc. are the same for every callback\n    // invocation: these objects are reused for efficiency. Changing these values has\n    // no effect as they are decoded/unpacked copies of the underlying data. To update\n    // the packedSplats, call .packedSplats.setSplat(index, center, scales,\n    // quaternion, opacity, color).\n    forEachSplat(callback) {\n      this.packedSplats.forEachSplat(callback);\n    }\n    // Call this when you are finished with the SplatMesh and want to free\n    // any buffers it holds (via packedSplats).\n    dispose() {\n      this.packedSplats.dispose();\n    }\n    constructGenerator(context) {\n      const { transform, viewToObject, recolor } = context;\n      const generator = dynoBlock(\n        { index: "int" },\n        { gsplat: Gsplat },\n        ({ index }) => {\n          if (!index) {\n            throw new Error("index is undefined");\n          }\n          let gsplat = readPackedSplat(this.packedSplats.dyno, index);\n          if (this.maxSh >= 1) {\n            const { sh1Texture, sh2Texture, sh3Texture } = this.ensureShTextures();\n            if (sh1Texture) {\n              const viewCenterInObject = viewToObject.translate;\n              const { center } = splitGsplat(gsplat).outputs;\n              const viewDir = normalize(sub(center, viewCenterInObject));\n              let rgb = evaluateSH1(gsplat, sh1Texture, viewDir);\n              if (this.maxSh >= 2 && sh2Texture) {\n                rgb = add(rgb, evaluateSH2(gsplat, sh2Texture, viewDir));\n              }\n              if (this.maxSh >= 3 && sh3Texture) {\n                rgb = add(rgb, evaluateSH3(gsplat, sh3Texture, viewDir));\n              }\n              let { rgba } = splitGsplat(gsplat).outputs;\n              rgba = add(rgba, extendVec(rgb, dynoConst("float", 0)));\n              gsplat = combineGsplat({ gsplat, rgba });\n            }\n          }\n          if (this.splatRgba) {\n            const rgba = readRgbaArray(this.splatRgba.dyno, index);\n            gsplat = combineGsplat({ gsplat, rgba });\n          }\n          if (this.skinning) {\n            gsplat = this.skinning.modify(gsplat);\n          }\n          if (this.objectModifier) {\n            gsplat = this.objectModifier.apply({ gsplat }).gsplat;\n          }\n          gsplat = transform.applyGsplat(gsplat);\n          const recolorRgba = mul(recolor, splitGsplat(gsplat).outputs.rgba);\n          gsplat = combineGsplat({ gsplat, rgba: recolorRgba });\n          if (this.rgbaDisplaceEdits) {\n            gsplat = this.rgbaDisplaceEdits.modify(gsplat);\n          }\n          if (this.worldModifier) {\n            gsplat = this.worldModifier.apply({ gsplat }).gsplat;\n          }\n          return { gsplat };\n        }\n      );\n      this.generator = generator;\n    }\n    // Call this whenever something changes in the Gsplat processing pipeline,\n    // for example changing maxSh or updating objectModifier or worldModifier.\n    // Compiled generators are cached for efficiency and re-use when the same\n    // pipeline structure emerges after successive changes.\n    updateGenerator() {\n      this.constructGenerator(this.context);\n    }\n    // This is called automatically by SparkRenderer and you should not have to\n    // call it. It updates parameters for the generated pipeline and calls\n    // updateGenerator() if the pipeline needs to change.\n    update({\n      time,\n      viewToWorld,\n      deltaTime,\n      globalEdits\n    }) {\n      var _a2;\n      this.numSplats = this.packedSplats.numSplats;\n      this.context.time.value = time;\n      this.context.deltaTime.value = deltaTime;\n      _SplatMesh.dynoTime.value = time;\n      const { transform, viewToObject, recolor } = this.context;\n      let updated = transform.update(this);\n      if (this.context.viewToWorld.updateFromMatrix(viewToWorld) && this.enableViewToWorld) {\n        updated = true;\n      }\n      const worldToView = viewToWorld.clone().invert();\n      if (this.context.worldToView.updateFromMatrix(worldToView) && this.enableWorldToView) {\n        updated = true;\n      }\n      const objectToWorld = new Matrix4().compose(\n        transform.translate.value,\n        transform.rotate.value,\n        new Vector3().setScalar(transform.scale.value)\n      );\n      const worldToObject = objectToWorld.invert();\n      const viewToObjectMatrix = worldToObject.multiply(viewToWorld);\n      if (viewToObject.updateFromMatrix(viewToObjectMatrix) && (this.enableViewToObject || this.packedSplats.extra.sh1)) {\n        updated = true;\n      }\n      const newRecolor = new Vector4(\n        this.recolor.r,\n        this.recolor.g,\n        this.recolor.b,\n        this.opacity\n      );\n      if (!newRecolor.equals(recolor.value)) {\n        recolor.value.copy(newRecolor);\n        updated = true;\n      }\n      const edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];\n      if (this.editable && !this.edits) {\n        this.traverseVisible((node) => {\n          if (node instanceof SplatEdit) {\n            edits.push(node);\n          }\n        });\n      }\n      edits.sort((a, b) => a.ordering - b.ordering);\n      const editsSdfs = edits.map((edit) => {\n        if (edit.sdfs != null) {\n          return { edit, sdfs: edit.sdfs };\n        }\n        const sdfs = [];\n        edit.traverseVisible((node) => {\n          if (node instanceof SplatEditSdf) {\n            sdfs.push(node);\n          }\n        });\n        return { edit, sdfs };\n      });\n      if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) {\n        const edits2 = editsSdfs.length;\n        const sdfs = editsSdfs.reduce(\n          (total, edit) => total + edit.sdfs.length,\n          0\n        );\n        this.rgbaDisplaceEdits = new SplatEdits({\n          maxEdits: edits2,\n          maxSdfs: sdfs\n        });\n        this.updateGenerator();\n      }\n      if (this.rgbaDisplaceEdits) {\n        const editResult = this.rgbaDisplaceEdits.update(editsSdfs);\n        updated || (updated = editResult.updated);\n        if (editResult.dynoUpdated) {\n          this.updateGenerator();\n        }\n      }\n      if (updated) {\n        this.updateVersion();\n      }\n      (_a2 = this.onFrame) == null ? void 0 : _a2.call(this, { mesh: this, time, deltaTime });\n    }\n    // This method conforms to the standard THREE.Raycaster API, performing object-ray\n    // intersections using this method to populate the provided intersects[] array\n    // with each intersection point.\n    raycast(raycaster, intersects) {\n      if (!this.packedSplats.packedArray || !this.packedSplats.numSplats) {\n        return;\n      }\n      const { near, far, ray } = raycaster;\n      const worldToMesh = this.matrixWorld.clone().invert();\n      const worldToMeshRot = new Matrix3().setFromMatrix4(worldToMesh);\n      const origin = ray.origin.clone().applyMatrix4(worldToMesh);\n      const direction = ray.direction.clone().applyMatrix3(worldToMeshRot);\n      const scales = new Vector3();\n      worldToMesh.decompose(new Vector3(), new Quaternion(), scales);\n      (scales.x * scales.y * scales.z) ** (1 / 3);\n      const RAYCAST_ELLIPSOID = true;\n      const distances = raycast_splats(\n        origin.x,\n        origin.y,\n        origin.z,\n        direction.x,\n        direction.y,\n        direction.z,\n        near,\n        far,\n        this.packedSplats.numSplats,\n        this.packedSplats.packedArray,\n        RAYCAST_ELLIPSOID\n      );\n      for (const distance of distances) {\n        const point = ray.direction.clone().multiplyScalar(distance).add(ray.origin);\n        intersects.push({\n          distance,\n          point,\n          object: this\n        });\n      }\n    }\n    ensureShTextures() {\n      if (!this.packedSplats.extra.sh1) {\n        return {};\n      }\n      let sh1Texture = this.packedSplats.extra.sh1Texture;\n      if (!sh1Texture) {\n        let sh1 = this.packedSplats.extra.sh1;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh1.length / 2\n        );\n        if (sh1.length < maxSplats * 2) {\n          const newSh1 = new Uint32Array(maxSplats * 2);\n          newSh1.set(sh1);\n          this.packedSplats.extra.sh1 = newSh1;\n          sh1 = newSh1;\n        }\n        const texture = new DataArrayTexture(sh1, width, height, depth);\n        texture.format = RGIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RG32UI";\n        texture.needsUpdate = true;\n        sh1Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh1"\n        });\n        this.packedSplats.extra.sh1Texture = sh1Texture;\n      }\n      if (!this.packedSplats.extra.sh2) {\n        return { sh1Texture };\n      }\n      let sh2Texture = this.packedSplats.extra.sh2Texture;\n      if (!sh2Texture) {\n        let sh2 = this.packedSplats.extra.sh2;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh2.length / 4\n        );\n        if (sh2.length < maxSplats * 4) {\n          const newSh2 = new Uint32Array(maxSplats * 4);\n          newSh2.set(sh2);\n          this.packedSplats.extra.sh2 = newSh2;\n          sh2 = newSh2;\n        }\n        const texture = new DataArrayTexture(sh2, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RGBA32UI";\n        texture.needsUpdate = true;\n        sh2Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh2"\n        });\n        this.packedSplats.extra.sh2Texture = sh2Texture;\n      }\n      if (!this.packedSplats.extra.sh3) {\n        return { sh1Texture, sh2Texture };\n      }\n      let sh3Texture = this.packedSplats.extra.sh3Texture;\n      if (!sh3Texture) {\n        let sh3 = this.packedSplats.extra.sh3;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh3.length / 4\n        );\n        if (sh3.length < maxSplats * 4) {\n          const newSh3 = new Uint32Array(maxSplats * 4);\n          newSh3.set(sh3);\n          this.packedSplats.extra.sh3 = newSh3;\n          sh3 = newSh3;\n        }\n        const texture = new DataArrayTexture(sh3, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RGBA32UI";\n        texture.needsUpdate = true;\n        sh3Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh3"\n        });\n        this.packedSplats.extra.sh3Texture = sh3Texture;\n      }\n      return { sh1Texture, sh2Texture, sh3Texture };\n    }\n  };\n  _SplatMesh.staticInitialized = _SplatMesh.staticInitialize();\n  _SplatMesh.isStaticInitialized = false;\n  _SplatMesh.dynoTime = new DynoFloat({ value: 0 });\n  let SplatMesh = _SplatMesh;\n  const defineEvaluateSH1 = unindent(`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`);\n  const defineEvaluateSH2 = unindent(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n`);\n  const defineEvaluateSH3 = unindent(`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);\n  function evaluateSH1(gsplat, sh1, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh1: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh1, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH1],\n      statements: ({ inputs, outputs }) => {\n        const statements = unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH1(${inputs.gsplat}, ${inputs.sh1}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `);\n        return statements;\n      }\n    }).outputs.rgb;\n  }\n  function evaluateSH2(gsplat, sh2, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh2: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh2, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH2],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH2(${inputs.gsplat}, ${inputs.sh2}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `)\n    }).outputs.rgb;\n  }\n  function evaluateSH3(gsplat, sh3, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh3: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh3, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH3],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH3(${inputs.gsplat}, ${inputs.sh3}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `)\n    }).outputs.rgb;\n  }\n  const _PlyReader = class _PlyReader {\n    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n    constructor({ fileBytes }) {\n      this.header = "";\n      this.littleEndian = true;\n      this.elements = {};\n      this.comments = [];\n      this.data = null;\n      this.numSplats = 0;\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n    }\n    // Identify and parse the PLY text header (assumed to be <64KB in size).\n    // this.elements will contain all the elements in the file, typically\n    // "vertex" contains the Gsplat data.\n    async parseHeader() {\n      const bufferStream = new ReadableStream({\n        start: (controller) => {\n          controller.enqueue(this.fileBytes.slice(0, 65536));\n          controller.close();\n        }\n      });\n      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();\n      this.header = "";\n      const headerTerminator = "end_header\\n";\n      while (true) {\n        const { value, done } = await decoder.read();\n        if (done) {\n          throw new Error("Failed to read header");\n        }\n        this.header += value;\n        const endHeader = this.header.indexOf(headerTerminator);\n        if (endHeader >= 0) {\n          this.header = this.header.slice(0, endHeader + headerTerminator.length);\n          break;\n        }\n      }\n      const headerLen = new TextEncoder().encode(this.header).length;\n      this.data = new DataView(this.fileBytes.buffer, headerLen);\n      this.elements = {};\n      let curElement = null;\n      this.comments = [];\n      this.header.trim().split("\\n").forEach((line, lineIndex) => {\n        const trimmedLine = line.trim();\n        if (lineIndex === 0) {\n          if (trimmedLine !== "ply") {\n            throw new Error("Invalid PLY header");\n          }\n          return;\n        }\n        if (trimmedLine.length === 0) {\n          return;\n        }\n        const fields = trimmedLine.split(" ");\n        switch (fields[0]) {\n          case "format":\n            if (fields[1] === "binary_little_endian") {\n              this.littleEndian = true;\n            } else if (fields[1] === "binary_big_endian") {\n              this.littleEndian = false;\n            } else {\n              throw new Error(`Unsupported PLY format: ${fields[1]}`);\n            }\n            if (fields[2] !== "1.0") {\n              throw new Error(`Unsupported PLY version: ${fields[2]}`);\n            }\n            break;\n          case "end_header":\n            break;\n          case "comment":\n            this.comments.push(trimmedLine.slice("comment ".length));\n            break;\n          case "element": {\n            const name = fields[1];\n            curElement = {\n              name,\n              count: Number.parseInt(fields[2]),\n              properties: {}\n            };\n            this.elements[name] = curElement;\n            break;\n          }\n          case "property":\n            if (curElement == null) {\n              throw new Error("Property must be inside an element");\n            }\n            if (fields[1] === "list") {\n              curElement.properties[fields[4]] = {\n                isList: true,\n                type: fields[3],\n                countType: fields[2]\n              };\n            } else {\n              curElement.properties[fields[2]] = {\n                isList: false,\n                type: fields[1]\n              };\n            }\n            break;\n        }\n      });\n      if (this.elements.vertex) {\n        this.numSplats = this.elements.vertex.count;\n      }\n    }\n    parseData(elementCallback) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No data to parse");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const item = {};\n        const parsers = [];\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            item[propertyName] = 0;\n            parsers.push(() => {\n              item[propertyName] = PARSE_FIELD[property.type](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            item[propertyName] = [];\n            parsers.push(() => {\n              const list = item[propertyName];\n              list.length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              for (let i2 = 0; i2 < list.length; i2++) {\n                list[i2] = PARSE_FIELD[property.type](\n                  data,\n                  offset,\n                  this.littleEndian\n                );\n                offset += FIELD_BYTES[property.type];\n              }\n            });\n          }\n        }\n        const callback = elementCallback(element) ?? (() => {\n        });\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          callback(index, item);\n        }\n      }\n    }\n    // Parse all the Gsplat data in the PLY file in go, invoking the given\n    // callbacks for each Gsplat.\n    parseSplats(splatCallback, shCallback) {\n      if (this.elements.vertex == null) {\n        throw new Error("No vertex element found");\n      }\n      let isSuperSplat = false;\n      const ssChunks = [];\n      let numSh = 0;\n      let sh1Props = [];\n      let sh2Props = [];\n      let sh3Props = [];\n      let sh1 = void 0;\n      let sh2 = void 0;\n      let sh3 = void 0;\n      function prepareSh() {\n        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\n        sh1Props = new Array(3).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${k + d * num_f_rest / 3}`)\n        );\n        sh2Props = new Array(5).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${3 + k + d * num_f_rest / 3}`)\n        );\n        sh3Props = new Array(7).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${8 + k + d * num_f_rest / 3}`)\n        );\n        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;\n        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;\n        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;\n      }\n      function ssShCallback(index, item) {\n        if (!sh1) {\n          throw new Error("Missing sh1");\n        }\n        for (const [i2, key] of sh1Props.entries()) {\n          sh1[i2] = item[key] * 8 / 255 - 4;\n        }\n        if (sh2) {\n          for (const [i2, key] of sh2Props.entries()) {\n            sh2[i2] = item[key] * 8 / 255 - 4;\n          }\n        }\n        if (sh3) {\n          for (const [i2, key] of sh3Props.entries()) {\n            sh3[i2] = item[key] * 8 / 255 - 4;\n          }\n        }\n        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);\n      }\n      function initSuperSplat(element) {\n        const {\n          min_x,\n          min_y,\n          min_z,\n          max_x,\n          max_y,\n          max_z,\n          min_scale_x,\n          min_scale_y,\n          min_scale_z,\n          max_scale_x,\n          max_scale_y,\n          max_scale_z\n        } = element.properties;\n        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {\n          throw new Error("Missing PLY chunk properties");\n        }\n        isSuperSplat = true;\n        return (index, item) => {\n          const {\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = item;\n          ssChunks.push({\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          });\n        };\n      }\n      function decodeSuperSplat(element) {\n        if (shCallback && element.name === "sh") {\n          numSh = getNumSh(element.properties);\n          prepareSh();\n          return ssShCallback;\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;\n        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {\n          throw new Error(\n            "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"\n          );\n        }\n        const SQRT2 = Math.sqrt(2);\n        return (index, item) => {\n          const chunk = ssChunks[index >>> 8];\n          if (chunk == null) {\n            throw new Error("Missing PLY chunk");\n          }\n          const {\n            min_x,\n            min_y,\n            min_z,\n            max_x,\n            max_y,\n            max_z,\n            min_scale_x,\n            min_scale_y,\n            min_scale_z,\n            max_scale_x,\n            max_scale_y,\n            max_scale_z,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = chunk;\n          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;\n          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;\n          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\n          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\n          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\n          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\n          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n          const rOrder = packed_rotation2 >>> 30;\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n          const quatZ = rOrder <= 2 ? r2 : rr;\n          const quatW = rOrder === 0 ? rr : r0;\n          const scaleX = Math.exp(\n            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x\n          );\n          const scaleY = Math.exp(\n            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y\n          );\n          const scaleZ = Math.exp(\n            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z\n          );\n          const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);\n          const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);\n          const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);\n          const opacity = (packed_color2 & 255) / 255;\n          splatCallback(\n            index,\n            x2,\n            y,\n            z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            opacity,\n            r,\n            g,\n            b\n          );\n        };\n      }\n      const elementCallback = (element) => {\n        if (element.name === "chunk") {\n          return initSuperSplat(element);\n        }\n        if (isSuperSplat) {\n          return decodeSuperSplat(element);\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const {\n          x: x2,\n          y,\n          z,\n          scale_0,\n          scale_1,\n          scale_2,\n          rot_0,\n          rot_1,\n          rot_2,\n          rot_3,\n          opacity,\n          f_dc_0,\n          f_dc_1,\n          f_dc_2,\n          red,\n          green,\n          blue,\n          alpha\n        } = element.properties;\n        if (!x2 || !y || !z) {\n          throw new Error("Missing PLY properties: x, y, z");\n        }\n        const hasScales = scale_0 && scale_1 && scale_2;\n        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\n        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\n        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\n        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\n        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\n        numSh = getNumSh(element.properties);\n        prepareSh();\n        return (index, item) => {\n          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;\n          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\n          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\n          const quatX = hasRots ? item.rot_1 : 0;\n          const quatY = hasRots ? item.rot_2 : 0;\n          const quatZ = hasRots ? item.rot_3 : 0;\n          const quatW = hasRots ? item.rot_0 : 1;\n          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\n          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;\n          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\n          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;\n          splatCallback(\n            index,\n            item.x,\n            item.y,\n            item.z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            op,\n            r,\n            g,\n            b\n          );\n          if (shCallback && sh1) {\n            if (sh1) {\n              for (const [i2, key] of sh1Props.entries()) {\n                sh1[i2] = item[key];\n              }\n            }\n            if (sh2) {\n              for (const [i2, key] of sh2Props.entries()) {\n                sh2[i2] = item[key];\n              }\n            }\n            if (sh3) {\n              for (const [i2, key] of sh3Props.entries()) {\n                sh3[i2] = item[key];\n              }\n            }\n            shCallback(index, sh1, sh2, sh3);\n          }\n        };\n      };\n      this.parseData(elementCallback);\n    }\n    // Inject RGBA values into original PLY file, which can be used to modify\n    // the color/opacity of the Gsplats and write out the modified PLY file.\n    injectRgba(rgba) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No parsed data");\n      }\n      if (rgba.length !== this.numSplats * 4) {\n        throw new Error("Invalid RGBA array length");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const parsers = [];\n        let rgbaOffset = 0;\n        const isVertex = elementName === "vertex";\n        if (isVertex) {\n          for (const name of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"]) {\n            if (!properties[name] || properties[name].type !== "float") {\n              throw new Error(`Can\'t injectRgba due to property: ${name}`);\n            }\n          }\n        }\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            if (isVertex) {\n              if (propertyName === "f_dc_0" || propertyName === "f_dc_1" || propertyName === "f_dc_2") {\n                const component = Number.parseInt(\n                  propertyName.slice("f_dc_".length)\n                );\n                parsers.push(() => {\n                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              } else if (propertyName === "opacity") {\n                parsers.push(() => {\n                  const value = Math.max(\n                    -100,\n                    Math.min(\n                      100,\n                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\n                    )\n                  );\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              }\n            }\n            parsers.push(() => {\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            parsers.push(() => {\n              const length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              offset += length * FIELD_BYTES[property.type];\n            });\n          }\n        }\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          if (isVertex) {\n            rgbaOffset += 4;\n          }\n        }\n      }\n    }\n  };\n  _PlyReader.defaultPointScale = 1e-3;\n  let PlyReader = _PlyReader;\n  const SH_C0$1 = 0.28209479177387814;\n  const PARSE_FIELD = {\n    char: (data, offset, littleEndian) => {\n      return data.getInt8(offset);\n    },\n    uchar: (data, offset, littleEndian) => {\n      return data.getUint8(offset);\n    },\n    short: (data, offset, littleEndian) => {\n      return data.getInt16(offset, littleEndian);\n    },\n    ushort: (data, offset, littleEndian) => {\n      return data.getUint16(offset, littleEndian);\n    },\n    int: (data, offset, littleEndian) => {\n      return data.getInt32(offset, littleEndian);\n    },\n    uint: (data, offset, littleEndian) => {\n      return data.getUint32(offset, littleEndian);\n    },\n    float: (data, offset, littleEndian) => {\n      return data.getFloat32(offset, littleEndian);\n    },\n    double: (data, offset, littleEndian) => {\n      return data.getFloat64(offset, littleEndian);\n    }\n  };\n  const SET_FIELD = {\n    char: (data, offset, littleEndian, value) => {\n      data.setInt8(offset, value);\n    },\n    uchar: (data, offset, littleEndian, value) => {\n      data.setUint8(offset, value);\n    },\n    short: (data, offset, littleEndian, value) => {\n      data.setInt16(offset, value, littleEndian);\n    },\n    ushort: (data, offset, littleEndian, value) => {\n      data.setUint16(offset, value, littleEndian);\n    },\n    int: (data, offset, littleEndian, value) => {\n      data.setInt32(offset, value, littleEndian);\n    },\n    uint: (data, offset, littleEndian, value) => {\n      data.setUint32(offset, value, littleEndian);\n    },\n    float: (data, offset, littleEndian, value) => {\n      data.setFloat32(offset, value, littleEndian);\n    },\n    double: (data, offset, littleEndian, value) => {\n      data.setFloat64(offset, value, littleEndian);\n    }\n  };\n  const FIELD_BYTES = {\n    char: 1,\n    uchar: 1,\n    short: 2,\n    ushort: 2,\n    int: 4,\n    uint: 4,\n    float: 4,\n    double: 8\n  };\n  const FIELD_SCALE = {\n    char: 127,\n    uchar: 255,\n    short: 32767,\n    ushort: 65535,\n    int: 2147483647,\n    uint: 4294967295,\n    float: 1,\n    double: 1\n  };\n  const NUM_F_REST_TO_NUM_SH = {\n    0: 0,\n    9: 1,\n    24: 2,\n    45: 3\n  };\n  const NUM_SH_TO_NUM_F_REST = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function getNumSh(properties) {\n    let num_f_rest = 0;\n    while (properties[`f_rest_${num_f_rest}`]) {\n      num_f_rest += 1;\n    }\n    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\n    if (numSh == null) {\n      throw new Error(`Unsupported number of SH coefficients: ${num_f_rest}`);\n    }\n    return numSh;\n  }\n  function WorkerWrapper(options) {\n    return new Worker(\n      self.location.href,\n      {\n        name: options == null ? void 0 : options.name\n      }\n    );\n  }\n  class SplatWorker {\n    constructor() {\n      this.messages = {};\n      this.messageIdNext = 0;\n      this.worker = new WorkerWrapper();\n      this.worker.onmessage = (event) => this.onMessage(event);\n    }\n    makeMessageId() {\n      return ++this.messageIdNext;\n    }\n    makeMessagePromiseId() {\n      const id = this.makeMessageId();\n      const promise = new Promise((resolve, reject) => {\n        this.messages[id] = { resolve, reject };\n      });\n      return { id, promise };\n    }\n    onMessage(event) {\n      const { id, result, error } = event.data;\n      const handler = this.messages[id];\n      if (handler) {\n        delete this.messages[id];\n        if (error) {\n          handler.reject(error);\n        } else {\n          handler.resolve(result);\n        }\n      }\n    }\n    // Invoke an RPC on the worker with the given name and arguments.\n    // The normal usage of a worker is to run one activity at a time,\n    // but this function allows for concurrent calls, tagging each request\n    // with a unique message Id and awaiting a response to that same Id.\n    // The method will automatically transfer any ArrayBuffers in the\n    // arguments to the worker. If you\'d like to transfer a copy of a\n    // buffer then you must clone it before passing to this function.\n    async call(name, args) {\n      const { id, promise } = this.makeMessagePromiseId();\n      this.worker.postMessage(\n        { name, args, id },\n        { transfer: getArrayBuffers(args) }\n      );\n      return promise;\n    }\n  }\n  let maxWorkers = 4;\n  let numWorkers = 0;\n  const freeWorkers = [];\n  const workerQueue = [];\n  async function allocWorker() {\n    const worker = freeWorkers.shift();\n    if (worker) {\n      return worker;\n    }\n    if (numWorkers < maxWorkers) {\n      const worker2 = new SplatWorker();\n      numWorkers += 1;\n      return worker2;\n    }\n    return new Promise((resolve) => {\n      workerQueue.push(resolve);\n    });\n  }\n  function freeWorker(worker) {\n    if (numWorkers > maxWorkers) {\n      numWorkers -= 1;\n      return;\n    }\n    const waiter = workerQueue.shift();\n    if (waiter) {\n      waiter(worker);\n      return;\n    }\n    freeWorkers.push(worker);\n  }\n  async function withWorker(callback) {\n    const worker = await allocWorker();\n    try {\n      return await callback(worker);\n    } finally {\n      freeWorker(worker);\n    }\n  }\n  class SplatLoader extends Loader {\n    constructor(manager) {\n      super(manager);\n      this.fileLoader = new FileLoader(manager);\n    }\n    load(url, onLoad, onProgress, onError) {\n      const resolvedURL = this.manager.resolveURL(\n        (this.path ?? "") + (url ?? "")\n      );\n      const headers = new Headers(this.requestHeader);\n      const credentials = this.withCredentials ? "include" : "same-origin";\n      const request = new Request(resolvedURL, { headers, credentials });\n      let fileType = this.fileType;\n      this.manager.itemStart(resolvedURL);\n      fetchWithProgress(request, onProgress).then(async (input) => {\n        const progresses = [\n          new ProgressEvent("progress", {\n            lengthComputable: true,\n            loaded: input.byteLength,\n            total: input.byteLength\n          })\n        ];\n        function updateProgresses() {\n          if (onProgress) {\n            const lengthComputable = progresses.every((p) => {\n              return p.lengthComputable || p.loaded === 0 && p.total === 0;\n            });\n            const loaded = progresses.reduce((sum, p) => sum + p.loaded, 0);\n            const total = progresses.reduce((sum, p) => sum + p.total, 0);\n            onProgress(\n              new ProgressEvent("progress", {\n                lengthComputable,\n                loaded,\n                total\n              })\n            );\n          }\n        }\n        const extraFiles = {};\n        const promises = [];\n        const pcSogsJson = tryPcSogs(input);\n        if (fileType === "pcsogs") {\n          if (pcSogsJson === void 0) {\n            throw new Error("Invalid PC SOGS file");\n          }\n        }\n        if (pcSogsJson !== void 0) {\n          fileType = "pcsogs";\n          for (const key of ["means", "scales", "quats", "sh0", "shN"]) {\n            const prop = pcSogsJson[key];\n            if (prop) {\n              for (const file of prop.files) {\n                const fileUrl = new URL(file, resolvedURL).toString();\n                const progressIndex = progresses.length;\n                progresses.push(new ProgressEvent("progress"));\n                this.manager.itemStart(fileUrl);\n                const request2 = new Request(fileUrl, { headers, credentials });\n                const promise = fetchWithProgress(request2, (progress) => {\n                  progresses[progressIndex] = progress;\n                  updateProgresses();\n                }).then((data) => {\n                  extraFiles[file] = data;\n                }).catch((error) => {\n                  this.manager.itemError(fileUrl);\n                  throw error;\n                }).finally(() => {\n                  this.manager.itemEnd(fileUrl);\n                });\n                promises.push(promise);\n              }\n            }\n          }\n        }\n        await Promise.all(promises);\n        if (onLoad) {\n          const decoded = await unpackSplats({\n            input,\n            extraFiles,\n            fileType,\n            pathOrUrl: resolvedURL\n          });\n          if (this.packedSplats) {\n            this.packedSplats.initialize(decoded);\n            onLoad(this.packedSplats);\n          } else {\n            onLoad(new PackedSplats(decoded));\n          }\n        }\n      }).catch((error) => {\n        this.manager.itemError(resolvedURL);\n        onError == null ? void 0 : onError(error);\n      }).finally(() => {\n        this.manager.itemEnd(resolvedURL);\n      });\n    }\n    async loadAsync(url, onProgress) {\n      return new Promise((resolve, reject) => {\n        this.load(\n          url,\n          (decoded) => {\n            resolve(decoded);\n          },\n          onProgress,\n          reject\n        );\n      });\n    }\n    parse(packedSplats) {\n      return new SplatMesh({ packedSplats });\n    }\n  }\n  async function fetchWithProgress(request, onProgress) {\n    const response = await fetch(request);\n    if (!response.ok) {\n      throw new Error(\n        `${response.status} "${response.statusText}" fetching URL: ${request.url}`\n      );\n    }\n    if (!response.body) {\n      throw new Error(`Response body is null for URL: ${request.url}`);\n    }\n    const reader = response.body.getReader();\n    const contentLength = Number.parseInt(\n      response.headers.get("Content-Length") || "0"\n    );\n    const total = Number.isNaN(contentLength) ? 0 : contentLength;\n    let loaded = 0;\n    const chunks = [];\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        break;\n      }\n      chunks.push(value);\n      loaded += value.length;\n      if (onProgress) {\n        onProgress(\n          new ProgressEvent("progress", {\n            lengthComputable: total !== 0,\n            loaded,\n            total\n          })\n        );\n      }\n    }\n    const bytes = new Uint8Array(loaded);\n    let offset = 0;\n    for (const chunk of chunks) {\n      bytes.set(chunk, offset);\n      offset += chunk.length;\n    }\n    return bytes.buffer;\n  }\n  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {\n    SplatFileType2["PLY"] = "ply";\n    SplatFileType2["SPZ"] = "spz";\n    SplatFileType2["SPLAT"] = "splat";\n    SplatFileType2["KSPLAT"] = "ksplat";\n    SplatFileType2["PCSOGS"] = "pcsogs";\n    SplatFileType2["PCSOGSZIP"] = "pcsogszip";\n    return SplatFileType2;\n  })(SplatFileType || {});\n  function getSplatFileType(fileBytes) {\n    const view = new DataView(fileBytes.buffer);\n    if ((view.getUint32(0, true) & 16777215) === 7957616) {\n      return "ply";\n    }\n    if ((view.getUint32(0, true) & 16777215) === 559903) {\n      const header = decompressPartialGzip(fileBytes, 4);\n      const gView = new DataView(header.buffer);\n      if (gView.getUint32(0, true) === 1347635022) {\n        return "spz";\n      }\n      return void 0;\n    }\n    if (view.getUint32(0, true) === 67324752) {\n      if (tryPcSogsZip(fileBytes)) {\n        return "pcsogszip";\n      }\n      return void 0;\n    }\n    return void 0;\n  }\n  function getFileExtension(pathOrUrl) {\n    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\n    const lastSlash = Math.max(\n      noTrailing.lastIndexOf("/"),\n      noTrailing.lastIndexOf("\\\\")\n    );\n    const filename = noTrailing.slice(lastSlash + 1);\n    const lastDot = filename.lastIndexOf(".");\n    if (lastDot <= 0 || lastDot === filename.length - 1) {\n      return "";\n    }\n    return filename.slice(lastDot + 1).toLowerCase();\n  }\n  function getSplatFileTypeFromPath(pathOrUrl) {\n    const extension = getFileExtension(pathOrUrl);\n    if (extension === "ply") {\n      return "ply";\n    }\n    if (extension === "spz") {\n      return "spz";\n    }\n    if (extension === "splat") {\n      return "splat";\n    }\n    if (extension === "ksplat") {\n      return "ksplat";\n    }\n    return void 0;\n  }\n  function tryPcSogs(input) {\n    try {\n      let text;\n      if (typeof input === "string") {\n        text = input;\n      } else {\n        const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n        if (fileBytes.length > 65536) {\n          return void 0;\n        }\n        text = new TextDecoder().decode(fileBytes);\n      }\n      const json = JSON.parse(text);\n      if (!json || typeof json !== "object" || Array.isArray(json)) {\n        return void 0;\n      }\n      for (const key of ["means", "scales", "quats", "sh0"]) {\n        if (!json[key] || typeof json[key] !== "object" || Array.isArray(json[key])) {\n          return void 0;\n        }\n        if (!json[key].shape || !json[key].files) {\n          return void 0;\n        }\n        if (key !== "quats" && (!json[key].mins || !json[key].maxs)) {\n          return void 0;\n        }\n      }\n      return json;\n    } catch {\n      return void 0;\n    }\n  }\n  function tryPcSogsZip(input) {\n    try {\n      const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n      let metaFilename = null;\n      const unzipped = unzipSync(fileBytes, {\n        filter: ({ name }) => {\n          const filename = name.split(/[\\\\/]/).pop();\n          if (filename === "meta.json") {\n            metaFilename = name;\n            return true;\n          }\n          return false;\n        }\n      });\n      if (!metaFilename) {\n        return void 0;\n      }\n      const json = tryPcSogs(unzipped[metaFilename]);\n      if (!json) {\n        return void 0;\n      }\n      return { name: metaFilename, json };\n    } catch {\n      return void 0;\n    }\n  }\n  async function unpackSplats({\n    input,\n    extraFiles,\n    fileType,\n    pathOrUrl\n  }) {\n    const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n    let splatFileType = fileType;\n    if (!fileType) {\n      splatFileType = getSplatFileType(fileBytes);\n      if (!splatFileType && pathOrUrl) {\n        splatFileType = getSplatFileTypeFromPath(pathOrUrl);\n      }\n    }\n    switch (splatFileType) {\n      case "ply": {\n        const ply = new PlyReader({ fileBytes });\n        await ply.parseHeader();\n        const numSplats = ply.numSplats;\n        const maxSplats = getTextureSize(numSplats).maxSplats;\n        const args = { fileBytes, packedArray: new Uint32Array(maxSplats * 4) };\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats: numSplats2, extra } = await worker.call(\n            "unpackPly",\n            args\n          );\n          return { packedArray, numSplats: numSplats2, extra };\n        });\n      }\n      case "spz": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            "decodeSpz",\n            {\n              fileBytes\n            }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      case "splat": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats } = await worker.call(\n            "decodeAntiSplat",\n            {\n              fileBytes\n            }\n          );\n          return { packedArray, numSplats };\n        });\n      }\n      case "ksplat": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            "decodeKsplat",\n            { fileBytes }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      case "pcsogs": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            "decodePcSogs",\n            { fileBytes, extraFiles }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      case "pcsogszip": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            "decodePcSogsZip",\n            { fileBytes }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      default: {\n        throw new Error(`Unknown splat file type: ${splatFileType}`);\n      }\n    }\n  }\n  class SplatData {\n    constructor({ maxSplats = 1 } = {}) {\n      this.numSplats = 0;\n      this.maxSplats = getTextureSize(maxSplats).maxSplats;\n      this.centers = new Float32Array(this.maxSplats * 3);\n      this.scales = new Float32Array(this.maxSplats * 3);\n      this.quaternions = new Float32Array(this.maxSplats * 4);\n      this.opacities = new Float32Array(this.maxSplats);\n      this.colors = new Float32Array(this.maxSplats * 3);\n    }\n    pushSplat() {\n      const index = this.numSplats;\n      this.ensureIndex(index);\n      this.numSplats += 1;\n      return index;\n    }\n    unpushSplat(index) {\n      if (index === this.numSplats - 1) {\n        this.numSplats -= 1;\n      } else {\n        throw new Error("Cannot unpush splat from non-last position");\n      }\n    }\n    ensureCapacity(numSplats) {\n      if (numSplats > this.maxSplats) {\n        const targetSplats = Math.max(numSplats, this.maxSplats * 2);\n        const newCenters = new Float32Array(targetSplats * 3);\n        const newScales = new Float32Array(targetSplats * 3);\n        const newQuaternions = new Float32Array(targetSplats * 4);\n        const newOpacities = new Float32Array(targetSplats);\n        const newColors = new Float32Array(targetSplats * 3);\n        newCenters.set(this.centers);\n        newScales.set(this.scales);\n        newQuaternions.set(this.quaternions);\n        newOpacities.set(this.opacities);\n        newColors.set(this.colors);\n        this.centers = newCenters;\n        this.scales = newScales;\n        this.quaternions = newQuaternions;\n        this.opacities = newOpacities;\n        this.colors = newColors;\n        if (this.sh1) {\n          const newSh1 = new Float32Array(targetSplats * 9);\n          newSh1.set(this.sh1);\n          this.sh1 = newSh1;\n        }\n        if (this.sh2) {\n          const newSh2 = new Float32Array(targetSplats * 15);\n          newSh2.set(this.sh2);\n          this.sh2 = newSh2;\n        }\n        if (this.sh3) {\n          const newSh3 = new Float32Array(targetSplats * 21);\n          newSh3.set(this.sh3);\n          this.sh3 = newSh3;\n        }\n        this.maxSplats = targetSplats;\n      }\n    }\n    ensureIndex(index) {\n      this.ensureCapacity(index + 1);\n    }\n    setCenter(index, x2, y, z) {\n      this.centers[index * 3] = x2;\n      this.centers[index * 3 + 1] = y;\n      this.centers[index * 3 + 2] = z;\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      this.scales[index * 3] = scaleX;\n      this.scales[index * 3 + 1] = scaleY;\n      this.scales[index * 3 + 2] = scaleZ;\n    }\n    setQuaternion(index, x2, y, z, w) {\n      this.quaternions[index * 4] = x2;\n      this.quaternions[index * 4 + 1] = y;\n      this.quaternions[index * 4 + 2] = z;\n      this.quaternions[index * 4 + 3] = w;\n    }\n    setOpacity(index, opacity) {\n      this.opacities[index] = opacity;\n    }\n    setColor(index, r, g, b) {\n      this.colors[index * 3] = r;\n      this.colors[index * 3 + 1] = g;\n      this.colors[index * 3 + 2] = b;\n    }\n    setSh1(index, sh1) {\n      if (!this.sh1) {\n        this.sh1 = new Float32Array(this.maxSplats * 9);\n      }\n      for (let j = 0; j < 9; ++j) {\n        this.sh1[index * 9 + j] = sh1[j];\n      }\n    }\n    setSh2(index, sh2) {\n      if (!this.sh2) {\n        this.sh2 = new Float32Array(this.maxSplats * 15);\n      }\n      for (let j = 0; j < 15; ++j) {\n        this.sh2[index * 15 + j] = sh2[j];\n      }\n    }\n    setSh3(index, sh3) {\n      if (!this.sh3) {\n        this.sh3 = new Float32Array(this.maxSplats * 21);\n      }\n      for (let j = 0; j < 21; ++j) {\n        this.sh3[index * 21 + j] = sh3[j];\n      }\n    }\n  }\n  async function unpackPcSogs(json, extraFiles) {\n    if (json.quats.encoding !== "quaternion_packed") {\n      throw new Error("Unsupported quaternion encoding");\n    }\n    const numSplats = json.means.shape[0];\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    const means = await Promise.all([\n      decodeImageRgba(extraFiles[json.means.files[0]]),\n      decodeImageRgba(extraFiles[json.means.files[1]])\n    ]);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const fx = (means[0][i4 + 0] + (means[1][i4 + 0] << 8)) / 65535;\n      const fy = (means[0][i4 + 1] + (means[1][i4 + 1] << 8)) / 65535;\n      const fz = (means[0][i4 + 2] + (means[1][i4 + 2] << 8)) / 65535;\n      let x2 = json.means.mins[0] + (json.means.maxs[0] - json.means.mins[0]) * fx;\n      let y = json.means.mins[1] + (json.means.maxs[1] - json.means.mins[1]) * fy;\n      let z = json.means.mins[2] + (json.means.maxs[2] - json.means.mins[2]) * fz;\n      x2 = Math.sign(x2) * (Math.exp(Math.abs(x2)) - 1);\n      y = Math.sign(y) * (Math.exp(Math.abs(y)) - 1);\n      z = Math.sign(z) * (Math.exp(Math.abs(z)) - 1);\n      setPackedSplatCenter(packedArray, i2, x2, y, z);\n    }\n    const scales = await decodeImageRgba(extraFiles[json.scales.files[0]]);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const fx = scales[i4 + 0] / 255;\n      const fy = scales[i4 + 1] / 255;\n      const fz = scales[i4 + 2] / 255;\n      const x2 = json.scales.mins[0] + (json.scales.maxs[0] - json.scales.mins[0]) * fx;\n      const y = json.scales.mins[1] + (json.scales.maxs[1] - json.scales.mins[1]) * fy;\n      const z = json.scales.mins[2] + (json.scales.maxs[2] - json.scales.mins[2]) * fz;\n      setPackedSplatScales(packedArray, i2, Math.exp(x2), Math.exp(y), Math.exp(z));\n    }\n    const quats = await decodeImageRgba(extraFiles[json.quats.files[0]]);\n    const SQRT2 = Math.sqrt(2);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const r0 = (quats[i4 + 0] / 255 - 0.5) * SQRT2;\n      const r1 = (quats[i4 + 1] / 255 - 0.5) * SQRT2;\n      const r2 = (quats[i4 + 2] / 255 - 0.5) * SQRT2;\n      const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n      const rOrder = quats[i4 + 3] - 252;\n      const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n      const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n      const quatZ = rOrder <= 2 ? r2 : rr;\n      const quatW = rOrder === 0 ? rr : r0;\n      setPackedSplatQuat(packedArray, i2, quatX, quatY, quatZ, quatW);\n    }\n    const sh0 = await decodeImageRgba(extraFiles[json.sh0.files[0]]);\n    const SH_C02 = 0.28209479177387814;\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const f0 = sh0[i4 + 0] / 255;\n      const f1 = sh0[i4 + 1] / 255;\n      const f2 = sh0[i4 + 2] / 255;\n      const f3 = sh0[i4 + 3] / 255;\n      const dc0 = json.sh0.mins[0] + (json.sh0.maxs[0] - json.sh0.mins[0]) * f0;\n      const dc1 = json.sh0.mins[1] + (json.sh0.maxs[1] - json.sh0.mins[1]) * f1;\n      const dc2 = json.sh0.mins[2] + (json.sh0.maxs[2] - json.sh0.mins[2]) * f2;\n      const opa = json.sh0.mins[3] + (json.sh0.maxs[3] - json.sh0.mins[3]) * f3;\n      const r = SH_C02 * dc0 + 0.5;\n      const g = SH_C02 * dc1 + 0.5;\n      const b = SH_C02 * dc2 + 0.5;\n      const a = 1 / (1 + Math.exp(-opa));\n      setPackedSplatRgba(packedArray, i2, r, g, b, a);\n    }\n    if (json.shN) {\n      const useSH3 = json.shN.shape[1] >= 48 - 3;\n      const useSH2 = json.shN.shape[1] >= 27 - 3;\n      const useSH1 = json.shN.shape[1] >= 12 - 3;\n      if (useSH1) extra.sh1 = new Uint32Array(numSplats * 2);\n      if (useSH2) extra.sh2 = new Uint32Array(numSplats * 4);\n      if (useSH3) extra.sh3 = new Uint32Array(numSplats * 4);\n      const sh1 = new Float32Array(9);\n      const sh2 = new Float32Array(15);\n      const sh3 = new Float32Array(21);\n      const [centroids, labels] = await Promise.all([\n        decodeImage(extraFiles[json.shN.files[0]]),\n        decodeImage(extraFiles[json.shN.files[1]])\n      ]);\n      for (let i2 = 0; i2 < numSplats; ++i2) {\n        const i4 = i2 * 4;\n        const label = labels.rgba[i4 + 0] + (labels.rgba[i4 + 1] << 8);\n        const col = (label & 63) * 15;\n        const row = label >>> 6;\n        const offset = row * centroids.width + col;\n        for (let d = 0; d < 3; ++d) {\n          if (useSH1) {\n            for (let k = 0; k < 3; ++k) {\n              sh1[k * 3 + d] = json.shN.mins + (json.shN.maxs - json.shN.mins) * centroids.rgba[(offset + k) * 4 + d] / 255;\n            }\n          }\n          if (useSH2) {\n            for (let k = 0; k < 5; ++k) {\n              sh2[k * 3 + d] = json.shN.mins + (json.shN.maxs - json.shN.mins) * centroids.rgba[(offset + 3 + k) * 4 + d] / 255;\n            }\n          }\n          if (useSH3) {\n            for (let k = 0; k < 7; ++k) {\n              sh3[k * 3 + d] = json.shN.mins + (json.shN.maxs - json.shN.mins) * centroids.rgba[(offset + 8 + k) * 4 + d] / 255;\n            }\n          }\n        }\n        if (useSH1) encodeSh1Rgb(extra.sh1, i2, sh1);\n        if (useSH2) encodeSh2Rgb(extra.sh2, i2, sh2);\n        if (useSH3) encodeSh3Rgb(extra.sh3, i2, sh3);\n      }\n    }\n    return { packedArray, numSplats, extra };\n  }\n  let offscreenGlContext = null;\n  async function decodeImage(fileBytes) {\n    if (!offscreenGlContext) {\n      const canvas = new OffscreenCanvas(1, 1);\n      offscreenGlContext = canvas.getContext("webgl2");\n      if (!offscreenGlContext) {\n        throw new Error("Failed to create WebGL2 context");\n      }\n    }\n    const imageBlob = new Blob([fileBytes]);\n    const bitmap = await createImageBitmap(imageBlob, {\n      premultiplyAlpha: "none"\n    });\n    const gl = offscreenGlContext;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    const data = new Uint8Array(bitmap.width * bitmap.height * 4);\n    gl.readPixels(\n      0,\n      0,\n      bitmap.width,\n      bitmap.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      data\n    );\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(framebuffer);\n    return { rgba: data, width: bitmap.width, height: bitmap.height };\n  }\n  async function decodeImageRgba(fileBytes) {\n    const { rgba } = await decodeImage(fileBytes);\n    return rgba;\n  }\n  async function unpackPcSogsZip(fileBytes) {\n    var _a2;\n    const nameJson = tryPcSogsZip(fileBytes);\n    if (!nameJson) {\n      throw new Error("Invalid PC SOGS zip file");\n    }\n    const { name, json } = nameJson;\n    const lastSlash = name.lastIndexOf("/");\n    const lastBackslash = name.lastIndexOf("\\\\");\n    const prefix = name.slice(0, Math.max(lastSlash, lastBackslash) + 1);\n    const fileMap = /* @__PURE__ */ new Map();\n    const refFiles = [\n      ...json.means.files,\n      ...json.scales.files,\n      ...json.quats.files,\n      ...json.sh0.files,\n      ...((_a2 = json.shN) == null ? void 0 : _a2.files) ?? []\n    ];\n    for (const file of refFiles) {\n      fileMap.set(prefix + file, file);\n    }\n    const unzipped = await new Promise(\n      (resolve, reject) => {\n        unzip(\n          fileBytes,\n          {\n            filter: ({ name: name2 }) => {\n              return fileMap.has(name2);\n            }\n          },\n          (err2, files) => {\n            if (err2) {\n              reject(err2);\n            } else {\n              resolve(files);\n            }\n          }\n        );\n      }\n    );\n    const extraFiles = {};\n    for (const [full, name2] of fileMap.entries()) {\n      extraFiles[name2] = unzipped[full];\n    }\n    return await unpackPcSogs(json, extraFiles);\n  }\n  class SpzReader {\n    constructor({ fileBytes }) {\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n      this.reader = new GunzipReader({ fileBytes: this.fileBytes });\n      const header = new DataView(this.reader.read(16).buffer);\n      if (header.getUint32(0, true) !== 1347635022) {\n        throw new Error("Invalid SPZ file");\n      }\n      this.version = header.getUint32(4, true);\n      if (this.version < 1 || this.version > 2) {\n        throw new Error(`Unsupported SPZ version: ${this.version}`);\n      }\n      this.numSplats = header.getUint32(8, true);\n      this.shDegree = header.getUint8(12);\n      this.fractionalBits = header.getUint8(13);\n      this.flags = header.getUint8(14);\n      this.flagAntiAlias = (this.flags & 1) !== 0;\n      this.reserved = header.getUint8(15);\n      this.parsed = false;\n    }\n    parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {\n      if (this.parsed) {\n        throw new Error("SPZ file already parsed");\n      }\n      this.parsed = true;\n      if (this.version === 1) {\n        const centerBytes = this.reader.read(this.numSplats * 3 * 2);\n        const centerUint16 = new Uint16Array(centerBytes.buffer);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const x2 = fromHalf(centerUint16[i3]);\n          const y = fromHalf(centerUint16[i3 + 1]);\n          const z = fromHalf(centerUint16[i3 + 2]);\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else if (this.version === 2) {\n        const fixed = 1 << this.fractionalBits;\n        const centerBytes = this.reader.read(this.numSplats * 3 * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i9 = i2 * 9;\n          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;\n          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\n          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else {\n        throw new Error("Unreachable");\n      }\n      {\n        const bytes = this.reader.read(this.numSplats);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);\n        }\n      }\n      {\n        const rgbBytes = this.reader.read(this.numSplats * 3);\n        const scale = SH_C0 / 0.15;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\n          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\n          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;\n          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);\n        }\n      }\n      {\n        const scalesBytes = this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\n          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);\n          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);\n          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);\n        }\n      }\n      {\n        const quatBytes = this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const quatX = quatBytes[i3] / 127.5 - 1;\n          const quatY = quatBytes[i3 + 1] / 127.5 - 1;\n          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\n          const quatW = Math.sqrt(\n            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\n          );\n          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);\n        }\n      }\n      if (shCallback && this.shDegree >= 1) {\n        const sh1 = new Float32Array(3 * 3);\n        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n        const shBytes = this.reader.read(\n          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3\n        );\n        let offset = 0;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          for (let j = 0; j < 9; ++j) {\n            sh1[j] = (shBytes[offset + j] - 128) / 128;\n          }\n          offset += 9;\n          if (sh2) {\n            for (let j = 0; j < 15; ++j) {\n              sh2[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 15;\n          }\n          if (sh3) {\n            for (let j = 0; j < 21; ++j) {\n              sh3[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 21;\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n    }\n  }\n  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\n  const SH_C0 = 0.28209479177387814;\n  const SPZ_MAGIC = 1347635022;\n  const SPZ_VERSION = 2;\n  const FLAG_ANTIALIASED = 1;\n  class SpzWriter {\n    constructor({\n      numSplats,\n      shDegree,\n      fractionalBits = 12,\n      flagAntiAlias = true\n    }) {\n      this.clippedCount = 0;\n      const splatSize = 9 + 1 + 3 + 3 + 3 + (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\n      const bufferSize = 16 + numSplats * splatSize;\n      this.buffer = new ArrayBuffer(bufferSize);\n      this.view = new DataView(this.buffer);\n      this.view.setUint32(0, SPZ_MAGIC, true);\n      this.view.setUint32(4, SPZ_VERSION, true);\n      this.view.setUint32(8, numSplats, true);\n      this.view.setUint8(12, shDegree);\n      this.view.setUint8(13, fractionalBits);\n      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);\n      this.view.setUint8(15, 0);\n      this.numSplats = numSplats;\n      this.shDegree = shDegree;\n      this.fractionalBits = fractionalBits;\n      this.fraction = 1 << fractionalBits;\n      this.flagAntiAlias = flagAntiAlias;\n    }\n    setCenter(index, x2, y, z) {\n      const xRounded = Math.round(x2 * this.fraction);\n      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));\n      const yRounded = Math.round(y * this.fraction);\n      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\n      const zRounded = Math.round(z * this.fraction);\n      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));\n      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\n      if (clipped) {\n        this.clippedCount += 1;\n      }\n      const i9 = index * 9;\n      const base = 16 + i9;\n      this.view.setUint8(base, xInt & 255);\n      this.view.setUint8(base + 1, xInt >> 8 & 255);\n      this.view.setUint8(base + 2, xInt >> 16 & 255);\n      this.view.setUint8(base + 3, yInt & 255);\n      this.view.setUint8(base + 4, yInt >> 8 & 255);\n      this.view.setUint8(base + 5, yInt >> 16 & 255);\n      this.view.setUint8(base + 6, zInt & 255);\n      this.view.setUint8(base + 7, zInt >> 8 & 255);\n      this.view.setUint8(base + 8, zInt >> 16 & 255);\n    }\n    setAlpha(index, alpha) {\n      const base = 16 + this.numSplats * 9 + index;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round(alpha * 255)))\n      );\n    }\n    static scaleRgb(r) {\n      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\n      return Math.max(0, Math.min(255, Math.round(v)));\n    }\n    setRgb(index, r, g, b) {\n      const base = 16 + this.numSplats * 10 + index * 3;\n      this.view.setUint8(base, SpzWriter.scaleRgb(r));\n      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\n      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      const base = 16 + this.numSplats * 13 + index * 3;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\n      );\n    }\n    setQuat(index, quatX, quatY, quatZ, quatW) {\n      const base = 16 + this.numSplats * 16 + index * 3;\n      const quatNeg = quatW < 0;\n      this.view.setUint8(\n        base,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatX : quatX) + 1) * 127.5))\n        )\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatY : quatY) + 1) * 127.5))\n        )\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatZ : quatZ) + 1) * 127.5))\n        )\n      );\n    }\n    static quantizeSh(sh, bits2) {\n      const value = Math.round(sh * 128) + 128;\n      const bucketSize = 1 << 8 - bits2;\n      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\n      return Math.max(0, Math.min(255, quantized));\n    }\n    setSh(index, sh1, sh2, sh3) {\n      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\n      const base1 = 16 + this.numSplats * 19 + index * shVecs * 3;\n      for (let j = 0; j < 9; ++j) {\n        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\n      }\n      if (sh2) {\n        const base2 = base1 + 9;\n        for (let j = 0; j < 15; ++j) {\n          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\n        }\n        if (sh3) {\n          const base3 = base2 + 15;\n          for (let j = 0; j < 21; ++j) {\n            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\n          }\n        }\n      }\n    }\n    async finalize() {\n      const input = new Uint8Array(this.buffer);\n      const stream = new ReadableStream({\n        async start(controller) {\n          controller.enqueue(input);\n          controller.close();\n        }\n      });\n      const compressed = stream.pipeThrough(new CompressionStream("gzip"));\n      const response = new Response(compressed);\n      const buffer = await response.arrayBuffer();\n      console.log(\n        "Compressed",\n        input.length,\n        "bytes to",\n        buffer.byteLength,\n        "bytes"\n      );\n      return new Uint8Array(buffer);\n    }\n  }\n  async function transcodeSpz(input) {\n    var _a2, _b2, _c;\n    const splats = new SplatData();\n    const {\n      inputs,\n      clipXyz,\n      maxSh,\n      fractionalBits = 12,\n      opacityThreshold\n    } = input;\n    for (const input2 of inputs) {\n      let transformPos2 = function(pos) {\n        pos.multiplyScalar(scale);\n        pos.applyQuaternion(quaternion);\n        pos.add(translate);\n        return pos;\n      }, transformScales = function(scales) {\n        scales.multiplyScalar(scale);\n        return scales;\n      }, transformQuaternion = function(quat) {\n        quat.premultiply(quaternion);\n        return quat;\n      }, withinClip = function(p) {\n        return !clip || clip.containsPoint(p);\n      }, withinOpacity = function(opacity) {\n        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\n      };\n      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\n      const quaternion = new Quaternion().fromArray(\n        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\n      );\n      const translate = new Vector3().fromArray(\n        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\n      );\n      const clip = clipXyz ? new Box3(\n        new Vector3().fromArray(clipXyz.min),\n        new Vector3().fromArray(clipXyz.max)\n      ) : void 0;\n      let fileType = input2.fileType;\n      if (!fileType) {\n        fileType = getSplatFileType(input2.fileBytes);\n        if (!fileType && input2.pathOrUrl) {\n          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\n        }\n      }\n      switch (fileType) {\n        case SplatFileType.PLY: {\n          const ply = new PlyReader({ fileBytes: input2.fileBytes });\n          await ply.parseHeader();\n          let lastIndex = null;\n          ply.parseSplats(\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (sh1 && lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n              }\n              if (sh2 && lastIndex !== null) {\n                splats.setSh2(lastIndex, sh2);\n              }\n              if (sh3 && lastIndex !== null) {\n                splats.setSh3(lastIndex, sh3);\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPZ: {\n          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });\n          const mapping = new Int32Array(spz2.numSplats);\n          mapping.fill(-1);\n          const centers = new Float32Array(spz2.numSplats * 3);\n          const center = new Vector3();\n          spz2.parseSplats(\n            (index, x2, y, z) => {\n              const center2 = transformPos2(new Vector3(x2, y, z));\n              centers[index * 3] = center2.x;\n              centers[index * 3 + 1] = center2.y;\n              centers[index * 3 + 2] = center2.z;\n            },\n            (index, alpha) => {\n              center.fromArray(centers, index * 3);\n              if (withinClip(center) && withinOpacity(alpha)) {\n                mapping[index] = splats.pushSplat();\n                splats.setCenter(mapping[index], center.x, center.y, center.z);\n                splats.setOpacity(mapping[index], alpha);\n              }\n            },\n            (index, r, g, b) => {\n              if (mapping[index] >= 0) {\n                splats.setColor(mapping[index], r, g, b);\n              }\n            },\n            (index, scaleX, scaleY, scaleZ) => {\n              if (mapping[index] >= 0) {\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(mapping[index], scales.x, scales.y, scales.z);\n              }\n            },\n            (index, quatX, quatY, quatZ, quatW) => {\n              if (mapping[index] >= 0) {\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  mapping[index],\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (mapping[index] >= 0) {\n                splats.setSh1(mapping[index], sh1);\n                if (sh2) {\n                  splats.setSh2(mapping[index], sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(mapping[index], sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPLAT:\n          decodeAntiSplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                const index2 = splats.pushSplat();\n                splats.setCenter(index2, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(index2, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  index2,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(index2, opacity);\n                splats.setColor(index2, r, g, b);\n              }\n            }\n          );\n          break;\n        case SplatFileType.KSPLAT: {\n          let lastIndex = null;\n          decodeKsplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n                if (sh2) {\n                  splats.setSh2(lastIndex, sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(lastIndex, sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        default:\n          throw new Error(`transcodeSpz not implemented for ${fileType}`);\n      }\n    }\n    const shDegree = Math.min(\n      maxSh ?? 3,\n      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0\n    );\n    const spz = new SpzWriter({\n      numSplats: splats.numSplats,\n      shDegree,\n      fractionalBits,\n      flagAntiAlias: true\n    });\n    for (let i2 = 0; i2 < splats.numSplats; ++i2) {\n      const i3 = i2 * 3;\n      const i4 = i2 * 4;\n      spz.setCenter(\n        i2,\n        splats.centers[i3],\n        splats.centers[i3 + 1],\n        splats.centers[i3 + 2]\n      );\n      spz.setScale(\n        i2,\n        splats.scales[i3],\n        splats.scales[i3 + 1],\n        splats.scales[i3 + 2]\n      );\n      spz.setQuat(\n        i2,\n        splats.quaternions[i4],\n        splats.quaternions[i4 + 1],\n        splats.quaternions[i4 + 2],\n        splats.quaternions[i4 + 3]\n      );\n      spz.setAlpha(i2, splats.opacities[i2]);\n      spz.setRgb(\n        i2,\n        splats.colors[i3],\n        splats.colors[i3 + 1],\n        splats.colors[i3 + 2]\n      );\n      if (splats.sh1 && shDegree >= 1) {\n        spz.setSh(\n          i2,\n          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),\n          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,\n          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0\n        );\n      }\n    }\n    const spzBytes = await spz.finalize();\n    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };\n  }\n  async function onMessage(event) {\n    const { name, args, id } = event.data;\n    let result = void 0;\n    let error = void 0;\n    try {\n      switch (name) {\n        case "unpackPly": {\n          const { packedArray, fileBytes } = args;\n          const decoded = await unpackPly({ packedArray, fileBytes });\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeSpz": {\n          const { fileBytes } = args;\n          const decoded = unpackSpz(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeAntiSplat": {\n          const { fileBytes } = args;\n          const decoded = unpackAntiSplat(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray\n          };\n          break;\n        }\n        case "decodeKsplat": {\n          const { fileBytes } = args;\n          const decoded = unpackKsplat(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodePcSogs": {\n          const { fileBytes, extraFiles } = args;\n          const json = JSON.parse(\n            new TextDecoder().decode(fileBytes)\n          );\n          const decoded = await unpackPcSogs(json, extraFiles);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodePcSogsZip": {\n          const { fileBytes } = args;\n          const decoded = await unpackPcSogsZip(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "sortSplats": {\n          const { maxSplats, totalSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ...sortSplats({ totalSplats, readback, ordering })\n          };\n          break;\n        }\n        case "sortDoubleSplats": {\n          const { numSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ordering\n          };\n          if (WASM_SPLAT_SORT) {\n            result = {\n              id,\n              readback,\n              ordering,\n              activeSplats: sort_splats(numSplats, readback, ordering)\n            };\n          }\n          break;\n        }\n        case "transcodeSpz": {\n          const input = args;\n          const spzBytes = await transcodeSpz(input);\n          result = {\n            id,\n            fileBytes: spzBytes,\n            input\n          };\n          break;\n        }\n        default: {\n          throw new Error(`Unknown name: ${name}`);\n        }\n      }\n    } catch (e) {\n      error = e;\n    }\n    self.postMessage(\n      { id, result, error },\n      { transfer: getArrayBuffers(result) }\n    );\n  }\n  async function unpackPly({\n    packedArray,\n    fileBytes\n  }) {\n    const ply = new PlyReader({ fileBytes });\n    await ply.parseHeader();\n    const numSplats = ply.numSplats;\n    const extra = {};\n    ply.parseSplats(\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  function unpackSpz(fileBytes) {\n    const spz = new SpzReader({ fileBytes });\n    const numSplats = spz.numSplats;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    spz.parseSplats(\n      (index, x2, y, z) => {\n        setPackedSplatCenter(packedArray, index, x2, y, z);\n      },\n      (index, alpha) => {\n        setPackedSplatOpacity(packedArray, index, alpha);\n      },\n      (index, r, g, b) => {\n        setPackedSplatRgb(packedArray, index, r, g, b);\n      },\n      (index, scaleX, scaleY, scaleZ) => {\n        setPackedSplatScales(packedArray, index, scaleX, scaleY, scaleZ);\n      },\n      (index, quatX, quatY, quatZ, quatW) => {\n        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  const DEPTH_INFINITY = 31744;\n  const DEPTH_SIZE = DEPTH_INFINITY + 1;\n  let depthArray = null;\n  function sortSplats({\n    totalSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray) {\n      depthArray = new Uint32Array(DEPTH_SIZE);\n    }\n    depthArray.fill(0);\n    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));\n    const layerSize = readbackUint32[0].length;\n    const numLayers = Math.ceil(totalSplats / layerSize);\n    let layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY) {\n          depthArray[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    let activeSplats = 0;\n    for (let j = 0; j < DEPTH_SIZE; ++j) {\n      const nextIndex = activeSplats + depthArray[j];\n      depthArray[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY) {\n          ordering[depthArray[pri]] = layerBase + i2;\n          depthArray[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    if (depthArray[DEPTH_SIZE - 1] !== activeSplats) {\n      throw new Error(\n        `Expected ${activeSplats} active splats but got ${depthArray[DEPTH_SIZE - 1]}`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  function sortDoubleSplats({\n    numSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray) {\n      depthArray = new Uint32Array(DEPTH_SIZE);\n    }\n    depthArray.fill(0);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const pri = readback[i2];\n      if (pri < DEPTH_INFINITY) {\n        depthArray[pri] += 1;\n      }\n    }\n    let activeSplats = 0;\n    for (let j = DEPTH_INFINITY - 1; j >= 0; --j) {\n      const nextIndex = activeSplats + depthArray[j];\n      depthArray[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const pri = readback[i2];\n      if (pri < DEPTH_INFINITY) {\n        ordering[depthArray[pri]] = i2;\n        depthArray[pri] += 1;\n      }\n    }\n    if (depthArray[0] !== activeSplats) {\n      throw new Error(\n        `Expected ${activeSplats} active splats but got ${depthArray[0]}`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  const messageBuffer = [];\n  function bufferMessage(event) {\n    messageBuffer.push(event);\n  }\n  async function initialize() {\n    self.addEventListener("message", bufferMessage);\n    await __wbg_init();\n    self.removeEventListener("message", bufferMessage);\n    self.addEventListener("message", onMessage);\n    for (const event of messageBuffer) {\n      onMessage(event);\n    }\n    messageBuffer.length = 0;\n  }\n  initialize().catch(console.error);\n})();\n//# sourceMappingURL=worker-CrWee7Fs.js.map\n',sr="undefined"!=typeof self&&self.Blob&&new Blob([er],{type:"text/javascript;charset=utf-8"});function ar(A){let n;try{if(n=sr&&(self.URL||self.webkitURL).createObjectURL(sr),!n)throw"";const t=new Worker(n,{name:null==A?void 0:A.name});return t.addEventListener("error",(()=>{(self.URL||self.webkitURL).revokeObjectURL(n)})),t}catch(n){return new Worker("data:text/javascript;charset=utf-8,"+encodeURIComponent(er),{name:null==A?void 0:A.name})}finally{n&&(self.URL||self.webkitURL).revokeObjectURL(n)}}class ir{constructor(){this.messages={},this.messageIdNext=0,this.worker=new ar,this.worker.onmessage=A=>this.onMessage(A)}makeMessageId(){return++this.messageIdNext}makeMessagePromiseId(){const A=this.makeMessageId(),n=new Promise(((n,t)=>{this.messages[A]={resolve:n,reject:t}}));return{id:A,promise:n}}onMessage(A){const{id:n,result:t,error:e}=A.data,s=this.messages[n];s&&(delete this.messages[n],e?s.reject(e):s.resolve(t))}async call(A,n){const{id:t,promise:e}=this.makeMessagePromiseId();return this.worker.postMessage({name:A,args:n,id:t},{transfer:gt(n)}),e}}let rr=4,or=0;const gr=[],cr=[];async function Ir(A){const n=await async function(){const A=gr.shift();if(A)return A;if(or<rr){const A=new ir;return or+=1,A}return new Promise((A=>{cr.push(A)}))}();try{return await A(n)}finally{!function(A){if(or>rr)return void(or-=1);const n=cr.shift();n?n(A):gr.push(A)}(n)}}class lr extends e.Loader{constructor(A){super(A),this.fileLoader=new e.FileLoader(A)}load(A,n,t,e){const s=this.manager.resolveURL((this.path??"")+(A??"")),a=new Headers(this.requestHeader),i=this.withCredentials?"include":"same-origin",r=new Request(s,{headers:a,credentials:i});let o=this.fileType;this.manager.itemStart(s),Br(r,t).then((async A=>{const e=[new ProgressEvent("progress",{lengthComputable:!0,loaded:A.byteLength,total:A.byteLength})];function r(){if(t){const A=e.every((A=>A.lengthComputable||0===A.loaded&&0===A.total)),n=e.reduce(((A,n)=>A+n.loaded),0),s=e.reduce(((A,n)=>A+n.total),0);t(new ProgressEvent("progress",{lengthComputable:A,loaded:n,total:s}))}}const g={},c=[],I=hr(A);if("pcsogs"===o&&void 0===I)throw new Error("Invalid PC SOGS file");if(void 0!==I){o="pcsogs";for(const A of["means","scales","quats","sh0","shN"]){const n=I[A];if(n)for(const A of n.files){const n=new URL(A,s).toString(),t=e.length;e.push(new ProgressEvent("progress")),this.manager.itemStart(n);const o=Br(new Request(n,{headers:a,credentials:i}),(A=>{e[t]=A,r()})).then((n=>{g[A]=n})).catch((A=>{throw this.manager.itemError(n),A})).finally((()=>{this.manager.itemEnd(n)}));c.push(o)}}}if(await Promise.all(c),n){const t=await pr({input:A,extraFiles:g,fileType:o,pathOrUrl:s});this.packedSplats?(this.packedSplats.initialize(t),n(this.packedSplats)):n(new fr(t))}})).catch((A=>{this.manager.itemError(s),null==e||e(A)})).finally((()=>{this.manager.itemEnd(s)}))}async loadAsync(A,n){return new Promise(((t,e)=>{this.load(A,(A=>{t(A)}),n,e)}))}parse(A){return new qi({packedSplats:A})}}async function Br(A,n){const t=await fetch(A);if(!t.ok)throw new Error(`${t.status} "${t.statusText}" fetching URL: ${A.url}`);if(!t.body)throw new Error(`Response body is null for URL: ${A.url}`);const e=t.body.getReader(),s=Number.parseInt(t.headers.get("Content-Length")||"0"),a=Number.isNaN(s)?0:s;let i=0;const r=[];for(;;){const{done:A,value:t}=await e.read();if(A)break;r.push(t),i+=t.length,n&&n(new ProgressEvent("progress",{lengthComputable:0!==a,loaded:i,total:a}))}const o=new Uint8Array(i);let g=0;for(const A of r)o.set(A,g),g+=A.length;return o.buffer}var Qr=(A=>(A.PLY="ply",A.SPZ="spz",A.SPLAT="splat",A.KSPLAT="ksplat",A.PCSOGS="pcsogs",A.PCSOGSZIP="pcsogszip",A))(Qr||{});function ur(A){const n=new DataView(A.buffer);if(7957616==(16777215&n.getUint32(0,!0)))return"ply";if(559903==(16777215&n.getUint32(0,!0))){const n=Mt(A,4);return 1347635022===new DataView(n.buffer).getUint32(0,!0)?"spz":void 0}return 67324752===n.getUint32(0,!0)&&function(A){try{const n=A instanceof ArrayBuffer?new Uint8Array(A):A;let t=null;const e=function(A,n){for(var t={},e=A.length-22;101010256!=N(A,e);--e)(!e||A.length-e>65558)&&k(13);var a=F(A,e+8);if(!a)return{};var i=N(A,e+16),r=4294967295==i||65535==a;if(r){var o=N(A,e-12);(r=101075792==N(A,o))&&(a=N(A,o+32),i=N(A,o+48))}for(var g=n&&n.filter,c=0;c<a;++c){var I=J(A,i,r),l=I[0],B=I[1],Q=I[2],u=I[3],C=I[4],E=I[5],h=Y(A,E);i=C,g&&!g({name:u,size:B,originalSize:Q,compression:l})||(l?8==l?t[u]=U(A.subarray(h,h+B),{out:new s(Q)}):k(14,"unknown compression type "+l):t[u]=S(A,h,h+B))}return t}(n,{filter:({name:A})=>"meta.json"===A.split(/[\\/]/).pop()&&(t=A,!0)});if(!t)return;const a=hr(e[t]);if(!a)return;return{name:t,json:a}}catch{return}}(A)?"pcsogszip":void 0}function Cr(A){const n=function(A){const n=A.split(/[?#]/,1)[0],t=Math.max(n.lastIndexOf("/"),n.lastIndexOf("\\")),e=n.slice(t+1),s=e.lastIndexOf(".");return s<=0||s===e.length-1?"":e.slice(s+1).toLowerCase()}(A);return"ply"===n?"ply":"spz"===n?"spz":"splat"===n?"splat":"ksplat"===n?"ksplat":void 0}function Er(A){return void 0!==hr(A)}function hr(A){try{let n;if("string"==typeof A)n=A;else{const t=A instanceof ArrayBuffer?new Uint8Array(A):A;if(t.length>65536)return;n=(new TextDecoder).decode(t)}const t=JSON.parse(n);if(!t||"object"!=typeof t||Array.isArray(t))return;for(const A of["means","scales","quats","sh0"]){if(!t[A]||"object"!=typeof t[A]||Array.isArray(t[A]))return;if(!t[A].shape||!t[A].files)return;if(!("quats"===A||t[A].mins&&t[A].maxs))return}return t}catch{return}}async function pr({input:A,extraFiles:n,fileType:t,pathOrUrl:e}){const s=A instanceof ArrayBuffer?new Uint8Array(A):A;let a=t;switch(t||(a=ur(s),!a&&e&&(a=Cr(e))),a){case"ply":{const A=new Vi({fileBytes:s});await A.parseHeader();const n=Qt(A.numSplats).maxSplats,t={fileBytes:s,packedArray:new Uint32Array(4*n)};return await Ir((async A=>{const{packedArray:n,numSplats:e,extra:s}=await A.call("unpackPly",t);return{packedArray:n,numSplats:e,extra:s}}))}case"spz":return await Ir((async A=>{const{packedArray:n,numSplats:t,extra:e}=await A.call("decodeSpz",{fileBytes:s});return{packedArray:n,numSplats:t,extra:e}}));case"splat":return await Ir((async A=>{const{packedArray:n,numSplats:t}=await A.call("decodeAntiSplat",{fileBytes:s});return{packedArray:n,numSplats:t}}));case"ksplat":return await Ir((async A=>{const{packedArray:n,numSplats:t,extra:e}=await A.call("decodeKsplat",{fileBytes:s});return{packedArray:n,numSplats:t,extra:e}}));case"pcsogs":return await Ir((async A=>{const{packedArray:t,numSplats:e,extra:a}=await A.call("decodePcSogs",{fileBytes:s,extraFiles:n});return{packedArray:t,numSplats:e,extra:a}}));case"pcsogszip":return await Ir((async A=>{const{packedArray:n,numSplats:t,extra:e}=await A.call("decodePcSogsZip",{fileBytes:s});return{packedArray:n,numSplats:t,extra:e}}));default:throw new Error(`Unknown splat file type: ${a}`)}}class dr{constructor({maxSplats:A=1}={}){this.numSplats=0,this.maxSplats=Qt(A).maxSplats,this.centers=new Float32Array(3*this.maxSplats),this.scales=new Float32Array(3*this.maxSplats),this.quaternions=new Float32Array(4*this.maxSplats),this.opacities=new Float32Array(this.maxSplats),this.colors=new Float32Array(3*this.maxSplats)}pushSplat(){const A=this.numSplats;return this.ensureIndex(A),this.numSplats+=1,A}unpushSplat(A){if(A!==this.numSplats-1)throw new Error("Cannot unpush splat from non-last position");this.numSplats-=1}ensureCapacity(A){if(A>this.maxSplats){const n=Math.max(A,2*this.maxSplats),t=new Float32Array(3*n),e=new Float32Array(3*n),s=new Float32Array(4*n),a=new Float32Array(n),i=new Float32Array(3*n);if(t.set(this.centers),e.set(this.scales),s.set(this.quaternions),a.set(this.opacities),i.set(this.colors),this.centers=t,this.scales=e,this.quaternions=s,this.opacities=a,this.colors=i,this.sh1){const A=new Float32Array(9*n);A.set(this.sh1),this.sh1=A}if(this.sh2){const A=new Float32Array(15*n);A.set(this.sh2),this.sh2=A}if(this.sh3){const A=new Float32Array(21*n);A.set(this.sh3),this.sh3=A}this.maxSplats=n}}ensureIndex(A){this.ensureCapacity(A+1)}setCenter(A,n,t,e){this.centers[3*A]=n,this.centers[3*A+1]=t,this.centers[3*A+2]=e}setScale(A,n,t,e){this.scales[3*A]=n,this.scales[3*A+1]=t,this.scales[3*A+2]=e}setQuaternion(A,n,t,e,s){this.quaternions[4*A]=n,this.quaternions[4*A+1]=t,this.quaternions[4*A+2]=e,this.quaternions[4*A+3]=s}setOpacity(A,n){this.opacities[A]=n}setColor(A,n,t,e){this.colors[3*A]=n,this.colors[3*A+1]=t,this.colors[3*A+2]=e}setSh1(A,n){this.sh1||(this.sh1=new Float32Array(9*this.maxSplats));for(let t=0;t<9;++t)this.sh1[9*A+t]=n[t]}setSh2(A,n){this.sh2||(this.sh2=new Float32Array(15*this.maxSplats));for(let t=0;t<15;++t)this.sh2[15*A+t]=n[t]}setSh3(A,n){this.sh3||(this.sh3=new Float32Array(21*this.maxSplats));for(let t=0;t<21;++t)this.sh3[21*A+t]=n[t]}}const yr=class A{constructor(A={}){this.maxSplats=0,this.numSplats=0,this.packedArray=null,this.isInitialized=!1,this.target=null,this.source=null,this.needsUpdate=!0,this.extra={},this.dyno=new mr({packedSplats:this}),this.initialized=Promise.resolve(this),this.reinitialize(A)}reinitialize(A){this.isInitialized=!1,A.url||A.fileBytes||A.construct?this.initialized=this.asyncInitialize(A).then((()=>(this.isInitialized=!0,this))):(this.initialize(A),this.isInitialized=!0,this.initialized=Promise.resolve(this))}initialize(A){A.packedArray?(this.packedArray=A.packedArray,this.maxSplats=Math.floor(this.packedArray.length/4),this.maxSplats=Math.floor(this.maxSplats/$)*$,this.numSplats=Math.min(this.maxSplats,A.numSplats??Number.POSITIVE_INFINITY)):(this.maxSplats=A.maxSplats??0,this.numSplats=0),this.extra=A.extra??{}}async asyncInitialize(A){const{url:n,fileBytes:t,construct:e}=A;if(n){const A=new lr;A.packedSplats=this,await A.loadAsync(n)}else if(t){const e=await pr({input:t,fileType:A.fileType,pathOrUrl:A.fileName??n});this.initialize(e)}if(e){const A=e(this);A instanceof Promise&&await A}}dispose(){this.target&&(this.target.dispose(),this.target=null),this.source&&(this.source.dispose(),this.source=null)}ensureSplats(A){const n=A<=this.maxSplats?this.maxSplats:Math.max(A,2*this.maxSplats),t=this.packedArray?this.packedArray.length/4:0;if(!this.packedArray||n>t){this.maxSplats=Qt(n).maxSplats;const A=new Uint32Array(4*this.maxSplats);this.packedArray&&A.set(this.packedArray),this.packedArray=A}return this.packedArray}ensureSplatsSh(A,n){let t,e;if(0===A)return this.ensureSplats(n);if(1===A)t=2,e="sh1";else if(2===A)t=4,e="sh2";else{if(3!==A)throw new Error(`Invalid level: ${A}`);t=4,e="sh3"}let s=this.extra[e]?this.extra[e].length/t:0;const a=n<=s?s:Math.max(n,2*s);if(!this.extra[e]||a>s){s=Qt(a).maxSplats;const A=new Uint32Array(s*t);this.extra[e]&&A.set(this.extra[e]),this.extra[e]=A}return this.extra[e]}getSplat(A){if(!this.packedArray||A>=this.numSplats)throw new Error("Invalid index");return Bt(this.packedArray,A)}setSplat(A,n,t,e,s,a){It(this.ensureSplats(A+1),A,n.x,n.y,n.z,t.x,t.y,t.z,e.x,e.y,e.z,e.w,s,a.r,a.g,a.b),this.numSplats=Math.max(this.numSplats,A+1)}pushSplat(A,n,t,e,s){It(this.ensureSplats(this.numSplats+1),this.numSplats,A.x,A.y,A.z,n.x,n.y,n.z,t.x,t.y,t.z,t.w,e,s.r,s.g,s.b),++this.numSplats}forEachSplat(A){if(this.packedArray&&this.numSplats)for(let n=0;n<this.numSplats;++n){const t=Bt(this.packedArray,n);A(n,t.center,t.scales,t.quaternion,t.opacity,t.color)}}ensureGenerate(A){if(this.target&&(A??1)<=this.maxSplats)return!1;this.dispose();const n=Qt(A??1),{width:t,height:s,depth:a}=n;return this.maxSplats=n.maxSplats,this.target=new e.WebGLArrayRenderTarget(t,s,a,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:e.NearestFilter,minFilter:e.NearestFilter}),this.target.texture.format=e.RGBAIntegerFormat,this.target.texture.type=e.UnsignedIntType,this.target.texture.internalFormat="RGBA32UI",this.target.scissorTest=!0,!0}generateMapping(A){let n=0;const t=A.map((A=>{const t=n,e=Math.ceil(A/$)*$;return n+=e,{base:t,count:A}}));return{maxSplats:n,mapping:t}}getTexture(){if(this.target)return this.target.texture;if(this.source||this.packedArray){return this.maybeUpdateSource()}return A.getEmpty()}maybeUpdateSource(){if(!this.packedArray)throw new Error("No packed splats");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:n,depth:t}=this.source.image;this.maxSplats!==A*n*t&&(this.source.dispose(),this.source=null)}if(this.source)this.packedArray.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.packedArray.buffer));else{const{width:A,height:n,depth:t}=Qt(this.maxSplats);this.source=new e.DataArrayTexture(this.packedArray,A,n,t),this.source.format=e.RGBAIntegerFormat,this.source.type=e.UnsignedIntType,this.source.internalFormat="RGBA32UI",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}static getEmpty(){if(!A.emptySource){const{width:n,height:t,depth:s,maxSplats:a}=Qt(1),i=new Uint32Array(4*a);A.emptySource=new e.DataArrayTexture(i,n,t,s),A.emptySource.format=e.RGBAIntegerFormat,A.emptySource.type=e.UnsignedIntType,A.emptySource.internalFormat="RGBA32UI",A.emptySource.needsUpdate=!0}return A.emptySource}prepareProgramMaterial(n){let t=A.generatorProgram.get(n);if(!t){const e=FA({index:"int"},{output:"uvec4"},(({index:A})=>{n.inputs.index=A;const t=n.outputs.gsplat;return{output:an(t)}}));A.programTemplate||(A.programTemplate=new Rt("precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout uvec4 target;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    } else {\n        target = uvec4(0u, 0u, 0u, 0u);\n    }\n}")),t=new Nt({graph:e,inputs:{index:"index"},outputs:{output:"target"},template:A.programTemplate}),Object.assign(t.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),A.generatorProgram.set(n,t)}const e=t.prepareMaterial();return A.mesh.material=e,{program:t,material:e}}saveRenderState(A){return{xrEnabled:A.xr.enabled,autoClear:A.autoClear}}resetRenderState(A,n){A.setRenderTarget(null),A.xr.enabled=n.xrEnabled,A.autoClear=n.autoClear}generate({generator:n,base:t,count:e,renderer:s}){if(!this.target)throw new Error("Target must be initialized with ensureSplats");if(t+e>this.maxSplats)throw new Error("Base + count exceeds maxSplats");const{program:a,material:i}=this.prepareProgramMaterial(n);a.update();const r=this.saveRenderState(s),o=Math.ceil((t+e)/$)*$,g=$*W;for(i.uniforms.targetBase.value=t,i.uniforms.targetCount.value=e;t<o;){const n=Math.floor(t/g);i.uniforms.targetLayer.value=n;const e=n*g,a=Math.floor((t-e)/$),r=Math.min(W,Math.ceil((o-e)/$));this.target.scissor.set(0,a,$,r-a),s.setRenderTarget(this.target,n),s.xr.enabled=!1,s.autoClear=!1,s.render(A.scene,A.camera),t+=$*(r-a)}return this.resetRenderState(s,r),{nextBase:o}}};yr.emptySource=null,yr.programTemplate=null,yr.generatorProgram=new Map,yr.geometry=new e.PlaneGeometry(2,2),yr.mesh=new e.Mesh(yr.geometry,new e.RawShaderMaterial({visible:!1})),yr.scene=(new e.Scene).add(yr.mesh),yr.camera=new e.Camera;let fr=yr;class mr extends In{constructor({packedSplats:A}={}){super({key:"packedSplats",type:JA,globals:()=>[jA],value:{texture:fr.getEmpty(),numSplats:0},update:A=>{var n,t;return A.texture=(null==(n=this.packedSplats)?void 0:n.getTexture())??fr.getEmpty(),A.numSplats=(null==(t=this.packedSplats)?void 0:t.numSplats)??0,A}}),this.packedSplats=A}}class wr extends e.InstancedBufferGeometry{constructor(A,n){super(),this.ordering=A,this.setAttribute("position",new e.BufferAttribute(Dr,3)),this.setIndex(new e.BufferAttribute(xr,1)),this._maxInstanceCount=A.length,this.instanceCount=n,this.attribute=new e.InstancedBufferAttribute(A,1,!1,1),this.attribute.setUsage(e.DynamicDrawUsage),this.setAttribute("splatIndex",this.attribute)}update(A,n){this.ordering=A,this.attribute.array=A,this.instanceCount=n,this.attribute.addUpdateRange(0,n),this.attribute.needsUpdate=!0}}const Dr=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0]),xr=new Uint16Array([0,1,2,0,2,3]),Sr=class A{constructor(A){if(this.lastTime=null,this.encodeLinear=!1,this.superXY=1,this.display=null,this.sorting=null,this.pending=null,this.sortingCheck=!1,this.readback=new Uint16Array(0),this.spark=A.spark,this.camera=A.camera,this.viewToWorld=A.viewToWorld??new e.Matrix4,A.target){const{width:n,height:t,doubleBuffer:s}=A.target,a=Math.max(1,Math.min(4,A.target.superXY??1));if(this.superXY=a,n*a>8192||t*a>8192)throw new Error("Target size too large");this.target=new e.WebGLRenderTarget(n*a,t*a,{format:e.RGBAFormat,type:e.UnsignedByteType,colorSpace:e.SRGBColorSpace}),s&&(this.back=new e.WebGLRenderTarget(n*a,t*a,{format:e.RGBAFormat,type:e.UnsignedByteType,colorSpace:e.SRGBColorSpace})),this.encodeLinear=!0}this.onTextureUpdated=A.onTextureUpdated,this.sortRadial=A.sortRadial??!0,this.sortDistance=A.sortDistance,this.sortCoorient=A.sortCoorient,this.depthBias=A.depthBias,this.sort360=A.sort360,this.orderingFreelist=new ct({allocate:A=>new Uint32Array(A),valid:(A,n)=>A.length===n}),this.autoUpdate=!1,this.setAutoUpdate(A.autoUpdate??!1)}dispose(){var A;this.setAutoUpdate(!1),this.target&&(this.target.dispose(),this.target=void 0),this.back&&(this.back.dispose(),this.back=void 0),this.display&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.geometry.dispose(),this.display=null),(null==(A=this.pending)?void 0:A.accumulator)&&(this.spark.releaseAccumulator(this.pending.accumulator),this.pending=null)}setAutoUpdate(A){!this.autoUpdate&&A?this.spark.autoViewpoints.push(this):this.autoUpdate&&!A&&(this.spark.autoViewpoints=this.spark.autoViewpoints.filter((A=>A!==this))),this.autoUpdate=A}async prepare({scene:A,camera:n,viewToWorld:t,update:e,forceOrigin:s}){var a;for(t?this.viewToWorld=t:(this.camera=n??this.camera,this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone()));e??1;){const n=s?this.viewToWorld:void 0;if(this.spark.updateInternal({scene:A,originToWorld:n}))break;await new Promise((A=>setTimeout(A,10)))}const i=this.spark.active;i!==(null==(a=this.display)?void 0:a.accumulator)&&(this.spark.active.refCount+=1),await this.sortUpdate({accumulator:i,viewToWorld:this.viewToWorld})}renderTarget({scene:A,camera:n}){var t;const s=this.back??this.target;if(!s)throw new Error("Must initialize SparkViewpoint with target");if(!(n=n??this.camera))throw new Error("Must provide camera");if(n instanceof e.PerspectiveCamera){const A=(new e.PerspectiveCamera).copy(n,!1);A.aspect=s.width/s.height,A.updateProjectionMatrix(),n=A}this.viewToWorld=n.matrixWorld.clone();try{this.spark.renderer.setRenderTarget(s),this.spark.prepareViewpoint(this),this.spark.renderer.render(A,n)}finally{this.spark.prepareViewpoint(this.spark.defaultView),this.spark.renderer.setRenderTarget(null)}s!==this.target&&([this.target,this.back]=[this.back,this.target]),null==(t=this.onTextureUpdated)||t.call(this,s.texture)}async readTarget(){if(!this.target)throw new Error("Must initialize SparkViewpoint with target");const{width:A,height:n}=this.target,t=A*n*4;(!this.superPixels||this.superPixels.length<t)&&(this.superPixels=new Uint8Array(t)),await this.spark.renderer.readRenderTargetPixelsAsync(this.target,0,0,A,n,this.superPixels);const{superXY:e}=this;if(1===e)return this.superPixels;const s=A/e,a=n/e,i=s*a*4;(!this.pixels||this.pixels.length<i)&&(this.pixels=new Uint8Array(i));const{superPixels:r,pixels:o}=this,g=e*e;for(let A=0;A<a;A++){const n=A*s;for(let t=0;t<s;t++){const s=t*e;let a=0,i=0,c=0,I=0;for(let n=0;n<e;n++){const t=(A*e+n)*this.target.width;for(let A=0;A<e;A++){const n=4*(t+s+A);a+=r[n],i+=r[n+1],c+=r[n+2],I+=r[n+3]}}const l=4*(n+t);o[l]=a/g,o[l+1]=i/g,o[l+2]=c/g,o[l+3]=I/g}}return o}async prepareRenderPixels({scene:A,camera:n,viewToWorld:t,update:e,forceOrigin:s}){return await this.prepare({scene:A,camera:n,viewToWorld:t,update:e,forceOrigin:s}),this.renderTarget({scene:A,camera:n}),this.readTarget()}autoPoll({accumulator:A}){var n,t,e,s;this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone());let a=!1,i=!1;if(this.display){if(A){a=!0;const{mappingVersion:n}=this.display.accumulator;A.mappingVersion===n&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=A,i=!0)}}else a=!0;const r=(null==(n=this.sorting)?void 0:n.viewToWorld)??(null==(t=this.display)?void 0:t.viewToWorld);r&&!xt({matrix1:this.viewToWorld,matrix2:r,maxDistance:this.sortDistance??.01,minCoorient:this.sortCoorient??this.sortRadial?.99:.999})&&(a=!0),a&&(A&&(A.refCount+=1),A&&(null==(e=this.pending)?void 0:e.accumulator)&&this.pending.accumulator!==(null==(s=this.display)?void 0:s.accumulator)&&this.spark.releaseAccumulator(this.pending.accumulator),this.pending={accumulator:A,viewToWorld:this.viewToWorld,displayed:i},this.driveSort())}async driveSort(){for(var A;;){if(this.sorting||!this.pending)return;const{viewToWorld:n,displayed:t}=this.pending;let e=this.pending.accumulator??(null==(A=this.display)?void 0:A.accumulator);if(e||(e=this.spark.active,e.refCount+=1),this.pending=null,!e)throw new Error("No accumulator to sort");this.sorting={viewToWorld:n},await this.sortUpdate({accumulator:e,viewToWorld:n,displayed:t}),this.sorting=null}}async sortUpdate({accumulator:n,viewToWorld:t,displayed:e=!1}){if(this.sortingCheck)throw new Error("Only one sort at a time");this.sortingCheck=!0,n=n??this.spark.active;const{numSplats:s,maxSplats:a}=n.splats;let i=0,r=this.orderingFreelist.alloc(a);if(s>0){const{reader:e,doubleSortReader:o,dynoSortRadial:g,dynoOrigin:c,dynoDirection:I,dynoDepthBias:l,dynoSort360:B,dynoSplats:Q}=A.makeSorter(),u=Math.ceil(a/2);this.readback=e.ensureBuffer(u,this.readback);const C=n.toWorld.clone().invert(),E=t.clone().premultiply(C);g.value=!!this.sort360||this.sortRadial,c.value.set(0,0,0).applyMatrix4(E),I.value.set(0,0,-1).applyMatrix4(E).sub(c.value).normalize(),l.value=this.depthBias??1,B.value=this.sort360??!1,Q.packedSplats=n.splats,await e.renderReadback({renderer:this.spark.renderer,reader:o,count:Math.ceil(s/2),readback:this.readback});const h=await Ir((async A=>A.call("sortDoubleSplats",{numSplats:s,readback:this.readback,ordering:r})));this.readback=h.readback,r=h.ordering,i=h.activeSplats}this.updateDisplay({accumulator:n,viewToWorld:t,ordering:r,activeSplats:i,displayed:e}),this.sortingCheck=!1}updateDisplay({accumulator:A,viewToWorld:n,ordering:t,activeSplats:e,displayed:s=!1}){if(this.display){s||A===this.display.accumulator||(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=A),this.display.viewToWorld=n;const a=this.display.geometry.ordering;a.length===t.length?this.display.geometry.update(t,e):(this.display.geometry.dispose(),this.display.geometry=new wr(t,e)),this.orderingFreelist.free(a)}else this.display={accumulator:A,viewToWorld:n,geometry:new wr(t,e)};this.spark.viewpoint===this&&this.spark.prepareViewpoint(this)}static makeSorter(){if(!A.dynos){const n=new ln({value:!0}),t=new mn({value:new e.Vector3}),s=new mn({value:new e.Vector3}),a=new un({value:1}),i=new ln({value:!1}),r=new mr,o=new fi,g=FA({index:"int"},{rgba8:"vec4"},(({index:A})=>{if(!A)throw new Error("No index");const e={sortRadial:n,sortOrigin:t,sortDirection:s,sortDepthBias:a,sort360:i},o=Qe(A,xA("int",2)),g=Mr({gsplat:HA(r,o),...e}),c=Mr({gsplat:HA(r,le(o,xA("int",1))),...e}),I=aa({vectorType:"vec2",x:g,y:c});return{rgba8:ws(ms(I))}}));A.dynos={dynoSortRadial:n,dynoOrigin:t,dynoDirection:s,dynoDepthBias:a,dynoSort360:i,dynoSplats:r,reader:o,doubleSortReader:g}}return A.dynos}};Sr.EMPTY_TEXTURE=new e.Texture,Sr.dynos=null;let br=Sr;const kr=UA("\n  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {\n    if (!isGsplatActive(gsplat.flags)) {\n      return INFINITY;\n    }\n\n    vec3 center = gsplat.center - sortOrigin;\n    float biasedDepth = dot(center, sortDirection) + sortDepthBias;\n    if (!sort360 && (biasedDepth <= 0.0)) {\n      return INFINITY;\n    }\n\n    return sortRadial ? length(center) : biasedDepth;\n  }\n");function Mr({gsplat:A,sortRadial:n,sortOrigin:t,sortDirection:e,sortDepthBias:s,sort360:a}){return NA({inTypes:{gsplat:YA,sortRadial:"bool",sortOrigin:"vec3",sortDirection:"vec3",sortDepthBias:"float",sort360:"bool"},outTypes:{metric:"float"},globals:()=>[VA,kr],inputs:{gsplat:A,sortRadial:n,sortOrigin:t,sortDirection:e,sortDepthBias:s,sort360:a},statements:({inputs:A,outputs:n})=>{const{gsplat:t,sortRadial:e,sortOrigin:s,sortDirection:a,sortDepthBias:i,sort360:r}=A;return GA(`\n        ${n.metric} = computeSort(${t}, ${e}, ${s}, ${a}, ${i}, ${r});\n      `)}}).outputs.metric}class vr{constructor(){this.splats=new fr,this.toWorld=new e.Matrix4,this.mapping=[],this.refCount=0,this.splatsVersion=-1,this.mappingVersion=-1}ensureGenerate(A){this.splats.ensureGenerate(A)&&(this.mapping=[])}generateSplats({renderer:A,modifier:n,generators:t,forceUpdate:e,originToWorld:s}){const a=this.mapping.reduce(((A,n)=>(A.set(n.node,n),A)),new Map);let i=0,r=0;for(const{node:s,generator:o,version:g,base:c,count:I}of t){const t=a.get(s);if((e||o!==(null==t?void 0:t.generator)||g!==(null==t?void 0:t.version)||c!==(null==t?void 0:t.base)||I!==(null==t?void 0:t.count))&&o&&I>0){const t=n.apply(o);try{this.splats.generate({generator:t,base:c,count:I,renderer:A})}catch(A){s.generator=void 0,s.generatorError=A}i+=1}r=Math.max(r,c+I)}return this.splats.numSplats=r,this.toWorld=s,this.mapping=t,0!==i}hasCorrespondence(A){return this.mapping.length===A.mapping.length&&this.mapping.every((({node:n,base:t,count:e},s)=>{const{node:a,base:i,count:r}=A.mapping[s];return n===a&&t===i&&e===r}))}}let Fr=null;let Nr,Rr=!1,Gr=!1;const Ur=e.Scene.prototype.add;e.Scene.prototype.add=function(A){return Rr=Rr||function(A){let n=!1;return A instanceof qi||(A.traverse((A=>{n=n||A instanceof qi})),n)}(A),Gr=Gr||A instanceof _r,Ur.call(this,A),this};const Lr=e.Scene.prototype.onBeforeRender;e.Scene.prototype.onBeforeRender=function(A){if(Rr){if(!Gr){const n=Nr||new _r({renderer:A});this.add(n)}e.Scene.prototype.onBeforeRender=Lr,e.Scene.prototype.add=Ur}};const Tr=class A extends e.Mesh{constructor(n){const t=A.makeUniforms(),s=(Fr||(e.ShaderChunk.splatDefines="const float LN_SCALE_MIN = -12.0;\nconst float LN_SCALE_MAX = 9.0;\nconst float LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254.0; \n\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\nconst uint SPLAT_TEX_HEIGHT_BITS = 11u;\nconst uint SPLAT_TEX_DEPTH_BITS = 11u;\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\n\nconst uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;\nconst uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;\nconst uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;\n\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\nconst uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\n\nconst uint F16_INF = 0x7c00u;\nconst float PI = 3.1415926535897932384626433832795;\n\nconst float INFINITY = 1.0 / 0.0;\nconst float NEG_INFINITY = -INFINITY;\n\nconst float MAX_PIXEL_RADIUS = 512.0;\nconst float MIN_ALPHA = 0.5 * (1.0 / 255.0); \nconst float MAX_STDDEV = sqrt(8.0);\n\nfloat sqr(float x) {\n    return x * x;\n}\n\nfloat pow4(float x) {\n    float x2 = x * x;\n    return x2 * x2;\n}\n\nfloat pow8(float x) {\n    float x4 = pow4(x);\n    return x4 * x4;\n}\n\nvec3 srgbToLinear(vec3 rgb) {\n    return pow(rgb, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 rgb) {\n    return pow(rgb, vec3(1.0 / 2.2));\n}\n\nuint encodeQuatOctXy88R8(vec4 q) {\n    \n    if (q.w < 0.0) {\n        q = -q;\n    }\n    \n    float theta = 2.0 * acos(q.w);\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    \n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;\n    \n    \n    \n    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);\n    vec2 p = vec2(axis.x, axis.y) / sum;\n    \n    if (axis.z < 0.0) {\n        float oldPx = p.x;\n        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\n        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);\n    }\n    \n    float u_f = p.x * 0.5 + 0.5;\n    float v_f = p.y * 0.5 + 0.5;\n    \n    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));\n    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));\n    \n    \n    \n    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));\n    \n    \n    return (angleInt << 16u) | (quantV << 8u) | quantU;\n}\n\nvec4 decodeQuatOctXy88R8(uint encoded) {\n    \n    uint quantU = encoded & uint(0xFFu);               \n    uint quantV = (encoded >> 8u) & uint(0xFFu);         \n    uint angleInt = encoded >> 16u;                      \n\n    \n    float u_f = float(quantU) / 255.0;\n    float v_f = float(quantV) / 255.0;\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);\n\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\n    float t = max(-axis.z, 0.0);\n    axis.x += (axis.x >= 0.0) ? -t : t;\n    axis.y += (axis.y >= 0.0) ? -t : t;\n    axis = normalize(axis);\n    \n    \n    float theta = (float(angleInt) / 255.0) * 3.14159265359;\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    float w = cos(halfTheta);\n    \n    return vec4(axis * s, w);\n}\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {\n    uvec4 uRgba = uvec4(round(clamp(rgba * 255.0, 0.0, 255.0)));\n\n    uint uQuat = encodeQuatOctXy88R8(quaternion);\n    \n    \n    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);\n\n    \n    uvec3 uScales = uvec3(\n        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,\n        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u\n    );\n\n    \n    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\n    uint word1 = packHalf2x16(center.xy);\n    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\n    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);\n    return uvec4(word0, word1, word2, word3);\n}\n\nvoid unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {\n    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\n\n    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);\n    rgba = vec4(uRgba) / 255.0;\n\n    center = vec4(\n        unpackHalf2x16(word1),\n        unpackHalf2x16(word2 & 0xffffu)\n    ).xyz;\n\n    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\n    scales = vec3(\n        (uScales.x == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.x - 1u) * LN_RESCALE),\n        (uScales.y == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.y - 1u) * LN_RESCALE),\n        (uScales.z == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.z - 1u) * LN_RESCALE)\n    );\n\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);\n    quaternion = decodeQuatOctXy88R8(uQuat);\n    \n    \n}\n\nvec3 quatVec(vec4 q, vec3 v) {\n    \n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 quatQuat(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\nmat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {\n    \n    return mat3(\n        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\n        s.x * (2.0 * (q.x * q.y + q.w * q.z)),\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\n        s.y * (2.0 * (q.x * q.y - q.w * q.z)),\n        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\n        s.z * (2.0 * (q.x * q.z + q.w * q.y)),\n        s.z * (2.0 * (q.y * q.z - q.w * q.x)),\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\n    );\n}\n\nvec4 slerp(vec4 q1, vec4 q2, float t) {\n    \n    float cosHalfTheta = dot(q1, q2);\n\n    \n    if (abs(cosHalfTheta) >= 0.999) {\n        return q1;\n    }\n    \n    \n    \n    if (cosHalfTheta < 0.0) {\n        q2 = -q2;\n        cosHalfTheta = -cosHalfTheta;\n    }\n\n    \n    float halfTheta = acos(cosHalfTheta);\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n    \n    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\n\n    \n    return q1 * ratioA + q2 * ratioB;\n}\n\nivec3 splatTexCoord(int index) {\n    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;\n    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;\n    return ivec3(x, y, z);\n}",Fr={splatVertex:"precision highp float;\nprecision highp int;\nprecision highp usampler2DArray;\n\n#include <splatDefines>\n\nattribute uint splatIndex;\n\nout vec4 vRgba;\nout vec2 vSplatUv;\nout vec3 vNdc;\n\nuniform vec2 renderSize;\nuniform uint numSplats;\nuniform vec4 renderToViewQuat;\nuniform vec3 renderToViewPos;\nuniform float maxStdDev;\nuniform float time;\nuniform float deltaTime;\nuniform bool debugFlag;\nuniform bool enable2DGS;\nuniform float blurAmount;\nuniform float preBlurAmount;\nuniform float focalDistance;\nuniform float apertureAngle;\nuniform float clipXY;\nuniform float focalAdjustment;\n\nuniform usampler2DArray packedSplats;\n\nvoid main() {\n    \n    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n\n    if (uint(gl_InstanceID) >= numSplats) {\n        return;\n    }\n    if (splatIndex == 0xffffffffu) {\n        \n        return;\n    }\n\n    ivec3 texCoord = ivec3(\n        splatIndex & SPLAT_TEX_WIDTH_MASK,\n        (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\n        splatIndex >> SPLAT_TEX_LAYER_BITS\n    );\n    uvec4 packed = texelFetch(packedSplats, texCoord, 0);\n\n    vec3 center, scales;\n    vec4 quaternion, rgba;\n    unpackSplat(packed, center, scales, quaternion, rgba);\n\n    if (rgba.a < MIN_ALPHA) {\n        return;\n    }\n    bvec3 zeroScales = equal(scales, vec3(0.0));\n    if (all(zeroScales)) {\n        return;\n    }\n\n    \n    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;\n\n    \n    if (viewCenter.z >= 0.0) {\n        return;\n    }\n\n    \n    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\n\n    \n    if (abs(clipCenter.z) >= clipCenter.w) {\n        return;\n    }\n\n    \n    float clip = clipXY * clipCenter.w;\n    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {\n        return;\n    }\n\n    \n    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);\n\n    if (enable2DGS && any(zeroScales)) {\n        vRgba = rgba;\n        vSplatUv = position.xy * maxStdDev;\n\n        vec3 offset;\n        if (zeroScales.z) {\n            offset = vec3(vSplatUv.xy * scales.xy, 0.0);\n        } else if (zeroScales.y) {\n            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);\n        } else {\n            offset = vec3(0.0, vSplatUv.xy * scales.yz);\n        }\n\n        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);\n        gl_Position = projectionMatrix * vec4(viewPos, 1.0);\n        vNdc = gl_Position.xyz / gl_Position.w;\n        return;\n    }\n\n    \n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n    \n    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);\n    mat3 cov3D = RS * transpose(RS);\n\n    \n    vec2 scaledRenderSize = renderSize * focalAdjustment;\n    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);\n    float invZ = 1.0 / viewCenter.z;\n    vec2 J1 = focal * invZ;\n    vec2 J2 = -(J1 * viewCenter.xy) * invZ;\n    mat3 J = mat3(\n        J1.x, 0.0, J2.x,\n        0.0, J1.y, J2.y,\n        0.0, 0.0, 0.0\n    );\n\n    \n    \n    \n    \n    \n    \n    \n    mat3 cov2D = transpose(J) * cov3D * J;\n    float a = cov2D[0][0];\n    float d = cov2D[1][1];\n    float b = cov2D[0][1];\n\n    \n    a += preBlurAmount;\n    d += preBlurAmount;\n\n    float fullBlurAmount = blurAmount;\n    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {\n        float focusRadius = MAX_PIXEL_RADIUS;\n        if (viewCenter.z < 0.0) {\n            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);\n            float apertureRadius = focal.x * tan(0.5 * apertureAngle);\n            focusRadius = focusBlur * apertureRadius;\n        }\n        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(MAX_PIXEL_RADIUS));\n    }\n\n    \n    float detOrig = a * d - b * b;\n    a += fullBlurAmount;\n    d += fullBlurAmount;\n    float det = a * d - b * b;\n\n    \n    float blurAdjust = sqrt(max(0.0, detOrig / det));\n    rgba.a *= blurAdjust;\n    if (rgba.a < MIN_ALPHA) {\n        return;\n    }\n\n    \n    float eigenAvg = 0.5 * (a + d);\n    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\n    float eigen1 = eigenAvg + eigenDelta;\n    float eigen2 = eigenAvg - eigenDelta;\n\n    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\n    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\n\n    float scale1 = position.x * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen1));\n    float scale2 = position.y * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen2));\n\n    \n    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;\n    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);\n\n    vRgba = rgba;\n    vSplatUv = position.xy * maxStdDev;\n    vNdc = ndc;\n    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);\n}",splatFragment:"precision highp float;\nprecision highp int;\n\n#include <splatDefines>\n\nuniform float near;\nuniform float far;\nuniform bool encodeLinear;\nuniform float maxStdDev;\nuniform bool disableFalloff;\nuniform float falloff;\n\nuniform bool splatTexEnable;\nuniform sampler3D splatTexture;\nuniform mat2 splatTexMul;\nuniform vec2 splatTexAdd;\nuniform float splatTexNear;\nuniform float splatTexFar;\nuniform float splatTexMid;\n\nout vec4 fragColor;\n\nin vec4 vRgba;\nin vec2 vSplatUv;\nin vec3 vNdc;\n\nvoid main() {\n    vec4 rgba = vRgba;\n\n    float z = dot(vSplatUv, vSplatUv);\n    if (!splatTexEnable) {\n        if (z > (maxStdDev * maxStdDev)) {\n            discard;\n        }\n    } else {\n        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;\n        float ndcZ = vNdc.z;\n        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));\n        float clampedFar = max(splatTexFar, splatTexNear);\n        float clampedDepth = clamp(depth, splatTexNear, clampedFar);\n        float logDepth = log2(clampedDepth + 1.0);\n        float logNear = log2(splatTexNear + 1.0);\n        float logFar = log2(clampedFar + 1.0);\n\n        float texZ;\n        if (splatTexMid > 0.0) {\n            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);\n            float logMid = log2(clampedMid + 1.0);\n            texZ = (clampedDepth <= clampedMid) ?\n                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :\n                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);\n        } else {\n            texZ = (logDepth - logNear) / (logFar - logNear);\n        }\n\n        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));\n        rgba *= modulate;\n    }\n\n    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);\n\n    if (rgba.a < MIN_ALPHA) {\n        discard;\n    }\n    if (encodeLinear) {\n        rgba.rgb = srgbToLinear(rgba.rgb);\n    }\n    fragColor = rgba;\n}"}),Fr),a=new e.ShaderMaterial({glslVersion:e.GLSL3,vertexShader:s.splatVertex,fragmentShader:s.splatFragment,uniforms:t,transparent:!0,blending:e.NormalBlending,depthTest:!0,depthWrite:!1,side:e.DoubleSide});super(Yr,a),this.splatTexture=null,this.autoViewpoints=[],this.rotateToAccumulator=new Sn({value:new e.Quaternion}),this.translateToAccumulator=new mn({value:new e.Vector3}),this.lastFrame=-1,this.lastUpdateTime=null,this.defaultCameras=[],this.pendingUpdate=null,this.envViewpoint=null,this.frustumCulled=!1,this.renderer=n.renderer,this.material=a,this.uniforms=t;const i=FA({gsplat:YA},{gsplat:YA},(({gsplat:A})=>{if(!A)throw new Error("gsplat not defined");return{gsplat:A=OA(A,{rotate:this.rotateToAccumulator,translate:this.translateToAccumulator})}}));this.modifier=new _i(i),this.autoUpdate=n.autoUpdate??!0,this.preUpdate=n.preUpdate??!1,this.originDistance=n.originDistance??1,this.maxStdDev=n.maxStdDev??Math.sqrt(8),this.enable2DGS=n.enable2DGS??!1,this.preBlurAmount=n.preBlurAmount??0,this.blurAmount=n.blurAmount??.3,this.focalDistance=n.focalDistance??0,this.apertureAngle=n.apertureAngle??0,this.falloff=n.falloff??1,this.clipXY=n.clipXY??1.4,this.focalAdjustment=n.focalAdjustment??1,this.active=new vr,this.accumulatorCount=1,this.freeAccumulators=[];for(let A=0;A<1;++A)this.freeAccumulators.push(new vr),this.accumulatorCount+=1;this.defaultView=new br({...n.view,autoUpdate:!0,spark:this}),this.viewpoint=this.defaultView,this.prepareViewpoint(this.viewpoint),this.clock=n.clock?dt(n.clock):new e.Clock,Nr=this}static makeUniforms(){return{renderSize:{value:new e.Vector2},near:{value:.1},far:{value:1e3},numSplats:{value:0},renderToViewQuat:{value:new e.Quaternion},renderToViewPos:{value:new e.Vector3},maxStdDev:{value:1},enable2DGS:{value:!1},preBlurAmount:{value:0},blurAmount:{value:.3},focalDistance:{value:0},apertureAngle:{value:0},falloff:{value:1},clipXY:{value:1.4},focalAdjustment:{value:1},splatTexEnable:{value:!1},splatTexture:{type:"t",value:A.EMPTY_SPLAT_TEXTURE},splatTexMul:{value:new e.Matrix2},splatTexAdd:{value:new e.Vector2},splatTexNear:{value:.1},splatTexFar:{value:1e3},splatTexMid:{value:0},packedSplats:{type:"t",value:fr.getEmpty()},time:{value:0},deltaTime:{value:0},encodeLinear:{value:!1},debugFlag:{value:!1}}}canAllocAccumulator(){return this.freeAccumulators.length>0||this.accumulatorCount<5}maybeAllocAccumulator(){let A=this.freeAccumulators.pop();if(void 0===A){if(this.accumulatorCount>=5)return null;A=new vr,this.accumulatorCount+=1}return A.refCount=1,A}releaseAccumulator(A){A.refCount-=1,0===A.refCount&&this.freeAccumulators.push(A)}newViewpoint(A){return new br({...A,spark:this})}onBeforeRender(n,t,s){var a,i;const r=this.time??this.clock.getElapsedTime(),o=r-(this.viewpoint.lastTime??r);this.viewpoint.lastTime=r;const g=n.info.render.frame,c=g!==this.lastFrame;this.lastFrame=g;const I=this.viewpoint;if(I===this.defaultView){if(c)if(n.xr.isPresenting){const A=n.xr.getCamera().cameras;this.defaultCameras=A.map((A=>A.matrixWorld)),this.defaultView.viewToWorld=function(A){if(0===A.length)return null;const n=new e.Vector3,t=new e.Quaternion,s=new e.Vector3,a=[],i=[];for(const e of A)e.decompose(n,t,s),a.push(n),i.push(t);return(new e.Matrix4).compose(ft(a),mt(i),new e.Vector3(1,1,1))}(this.defaultCameras)??new e.Matrix4}else this.defaultView.viewToWorld=s.matrixWorld.clone(),this.defaultCameras=[this.defaultView.viewToWorld];this.autoUpdate&&this.update({scene:t,viewToWorld:this.defaultView.viewToWorld})}if(c&&(this.uniforms.time.value=r,this.uniforms.deltaTime.value=o,this.uniforms.debugFlag.value=performance.now()/1e3%2<1),I.target)this.uniforms.renderSize.value.set(I.target.width,I.target.height);else{const A=n.getDrawingBufferSize(this.uniforms.renderSize.value);if(1===A.x&&1===A.y){const t=null==(a=n.xr.getSession())?void 0:a.renderState.baseLayer;t&&(A.x=t.framebufferWidth,A.y=t.framebufferHeight)}}const l=s;if(this.uniforms.near.value=l.near,this.uniforms.far.value=l.far,this.uniforms.encodeLinear.value=I.encodeLinear,this.uniforms.maxStdDev.value=this.maxStdDev,this.uniforms.enable2DGS.value=this.enable2DGS,this.uniforms.preBlurAmount.value=this.preBlurAmount,this.uniforms.blurAmount.value=this.blurAmount,this.uniforms.focalDistance.value=this.focalDistance,this.uniforms.apertureAngle.value=this.apertureAngle,this.uniforms.falloff.value=this.falloff,this.uniforms.clipXY.value=this.clipXY,this.uniforms.focalAdjustment.value=this.focalAdjustment,this.splatTexture){const{enable:n,texture:t,multiply:e,add:s,near:a,far:i,mid:r}=this.splatTexture;n&&t?(this.uniforms.splatTexEnable.value=!0,this.uniforms.splatTexture.value=t,e?this.uniforms.splatTexMul.value.fromArray(e.elements):this.uniforms.splatTexMul.value.set(.5/this.maxStdDev,0,0,.5/this.maxStdDev),this.uniforms.splatTexAdd.value.set((null==s?void 0:s.x)??.5,(null==s?void 0:s.y)??.5),this.uniforms.splatTexNear.value=a??this.uniforms.near.value,this.uniforms.splatTexFar.value=i??this.uniforms.far.value,this.uniforms.splatTexMid.value=r??0):(this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=A.EMPTY_SPLAT_TEXTURE)}else this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=A.EMPTY_SPLAT_TEXTURE;const B=(null==(i=I.display)?void 0:i.accumulator.toWorld)??new e.Matrix4,Q=s.matrixWorld.clone().invert();B.clone().premultiply(Q).decompose(this.uniforms.renderToViewPos.value,this.uniforms.renderToViewQuat.value,new e.Vector3)}prepareViewpoint(A){if(this.viewpoint=A??this.viewpoint,this.viewpoint.display){const{accumulator:A,geometry:n}=this.viewpoint.display;this.uniforms.numSplats.value=A.splats.numSplats,this.uniforms.packedSplats.value=A.splats.getTexture(),this.geometry=n}else this.uniforms.numSplats.value=0,this.uniforms.packedSplats.value=fr.getEmpty(),this.geometry=Yr}update({scene:A,viewToWorld:n}){const t=this.matrixWorld.clone();this.preUpdate?this.updateInternal({scene:A,originToWorld:t,viewToWorld:n}):(this.pendingUpdate={scene:A,originToWorld:t},setTimeout((()=>{if(this.pendingUpdate){const{scene:A,originToWorld:t}=this.pendingUpdate;this.pendingUpdate=null,this.updateInternal({scene:A,originToWorld:t,viewToWorld:n})}}),1))}updateInternal({scene:A,originToWorld:n,viewToWorld:t}){var s;if(!this.canAllocAccumulator())return!1;n||(n=this.active.toWorld),t=t??n.clone();const a=this.time??this.clock.getElapsedTime(),i=a-(this.lastUpdateTime??a);this.lastUpdateTime=a;const r=this.active.mapping.reduce(((A,n)=>(A.set(n.node,n),A)),new Map),{generators:o,visibleGenerators:g,globalEdits:c}=this.compileScene(A);for(const A of o)null==(s=A.frameUpdate)||s.call(A,{object:A,time:a,deltaTime:i,viewToWorld:t,globalEdits:c});const I=new Set(g.map((A=>A.uuid)));for(const A of o){const n=r.get(A),t=A.generator&&I.has(A.uuid)?A.numSplats:0;A.generator===(null==n?void 0:n.generator)&&t===(null==n?void 0:n.count)||A.updateVersion()}const l=!xt({matrix1:n,matrix2:this.active.toWorld,maxDistance:this.originDistance})||o.length!==r.size||o.some((A=>{var n;return A.version!==(null==(n=r.get(A))?void 0:n.version)}));let B=null;if(l){if(B=this.maybeAllocAccumulator(),!B)throw new Error("Unreachable");const A=!xt({matrix1:n,matrix2:this.active.toWorld,maxDistance:1e-5,minCoorient:.99999}),t=g.map(((A,n)=>{const t=r.get(A);return t?[A.version-t.version,t.base,A]:[Number.POSITIVE_INFINITY,A.version,A]})).sort(((A,n)=>A[0]!==n[0]?A[0]-n[0]:A[1]-n[1])).map((([A,n,t])=>t)),s=t.map((A=>A.numSplats)),{maxSplats:a,mapping:i}=B.splats.generateMapping(s),o=t.map(((A,n)=>{const{base:t,count:e}=i[n];return{node:A,generator:A.generator,version:A.version,base:t,count:e}}));n.clone().invert().decompose(this.translateToAccumulator.value,this.rotateToAccumulator.value,new e.Vector3),B.ensureGenerate(a),B.generateSplats({renderer:this.renderer,modifier:this.modifier,generators:o,forceUpdate:A,originToWorld:n}),B.splatsVersion=this.active.splatsVersion+1;const c=B.hasCorrespondence(this.active);B.mappingVersion=this.active.mappingVersion+(c?0:1),this.releaseAccumulator(this.active),this.active=B,this.prepareViewpoint()}return setTimeout((()=>{for(const A of this.autoViewpoints)A.autoPoll({accumulator:B??void 0})}),1),!0}compileScene(A){const n=[];A.traverse((A=>{A instanceof Ji&&n.push(A)}));const t=[];A.traverseVisible((A=>{A instanceof Ji&&t.push(A)}));const e=new Set;return A.traverseVisible((A=>{if(A instanceof Ni){let n=A.parent;for(;null!=n&&!(n instanceof qi);)n=n.parent;null==n&&e.add(A)}})),{generators:n,visibleGenerators:t,globalEdits:Array.from(e)}}async renderEnvMap({renderer:n,scene:t,worldCenter:s,size:a=256,near:i=.1,far:r=1e3,hideObjects:o=[],update:g=!1}){var c,I;if(this.envViewpoint||(this.envViewpoint=this.newViewpoint({sort360:!0})),!A.cubeRender||A.cubeRender.target.width!==a||A.cubeRender.near!==i||A.cubeRender.far!==r){A.cubeRender&&A.cubeRender.target.dispose();const n=new e.WebGLCubeRenderTarget(a,{format:e.RGBAFormat,generateMipmaps:!0,minFilter:e.LinearMipMapLinearFilter}),t=new e.CubeCamera(i,r,n);A.cubeRender={target:n,camera:t,near:i,far:r}}A.pmrem||(A.pmrem=new e.PMREMGenerator(n??this.renderer));const l=(new e.Matrix4).setPosition(s);await(null==(c=this.envViewpoint)?void 0:c.prepare({scene:t,viewToWorld:l,update:g}));const{target:B,camera:Q}=A.cubeRender;Q.position.copy(s);const u=new Map;for(const A of o)u.set(A,A.visible),A.visible=!1;this.prepareViewpoint(this.envViewpoint),Q.update(n??this.renderer,t),this.prepareViewpoint(this.defaultView);for(const[A,n]of u.entries())A.visible=n;return null==(I=A.pmrem)?void 0:I.fromCubemap(B.texture).texture}recurseSetEnvMap(A,n){A.traverse((A=>{if(A instanceof e.Mesh)if(Array.isArray(A.material))for(const t of A.material)t instanceof e.MeshStandardMaterial&&(t.envMap=n);else A.material instanceof e.MeshStandardMaterial&&(A.material.envMap=n)}))}getRgba({generator:A,rgba:n}){const t=this.active.mapping.find((({node:n})=>n===A));if(!t)throw new Error("Generator not found");return(n=n??new wi).fromPackedSplats({packedSplats:this.active.splats,base:t.base,count:t.count,renderer:this.renderer}),n}async readRgba({generator:A,rgba:n}){return(n=this.getRgba({generator:A,rgba:n})).read()}};Tr.cubeRender=null,Tr.pmrem=null,Tr.EMPTY_SPLAT_TEXTURE=new e.Data3DTexture;let _r=Tr;const Yr=new wr(new Uint32Array(1),0);function Jr(A,n,t){const e=Math.floor(A.length/32);if(32*e!==A.length)throw new Error("Invalid .splat file size");const s=new Float32Array(A.buffer);for(let n=0;n<e;++n){const e=32*n,a=8*n,i=s[a+0],r=s[a+1],o=s[a+2],g=s[a+3],c=s[a+4],I=s[a+5],l=A[e+24]/255,B=A[e+25]/255,Q=A[e+26]/255,u=A[e+27]/255,C=(A[e+28]-128)/128;t(n,i,r,o,g,c,I,(A[e+29]-128)/128,(A[e+30]-128)/128,(A[e+31]-128)/128,C,u,l,B,Q)}}FA({packedSplats:JA,index:"int"},{gsplat:YA},(({packedSplats:A,index:n})=>{if(!A||!n)throw new Error("Invalid input");return{gsplat:HA(A,n)}}));const Hr={0:{bytesPerCenter:12,bytesPerScale:12,bytesPerRotation:16,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:4,scaleOffsetBytes:12,rotationOffsetBytes:24,colorOffsetBytes:40,sphericalHarmonicsOffsetBytes:44,scaleRange:1},1:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:2,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767},2:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:1,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767}},qr={0:0,1:9,2:24,3:45};function zr(A,n,t,e){var s;const a=4096,i=1024;let r=0;const o=new DataView(A.buffer,r,a);r+=a;const g=o.getUint8(0),c=o.getUint8(1);if(0!==g||c<1)throw new Error(`Unsupported .ksplat version: ${g}.${c}`);const I=o.getUint32(4,!0);o.getUint32(16,!0);const l=o.getUint16(20,!0);if(l<0||l>2)throw new Error(`Invalid .ksplat compression level: ${l}`);const B=o.getFloat32(36,!0)||-1.5,Q=o.getFloat32(40,!0)||1.5;let u=a+I*i;for(let n=0;n<I;++n){let n=function(A,n){if(0===l)return O.getFloat32(A+R+4*n,!0);if(1===l)return st(O.getUint16(A+R+2*n,!0));const t=O.getUint8(A+R+n)/255;return B+t*(Q-B)};const a=new DataView(A.buffer,r,i);r+=i;const o=a.getUint32(0,!0),g=a.getUint32(4,!0),c=a.getUint32(8,!0),I=a.getUint32(12,!0),C=a.getFloat32(16,!0),E=a.getUint16(20,!0),h=(a.getUint32(24,!0)||(null==(s=Hr[l])?void 0:s.scaleRange))??1,p=a.getUint32(32,!0),d=p*c,y=a.getUint32(36,!0),f=4*y,m=E*I+f,w=a.getUint16(40,!0),D=qr[w],{bytesPerCenter:x,bytesPerScale:S,bytesPerRotation:b,bytesPerColor:k,bytesPerSphericalHarmonicsComponent:M,scaleOffsetBytes:v,rotationOffsetBytes:F,colorOffsetBytes:N,sphericalHarmonicsOffsetBytes:R}=Hr[l],G=x+S+b+k+D*M,U=G*g,L=U+m,T=[0,3,6,1,4,7,2,5,8],_=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],Y=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],J=w>=1?new Float32Array(9):void 0,H=w>=2?new Float32Array(15):void 0,q=w>=3?new Float32Array(21):void 0,z=C/2/h,K=u+f,P=u+m,O=new DataView(A.buffer,P,U),V=new Float32Array(A.buffer,K,3*I),j=new Uint32Array(A.buffer,u,y);let Z=p,$=d;for(let A=0;A<o;++A){const s=A*G;let a;if(A<d)a=Math.floor(A/c);else{const n=j[Z-p];A>=$+n&&(Z+=1,$+=n),a=Z}const i=0===l?O.getFloat32(s+0,!0):(O.getUint16(s+0,!0)-h)*z+V[3*a+0],r=0===l?O.getFloat32(s+4,!0):(O.getUint16(s+2,!0)-h)*z+V[3*a+1],o=0===l?O.getFloat32(s+8,!0):(O.getUint16(s+4,!0)-h)*z+V[3*a+2],g=0===l?O.getFloat32(s+v+0,!0):st(O.getUint16(s+v+0,!0)),I=0===l?O.getFloat32(s+v+4,!0):st(O.getUint16(s+v+2,!0)),B=0===l?O.getFloat32(s+v+8,!0):st(O.getUint16(s+v+4,!0)),Q=0===l?O.getFloat32(s+F+0,!0):st(O.getUint16(s+F+0,!0)),u=0===l?O.getFloat32(s+F+4,!0):st(O.getUint16(s+F+2,!0)),C=0===l?O.getFloat32(s+F+8,!0):st(O.getUint16(s+F+4,!0)),E=0===l?O.getFloat32(s+F+12,!0):st(O.getUint16(s+F+6,!0)),y=O.getUint8(s+N+0)/255,f=O.getUint8(s+N+1)/255,m=O.getUint8(s+N+2)/255;if(t(A,i,r,o,g,I,B,u,C,E,Q,O.getUint8(s+N+3)/255,y,f,m),w>=1&&J){for(const[A,t]of T.entries())J[A]=n(s,t);if(H)for(const[A,t]of _.entries())H[A]=n(s,t);if(q)for(const[A,t]of Y.entries())q[A]=n(s,t);null==e||e(A,J,H,q)}}u+=L}}class Kr{constructor({fileBytes:A}){this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A,this.reader=new vt({fileBytes:this.fileBytes});const n=new DataView(this.reader.read(16).buffer);if(1347635022!==n.getUint32(0,!0))throw new Error("Invalid SPZ file");if(this.version=n.getUint32(4,!0),this.version<1||this.version>2)throw new Error(`Unsupported SPZ version: ${this.version}`);this.numSplats=n.getUint32(8,!0),this.shDegree=n.getUint8(12),this.fractionalBits=n.getUint8(13),this.flags=n.getUint8(14),this.flagAntiAlias=!!(1&this.flags),this.reserved=n.getUint8(15),this.parsed=!1}parseSplats(A,n,t,e,s,a){if(this.parsed)throw new Error("SPZ file already parsed");if(this.parsed=!0,1===this.version){const n=this.reader.read(3*this.numSplats*2),t=new Uint16Array(n.buffer);for(let n=0;n<this.numSplats;n++){const e=3*n,s=st(t[e]),a=st(t[e+1]),i=st(t[e+2]);null==A||A(n,s,a,i)}}else{if(2!==this.version)throw new Error("Unreachable");{const n=1<<this.fractionalBits,t=this.reader.read(3*this.numSplats*3);for(let e=0;e<this.numSplats;e++){const s=9*e,a=((t[s+2]<<24|t[s+1]<<16|t[s]<<8)>>8)/n,i=((t[s+5]<<24|t[s+4]<<16|t[s+3]<<8)>>8)/n,r=((t[s+8]<<24|t[s+7]<<16|t[s+6]<<8)>>8)/n;null==A||A(e,a,i,r)}}}{const A=this.reader.read(this.numSplats);for(let t=0;t<this.numSplats;t++)null==n||n(t,A[t]/255)}{const A=this.reader.read(3*this.numSplats),n=Or/.15;for(let e=0;e<this.numSplats;e++){const s=3*e,a=(A[s]/255-.5)*n+.5,i=(A[s+1]/255-.5)*n+.5,r=(A[s+2]/255-.5)*n+.5;null==t||t(e,a,i,r)}}{const A=this.reader.read(3*this.numSplats);for(let n=0;n<this.numSplats;n++){const t=3*n,s=Math.exp(A[t]/16-10),a=Math.exp(A[t+1]/16-10),i=Math.exp(A[t+2]/16-10);null==e||e(n,s,a,i)}}{const A=this.reader.read(3*this.numSplats);for(let n=0;n<this.numSplats;n++){const t=3*n,e=A[t]/127.5-1,a=A[t+1]/127.5-1,i=A[t+2]/127.5-1,r=Math.sqrt(Math.max(0,1-e*e-a*a-i*i));null==s||s(n,e,a,i,r)}}if(a&&this.shDegree>=1){const A=new Float32Array(9),n=this.shDegree>=2?new Float32Array(15):void 0,t=this.shDegree>=3?new Float32Array(21):void 0,e=this.reader.read(this.numSplats*Pr[this.shDegree]*3);let s=0;for(let i=0;i<this.numSplats;i++){for(let n=0;n<9;++n)A[n]=(e[s+n]-128)/128;if(s+=9,n){for(let A=0;A<15;++A)n[A]=(e[s+A]-128)/128;s+=15}if(t){for(let A=0;A<21;++A)t[A]=(e[s+A]-128)/128;s+=21}null==a||a(i,A,n,t)}}}}const Pr={1:3,2:8,3:15},Or=.28209479177387814;class Vr{constructor({numSplats:A,shDegree:n,fractionalBits:t=12,flagAntiAlias:e=!0}){this.clippedCount=0;const s=16+A*(19+(n>=1?9:0)+(n>=2?15:0)+(n>=3?21:0));this.buffer=new ArrayBuffer(s),this.view=new DataView(this.buffer),this.view.setUint32(0,1347635022,!0),this.view.setUint32(4,2,!0),this.view.setUint32(8,A,!0),this.view.setUint8(12,n),this.view.setUint8(13,t),this.view.setUint8(14,e?1:0),this.view.setUint8(15,0),this.numSplats=A,this.shDegree=n,this.fractionalBits=t,this.fraction=1<<t,this.flagAntiAlias=e}setCenter(A,n,t,e){const s=Math.round(n*this.fraction),a=Math.max(-8388607,Math.min(8388607,s)),i=Math.round(t*this.fraction),r=Math.max(-8388607,Math.min(8388607,i)),o=Math.round(e*this.fraction),g=Math.max(-8388607,Math.min(8388607,o));(s!==a||i!==r||o!==g)&&(this.clippedCount+=1);const c=16+9*A;this.view.setUint8(c,255&a),this.view.setUint8(c+1,a>>8&255),this.view.setUint8(c+2,a>>16&255),this.view.setUint8(c+3,255&r),this.view.setUint8(c+4,r>>8&255),this.view.setUint8(c+5,r>>16&255),this.view.setUint8(c+6,255&g),this.view.setUint8(c+7,g>>8&255),this.view.setUint8(c+8,g>>16&255)}setAlpha(A,n){const t=16+9*this.numSplats+A;this.view.setUint8(t,Math.max(0,Math.min(255,Math.round(255*n))))}static scaleRgb(A){const n=255*((A-.5)/(Or/.15)+.5);return Math.max(0,Math.min(255,Math.round(n)))}setRgb(A,n,t,e){const s=16+10*this.numSplats+3*A;this.view.setUint8(s,Vr.scaleRgb(n)),this.view.setUint8(s+1,Vr.scaleRgb(t)),this.view.setUint8(s+2,Vr.scaleRgb(e))}setScale(A,n,t,e){const s=16+13*this.numSplats+3*A;this.view.setUint8(s,Math.max(0,Math.min(255,Math.round(16*(Math.log(n)+10))))),this.view.setUint8(s+1,Math.max(0,Math.min(255,Math.round(16*(Math.log(t)+10))))),this.view.setUint8(s+2,Math.max(0,Math.min(255,Math.round(16*(Math.log(e)+10)))))}setQuat(A,n,t,e,s){const a=16+16*this.numSplats+3*A,i=s<0;this.view.setUint8(a,Math.max(0,Math.min(255,Math.round(127.5*((i?-n:n)+1))))),this.view.setUint8(a+1,Math.max(0,Math.min(255,Math.round(127.5*((i?-t:t)+1))))),this.view.setUint8(a+2,Math.max(0,Math.min(255,Math.round(127.5*((i?-e:e)+1)))))}static quantizeSh(A,n){const t=Math.round(128*A)+128,e=1<<8-n,s=Math.floor((t+e/2)/e)*e;return Math.max(0,Math.min(255,s))}setSh(A,n,t,e){const s=Pr[this.shDegree]||0,a=16+19*this.numSplats+A*s*3;for(let A=0;A<9;++A)this.view.setUint8(a+A,Vr.quantizeSh(n[A],5));if(t){const A=a+9;for(let n=0;n<15;++n)this.view.setUint8(A+n,Vr.quantizeSh(t[n],4));if(e){const n=A+15;for(let A=0;A<21;++A)this.view.setUint8(n+A,Vr.quantizeSh(e[A],4))}}}async finalize(){const A=new Uint8Array(this.buffer),n=new ReadableStream({async start(n){n.enqueue(A),n.close()}}).pipeThrough(new CompressionStream("gzip")),t=new Response(n),e=await t.arrayBuffer();return console.log("Compressed",A.length,"bytes to",e.byteLength,"bytes"),new Uint8Array(e)}}async function jr(A){var n,t,s;const a=new dr,{inputs:i,clipXyz:r,maxSh:o,fractionalBits:g=12,opacityThreshold:c}=A;for(const A of i){let i=function(A){return A.multiplyScalar(B),A.applyQuaternion(Q),A.add(u),A},o=function(A){return A.multiplyScalar(B),A},g=function(A){return A.premultiply(Q),A},I=function(A){return!C||C.containsPoint(A)},l=function(A){return void 0===c||A>=c};const B=(null==(n=A.transform)?void 0:n.scale)??1,Q=(new e.Quaternion).fromArray((null==(t=A.transform)?void 0:t.quaternion)??[0,0,0,1]),u=(new e.Vector3).fromArray((null==(s=A.transform)?void 0:s.translate)??[0,0,0]),C=r?new e.Box3((new e.Vector3).fromArray(r.min),(new e.Vector3).fromArray(r.max)):void 0;let E=A.fileType;switch(E||(E=ur(A.fileBytes),!E&&A.pathOrUrl&&(E=Cr(A.pathOrUrl))),E){case Qr.PLY:{const n=new Vi({fileBytes:A.fileBytes});await n.parseHeader();let t=null;n.parseSplats(((A,n,s,r,c,B,Q,u,C,E,h,p,d,y,f)=>{const m=i(new e.Vector3(n,s,r));if(I(m)&&l(p)){t=a.pushSplat(),a.setCenter(t,m.x,m.y,m.z);const A=o(new e.Vector3(c,B,Q));a.setScale(t,A.x,A.y,A.z);const n=g(new e.Quaternion(u,C,E,h));a.setQuaternion(t,n.x,n.y,n.z,n.w),a.setOpacity(t,p),a.setColor(t,d,y,f)}else t=null}),((A,n,e,s)=>{n&&null!==t&&a.setSh1(t,n),e&&null!==t&&a.setSh2(t,e),s&&null!==t&&a.setSh3(t,s)}));break}case Qr.SPZ:{const n=new Kr({fileBytes:A.fileBytes}),t=new Int32Array(n.numSplats);t.fill(-1);const s=new Float32Array(3*n.numSplats),r=new e.Vector3;n.parseSplats(((A,n,t,a)=>{const r=i(new e.Vector3(n,t,a));s[3*A]=r.x,s[3*A+1]=r.y,s[3*A+2]=r.z}),((A,n)=>{r.fromArray(s,3*A),I(r)&&l(n)&&(t[A]=a.pushSplat(),a.setCenter(t[A],r.x,r.y,r.z),a.setOpacity(t[A],n))}),((A,n,e,s)=>{t[A]>=0&&a.setColor(t[A],n,e,s)}),((A,n,s,i)=>{if(t[A]>=0){const r=o(new e.Vector3(n,s,i));a.setScale(t[A],r.x,r.y,r.z)}}),((A,n,s,i,r)=>{if(t[A]>=0){const o=g(new e.Quaternion(n,s,i,r));a.setQuaternion(t[A],o.x,o.y,o.z,o.w)}}),((A,n,e,s)=>{t[A]>=0&&(a.setSh1(t[A],n),e&&a.setSh2(t[A],e),s&&a.setSh3(t[A],s))}));break}case Qr.SPLAT:Jr(A.fileBytes,0,((A,n,t,s,r,c,B,Q,u,C,E,h,p,d,y)=>{const f=i(new e.Vector3(n,t,s));if(I(f)&&l(h)){const A=a.pushSplat();a.setCenter(A,f.x,f.y,f.z);const n=o(new e.Vector3(r,c,B));a.setScale(A,n.x,n.y,n.z);const t=g(new e.Quaternion(Q,u,C,E));a.setQuaternion(A,t.x,t.y,t.z,t.w),a.setOpacity(A,h),a.setColor(A,p,d,y)}}));break;case Qr.KSPLAT:{let n=null;zr(A.fileBytes,0,((A,t,s,r,c,B,Q,u,C,E,h,p,d,y,f)=>{const m=i(new e.Vector3(t,s,r));if(I(m)&&l(p)){n=a.pushSplat(),a.setCenter(n,m.x,m.y,m.z);const A=o(new e.Vector3(c,B,Q));a.setScale(n,A.x,A.y,A.z);const t=g(new e.Quaternion(u,C,E,h));a.setQuaternion(n,t.x,t.y,t.z,t.w),a.setOpacity(n,p),a.setColor(n,d,y,f)}else n=null}),((A,t,e,s)=>{null!==n&&(a.setSh1(n,t),e&&a.setSh2(n,e),s&&a.setSh3(n,s))}));break}default:throw new Error(`transcodeSpz not implemented for ${E}`)}}const I=Math.min(o??3,a.sh3?3:a.sh2?2:a.sh1?1:0),l=new Vr({numSplats:a.numSplats,shDegree:I,fractionalBits:g,flagAntiAlias:!0});for(let A=0;A<a.numSplats;++A){const n=3*A,t=4*A;l.setCenter(A,a.centers[n],a.centers[n+1],a.centers[n+2]),l.setScale(A,a.scales[n],a.scales[n+1],a.scales[n+2]),l.setQuat(A,a.quaternions[t],a.quaternions[t+1],a.quaternions[t+2],a.quaternions[t+3]),l.setAlpha(A,a.opacities[A]),l.setRgb(A,a.colors[n],a.colors[n+1],a.colors[n+2]),a.sh1&&I>=1&&l.setSh(A,a.sh1.slice(9*A,9*(A+1)),I>=2&&a.sh2?a.sh2.slice(15*A,15*(A+1)):void 0,I>=3&&a.sh3?a.sh3.slice(21*A,21*(A+1)):void 0)}return{fileBytes:await l.finalize(),clippedCount:l.clippedCount}}class Zr{constructor(A){this.mesh=A.mesh,this.numSplats=A.numSplats??this.mesh.numSplats;const{width:n,height:t,depth:s,maxSplats:a}=Qt(this.numSplats);this.skinData=new Uint16Array(4*a),this.skinTexture=new e.DataArrayTexture(this.skinData,n,t,s),this.skinTexture.format=e.RGBAIntegerFormat,this.skinTexture.type=e.UnsignedShortType,this.skinTexture.internalFormat="RGBA16UI",this.skinTexture.needsUpdate=!0,this.numBones=A.numBones??256,this.boneData=new Float32Array(16*this.numBones),this.boneTexture=new e.DataTexture(this.boneData,4,this.numBones,e.RGBAFormat,e.FloatType),this.boneTexture.internalFormat="RGBA32F",this.boneTexture.needsUpdate=!0,this.uniform=new In({key:"skinning",type:$r,globals:()=>[Wr],value:{numSplats:this.numSplats,numBones:this.numBones,skinTexture:this.skinTexture,boneTexture:this.boneTexture}})}modify(A){return function(A,n){const t=new MA({inTypes:{gsplat:YA,skinning:$r},outTypes:{gsplat:YA},globals:()=>[Wr,Xr],inputs:{gsplat:A,skinning:n},statements:({inputs:A,outputs:n})=>{const{skinning:t}=A,{gsplat:e}=n;return GA(`\n        ${e} = ${A.gsplat};\n        if (isGsplatActive(${e}.flags)) {\n          applyGsplatSkinning(\n            ${t}.numSplats, ${t}.numBones,\n            ${t}.skinTexture, ${t}.boneTexture,\n            ${e}.index, ${e}.center, ${e}.quaternion\n          );\n        }\n      `)}});return t.outputs.gsplat}(A,this.uniform)}setRestQuatPos(A,n,t){const e=16*A;this.boneData[e+0]=n.x,this.boneData[e+1]=n.y,this.boneData[e+2]=n.z,this.boneData[e+3]=n.w,this.boneData[e+4]=t.x,this.boneData[e+5]=t.y,this.boneData[e+6]=t.z,this.boneData[e+7]=0,this.boneData[e+8]=0,this.boneData[e+9]=0,this.boneData[e+10]=0,this.boneData[e+11]=1,this.boneData[e+12]=0,this.boneData[e+13]=0,this.boneData[e+14]=0,this.boneData[e+15]=0}setBoneQuatPos(A,n,t){const s=16*A,a=new e.Quaternion(this.boneData[s+0],this.boneData[s+1],this.boneData[s+2],this.boneData[s+3]),i=new e.Vector3(this.boneData[s+4],this.boneData[s+5],this.boneData[s+6]),r=a.clone().invert(),o=t.clone().sub(i);o.applyQuaternion(r),r.multiply(n);const g=new e.Quaternion(o.x,o.y,o.z,0).multiply(a);this.boneData[s+8]=r.x,this.boneData[s+9]=r.y,this.boneData[s+10]=r.z,this.boneData[s+11]=r.w,this.boneData[s+12]=.5*g.x,this.boneData[s+13]=.5*g.y,this.boneData[s+14]=.5*g.z,this.boneData[s+15]=.5*g.w}setSplatBones(A,n,t){const e=4*A;this.skinData[e+0]=Math.min(255,Math.max(0,Math.round(255*t.x)))+(n.x<<8),this.skinData[e+1]=Math.min(255,Math.max(0,Math.round(255*t.y)))+(n.y<<8),this.skinData[e+2]=Math.min(255,Math.max(0,Math.round(255*t.z)))+(n.z<<8),this.skinData[e+3]=Math.min(255,Math.max(0,Math.round(255*t.w)))+(n.w<<8)}updateBones(){this.boneTexture.needsUpdate=!0,this.mesh.needsUpdate=!0}}const $r={type:"GsplatSkinning"},Wr=UA("\n  struct GsplatSkinning {\n    int numSplats;\n    int numBones;\n    usampler2DArray skinTexture;\n    sampler2D boneTexture;\n  };\n"),Xr=UA("\n  void applyGsplatSkinning(\n    int numSplats, int numBones,\n    usampler2DArray skinTexture, sampler2D boneTexture,\n    int splatIndex, inout vec3 center, inout vec4 quaternion\n  ) {\n    if ((splatIndex < 0) || (splatIndex >= numSplats)) {\n      return;\n    }\n\n    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);\n\n    float weights[4];\n    weights[0] = float(skinData.x & 0xffu) / 255.0;\n    weights[1] = float(skinData.y & 0xffu) / 255.0;\n    weights[2] = float(skinData.z & 0xffu) / 255.0;\n    weights[3] = float(skinData.w & 0xffu) / 255.0;\n\n    uint boneIndices[4];\n    boneIndices[0] = (skinData.x >> 8u) & 0xffu;\n    boneIndices[1] = (skinData.y >> 8u) & 0xffu;\n    boneIndices[2] = (skinData.z >> 8u) & 0xffu;\n    boneIndices[3] = (skinData.w >> 8u) & 0xffu;\n\n    vec4 quat = vec4(0.0);\n    vec4 dual = vec4(0.0);\n    for (int i = 0; i < 4; i++) {\n      if (weights[i] > 0.0) {\n        int boneIndex = int(boneIndices[i]);\n        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);\n        vec4 boneDual = vec4(0.0);\n        if (boneIndex < numBones) {\n          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);\n          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);\n        }\n\n        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {\n          // Flip sign if next blend is pointing in the opposite direction\n          boneQuat = -boneQuat;\n          boneDual = -boneDual;\n        }\n        quat += weights[i] * boneQuat;\n        dual += weights[i] * boneDual;\n      }\n    }\n\n    // Normalize dual quaternion\n    float norm = length(quat);\n    quat /= norm;\n    dual /= norm;\n    vec3 translate = vec3(\n      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),\n      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),\n      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)\n    );\n\n    center = quatVec(quat, center) + translate;\n    quaternion = quatQuat(quat, quaternion);\n  }\n");function Ao({splats:A,extents:n,stepSize:t=1,pointRadius:s=.01,pointShadowScale:a=2,opacity:i=1,color:r}){const o=1e-6,g=new e.Vector3,c=new e.Vector3,I=new e.Quaternion(0,0,0,1);null==r&&(r=(A,n)=>A.set(.55+.45*Math.cos(1*n.x),.55+.45*Math.cos(1*n.y),.55+.45*Math.cos(1*n.z)));const l=new e.Color;for(let e=n.min.z;e<n.max.z+o;e+=t)for(let B=n.min.y;B<n.max.y+o;B+=t)for(let Q=n.min.x;Q<n.max.x+o;Q+=t){g.set(Q,B,e);for(let n=0;n<2;++n)c.setScalar(s*(n?1:a)),n?"function"==typeof r?r(l,g):l.copy(r):l.setScalar(0),A.pushSplat(g,c,I,i,l)}}function no({splats:A,scale:n=.25,axisRadius:t=.0075,axisShadowScale:s=2,origins:a=[new e.Vector3]}){const i=new e.Vector3,r=new e.Vector3,o=new e.Quaternion(0,0,0,1),g=new e.Color;for(const e of a)for(let a=0;a<3;++a){i.set(e.x+(0===a?n:0),e.y+(1===a?n:0),e.z+(2===a?n:0));for(let e=0;e<2;++e)r.set((0===a?n:t)*(e?1:s),(1===a?n:t)*(e?1:s),(2===a?n:t)*(e?1:s)),g.setRGB(0===e?0:0===a?1:0,0===e?0:1===a?1:0,0===e?0:2===a?1:0),A.pushSplat(i,r,o,1,g)}}function to({splats:A,origin:n=new e.Vector3,radius:t=1,maxDepth:s=3,filter:a=null,pointRadius:i=.02,pointThickness:r=.001,color:o=new e.Color(1,1,1)}){const g={};function c(A){if(a&&!a(A))return;const n=`${A.x},${A.y},${A.z}`;g[n]||(g[n]=A)}function I(A,n,t,a){if(c(n),c(t),c(a),A>=s)return;const i=(new e.Vector3).addVectors(n,t).normalize(),r=(new e.Vector3).addVectors(t,a).normalize(),o=(new e.Vector3).addVectors(a,n).normalize();I(A+1,n,i,o),I(A+1,i,t,r),I(A+1,o,r,a),I(A+1,i,r,o)}for(const A of[-1,1])for(const n of[-1,1])for(const t of[-1,1]){I(0,new e.Vector3(A,0,0),new e.Vector3(0,n,0),new e.Vector3(0,0,t))}const l=Object.values(g),B=new e.Vector3(i,i,r),Q=new e.Quaternion,u="function"==typeof o?new e.Color:o;for(const s of l)Q.setFromUnitVectors(new e.Vector3(0,0,-1),s),"function"==typeof o&&o(u,s),s.multiplyScalar(t),s.add(n),A.pushSplat(s,B,Q,1,u)}function eo({text:A,font:n,fontSize:t,color:s,rgb:a,dotRadius:i,textAlign:r,lineHeight:o,objectScale:g}){n=n??"Arial",t=t??32,s=s??new e.Color(1,1,1),i=i??.8,r=r??"start",o=o??1,g=g??1;const c=A.split("\n"),I=document.createElement("canvas"),l=I.getContext("2d");if(!l)throw new Error("Failed to create canvas context");l.font=`${t}px ${n}`,l.textAlign=r;const B=l.measureText(""),Q=B.fontBoundingBoxAscent+B.fontBoundingBoxDescent;let u=Number.POSITIVE_INFINITY,C=Number.NEGATIVE_INFINITY,E=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY;for(let A=0;A<c.length;++A){const n=l.measureText(c[A]),t=Q*o*A;u=Math.min(u,-n.actualBoundingBoxLeft),C=Math.max(C,n.actualBoundingBoxRight),E=Math.min(E,t-n.actualBoundingBoxAscent),h=Math.max(h,t+n.actualBoundingBoxDescent)}const p=Math.floor(u),d=Math.floor(E),y=Math.ceil(C)-p,f=Math.ceil(h)-d;I.width=y,I.height=f,l.font=`${t}px ${n}`,l.textAlign=r,l.textBaseline="alphabetic",l.fillStyle="#FFFFFF";for(let A=0;A<c.length;++A){const n=Q*o*A-d;l.fillText(c[A],-p,n)}const m=l.getImageData(0,0,y,f),w=new Uint8Array(m.data.buffer),D=new fr,x=new e.Vector3,S=(new e.Vector3).setScalar(i*g),b=new e.Quaternion(0,0,0,1);a=a??new e.Color(1,1,1);let k=0;for(let A=0;A<f;++A)for(let n=0;n<y;++n){const t=w[k+3];if(t>0){const e=t/255;x.set(n-.5*(y-1),.5*(f-1)-A,0),x.multiplyScalar(g),D.pushSplat(x,S,b,e,a)}k+=4}const M=new qi({packedSplats:D});return M.recolor=s,M}function so({url:A,dotRadius:n,subXY:t,forEachSplat:s}){return n=n??.8,t=Math.max(1,Math.floor(t??1)),new qi({constructSplats:async a=>new Promise(((i,r)=>{const o=new Image;o.crossOrigin="anonymous",o.onerror=r,o.onload=()=>{const{width:A,height:g}=o,c=document.createElement("canvas");c.width=A,c.height=g;const I=c.getContext("2d");if(!I)return void r(new Error("Failed to create canvas context"));I.imageSmoothingEnabled=!0,I.imageSmoothingQuality="high";const l=Math.round(A/t),B=Math.round(g/t);I.drawImage(o,0,0,l,B);try{const A=I.getImageData(0,0,l,B),t=new Uint8Array(A.data.buffer),r=new e.Vector3,o=(new e.Vector3).setScalar(n),g=new e.Quaternion(0,0,0,1),c=new e.Color;let Q=0;for(let A=0;A<B;++A)for(let e=0;e<l;++e){const i=4*Q,I=t[i+3];if(I>0){let u=I/255;c.set(t[i+0]/255,t[i+1]/255,t[i+2]/255),r.set(e-.5*(l-1),.5*(B-1)-A,0),o.setScalar(n),g.set(0,0,0,1);let C=!0;if(s){const A=s(l,B,Q,r,o,g,u,c);u=A??u,C=null!==A}C&&a.pushSplat(r,o,g,u,c)}Q+=1}i()}catch(A){r(A)}},o.src=A}))})}const ao={box:new e.Box3(new e.Vector3(-1,-1,-1),new e.Vector3(1,1,1)),density:100,fallDirection:new e.Vector3(-1,-3,1).normalize(),fallVelocity:.02,wanderScale:.04,wanderVariance:2,color1:new e.Color(1,1,1),color2:new e.Color(.5,.5,1),minScale:.001,maxScale:.005,anisoScale:new e.Vector3(1,1,1)},io={box:new e.Box3(new e.Vector3(-2,-1,-2),new e.Vector3(2,5,2)),density:10,fallDirection:new e.Vector3(0,-1,0),fallVelocity:2,wanderScale:.1,wanderVariance:1,color1:new e.Color(1,1,1),color2:new e.Color(.25,.25,.5),minScale:.005,maxScale:.01,anisoScale:new e.Vector3(.1,1,.1)};const ro=Object.freeze(Object.defineProperty({__proto__:null,DEFAULT_RAIN:io,DEFAULT_SNOW:ao,snowBox:function({box:A,minY:n,numSplats:t,density:s,anisoScale:a,minScale:i,maxScale:r,fallDirection:o,fallVelocity:g,wanderScale:c,wanderVariance:I,color1:l,color2:B,opacity:Q,onFrame:u}){const C=((A=A??new e.Box3(new e.Vector3(-1,-1,-1),new e.Vector3(1,1,1))).max.x-A.min.x)*(A.max.y-A.min.y)*(A.max.z-A.min.z);s=s??100,t=t??Math.max(1,Math.min(1e6,Math.round(C*s)));const E=gn(i??.001),h=gn(r??.005),p=cn(((null==a?void 0:a.clone())??new e.Vector3(1,1,1)).normalize()),d=cn((o??new e.Vector3(0,-1,0)).normalize()),y=gn(g??.02),f=gn(c??.01),m=gn(I??2),w=cn(l??new e.Color(1,1,1)),D=cn(B??new e.Color(.5,.5,1)),x=gn(Q??1),S=gn(0),b=cn(new e.Vector3(0,0,0)),k=cn(A.min),M=cn(A.max),v=gn(n??Number.NEGATIVE_INFINITY),F=Be(M,k),N=new Ji({numSplats:t,generator:FA({index:"int"},{gsplat:YA},(({index:A})=>{if(!A)throw new Error("index not defined");const n=Fa(A),t=sa(n).outputs.w;let s=ds(n),a=pe(Qe(t,xA("float",100)));a=si(Qe(wA("float","PI"),a)),a=le(E,Qe(a,Be(h,E)));const i=Qe(a,p),r=pe(Qe(t,xA("float",10))),o=pe(t),g=ye(w,D,o),c=Qe(g,r),I=Fa(aa({vectorType:"ivec2",x:A,y:xA("int",6837)}));let l=ds(I),B=Qe(sa(I).outputs.w,m);B=le(S,B),s=le(s,b);const Q=Ee(s,xA("vec3",new e.Vector3(1,1,1)));s=le(k,Qe(F,Q));const u=xA("vec4",new e.Quaternion(0,0,0,1));l=si(le(ds(B),l)),l=Qe(l,f);let C=le(s,l),d=sa(C).outputs.y;d=de(v,d),C=aa({vector:C,y:d});let y=KA({flags:wA("uint","GSPLAT_FLAG_ACTIVE"),index:A,center:C,scales:i,quaternion:u,rgb:c,opacity:x});return y=R.applyGsplat(y),{gsplat:y}}),{globals:()=>[VA]}),update:({object:A,time:n,deltaTime:t})=>{S.value=n,R.update(N);const e=d.value.clone().multiplyScalar(y.value*t);b.value.add(e),A.visible=x.value>0,null==u||u({object:A,time:n,deltaTime:t}),N.updateVersion()}}),R=new Yi;return{snow:N,min:k,max:M,minY:v,color1:w,color2:D,opacity:x,fallVelocity:y,wanderVariance:m,wanderScale:f,fallDirection:d,minScale:E,maxScale:h,anisoScale:p}},staticBox:function({box:A,cells:n,dotScale:t,color:s,opacity:a}){n.x=Math.max(1,Math.round(n.x)),n.y=Math.max(1,Math.round(n.y)),n.z=Math.max(1,Math.round(n.z)),a=a??1;const i=n.x*n.y*n.z,r=xA("int",n.x),o=xA("int",n.y);xA("int",n.z);const g=gn(0),c=new Ji({numSplats:i,generator:FA({index:"int"},{gsplat:YA},(({index:i})=>{if(!i)throw new Error("index is undefined");const c=Ce(i,r),l=ue(i,r),B=Ce(l,o),Q=ue(l,o),u=aa({vectorType:"ivec3",x:c,y:B,z:Q}),C=fs(g),E=aa({vectorType:"ivec2",x:i,y:C}),h=va(E),p=xA("vec3",A.min),d=xA("vec3",A.max),y=Be(d,p),f=ue(le(ds(u),h),xA("vec3",n));let m,w,D;s?(m=xA("float",s.r),w=xA("float",s.g),D=xA("float",s.b)):({r:m,g:w,b:D}=sa(f).outputs);const x=aa({vectorType:"vec4",r:m,g:w,b:D,a:xA("float",a)}),S=le(p,Qe(y,f)),b=ds(xA("float",t)),k=xA("vec4",new e.Quaternion(0,0,0,1));let M=KA({flags:wA("uint","GSPLAT_FLAG_ACTIVE"),index:i,center:S,scales:b,quaternion:k,rgba:x});return M=I.applyGsplat(M),{gsplat:M}}),{globals:()=>[VA]}),update:({time:A})=>{g.value=A,I.update(c),c.updateVersion()}}),I=new Yi;return c}},Symbol.toStringTag,{value:"Module"}));function oo(A){return FA({gsplat:YA},{gsplat:YA},(({gsplat:n})=>{if(!n)throw new Error("No gsplat input");let t=PA(n);const e=A.applyGsplat(n),s=zA(e).outputs.center,a=PA(e),i=ta(s,a),r=Xe(i,xA("float",0));t=As(r,he(t),t);const o=le(Qe(t,xA("float",.5)),xA("float",.5));return{gsplat:n=KA({gsplat:n,rgb:o})}}))}function go(A,n,t,e){return FA({gsplat:YA},{gsplat:YA},(({gsplat:s})=>{if(!s)throw new Error("No gsplat input");let{center:a}=zA(s).outputs;a=A.apply(a);const{z:i}=sa(a).outputs;let r=Na(he(i),n,t);return r=As(e,Be(xA("float",1),r),r),{gsplat:s=KA({gsplat:s,r,g:r,b:r})}}))}const co=Object.freeze(Object.defineProperty({__proto__:null,makeDepthColorModifier:go,makeNormalColorModifier:oo,setDepthColor:function(A,n,t,e){A.enableWorldToView=!0;const s=xA("float",n),a=xA("float",t),i=xA("bool",e??!1);return A.worldModifier=go(A.context.worldToView,s,a,i),A.updateGenerator(),{minDepth:s,maxDepth:a,reverse:i}},setWorldNormalColor:function(A){A.enableWorldToView=!0,A.worldModifier=oo(A.context.worldToView),A.updateGenerator()}},Symbol.toStringTag,{value:"Module"})),Io=class A{static createButton(n,t={}){const e=navigator.xr;if(!e)return null;const s=e,a=document.createElement("button");function i(){a.style.display="none",a.style.cursor="auto",a.style.left="calc(50% - 75px)",a.style.width="150px",a.onmouseenter=null,a.onmouseleave=null,a.onclick=null}var r;return n.xr.enabled=!0,n.xr.setReferenceSpaceType("local"),a.id="VRButton",a.style.display="none",(r=a).style.position="absolute",r.style.bottom="20px",r.style.padding="12px 6px",r.style.border="1px solid #fff",r.style.borderRadius="4px",r.style.background="rgba(0,0,0,0.1)",r.style.color="#fff",r.style.font="normal 13px sans-serif",r.style.textAlign="center",r.style.opacity="0.5",r.style.outline="none",r.style.zIndex="999",s.isSessionSupported("immersive-vr").then((e=>{e?function(){let A=null;async function e(t){console.log("onSessionStarted"),t.addEventListener("end",i),await n.xr.setSession(t),a.textContent="EXIT VR",A=t}function i(){console.log("onSessionEnded"),null==A||A.removeEventListener("end",i),a.textContent="ENTER VR",A=null}a.style.display="",a.style.cursor="pointer",a.style.left="calc(50% - 100px)",a.style.width="200px",a.style.height="100px",a.textContent="ENTER VR";const r={...t,optionalFeatures:[...t.optionalFeatures||[]]};a.onmouseenter=()=>{a.style.opacity="1.0"},a.onmouseleave=()=>{a.style.opacity="0.5"},a.onclick=()=>{null===A?(console.log("requesting session"),s.requestSession("immersive-vr",r).then(e)):(console.log("ending session"),A.end())}}():(i(),a.textContent="VR NOT SUPPORTED"),e&&A.xrSessionIsGranted&&a.click()})).catch((function(A){i(),console.warn("Exception when trying to call xr.isSessionSupported",A),a.textContent="VR NOT ALLOWED"})),a}static registerSessionGrantedListener(){const n=navigator.xr;if(!n)return null;const t=n;/WebXRViewer\//i.test(navigator.userAgent)||t.addEventListener("sessiongranted",(()=>{A.xrSessionIsGranted=!0}))}};Io.xrSessionIsGranted=!1;let lo=Io;lo.registerSessionGrantedListener();var Bo=(A=>(A.w="wrist",A.t0="thumb-metacarpal",A.t1="thumb-phalanx-proximal",A.t2="thumb-phalanx-distal",A.t3="thumb-tip",A.i0="index-finger-metacarpal",A.i1="index-finger-phalanx-proximal",A.i2="index-finger-phalanx-intermediate",A.i3="index-finger-phalanx-distal",A.i4="index-finger-tip",A.m0="middle-finger-metacarpal",A.m1="middle-finger-phalanx-proximal",A.m2="middle-finger-phalanx-intermediate",A.m3="middle-finger-phalanx-distal",A.m4="middle-finger-tip",A.r0="ring-finger-metacarpal",A.r1="ring-finger-phalanx-proximal",A.r2="ring-finger-phalanx-intermediate",A.r3="ring-finger-phalanx-distal",A.r4="ring-finger-tip",A.p0="pinky-finger-metacarpal",A.p1="pinky-finger-phalanx-proximal",A.p2="pinky-finger-phalanx-intermediate",A.p3="pinky-finger-phalanx-distal",A.p4="pinky-finger-tip",A))(Bo||{});const Qo=Object.keys(Bo),uo=Qo.length,Co={w:0,t0:1,t1:2,t2:3,t3:4,i0:5,i1:6,i2:7,i3:8,i4:9,m0:10,m1:11,m2:12,m3:13,m4:14,r0:15,r1:16,r2:17,r3:18,r4:19,p0:20,p1:21,p2:22,p3:23,p4:24},Eo={w:.02,t0:.02,t1:.014,t2:.0115,t3:.0085,i0:.022,i1:.012,i2:.0085,i3:.0075,i4:.0065,m0:.021,m1:.012,m2:.008,m3:.0075,m4:.0065,r0:.019,r1:.011,r2:.0075,r3:.007,r4:.006,p0:.012,p1:.01,p2:.007,p3:.0065,p4:.0055},ho=[["w","t0","t1","t2","t3"],["w","i0","i1","i2","i3","i4"],["w","m0","m1","m2","m3","m4"],["w","r0","r1","r2","r3","r4"],["w","p0","p1","p2","p3","p4"]],po=[[8,10,8,6],[8,19,14,8,6],[8,19,14,8,6],[8,19,14,8,6],[8,19,14,8,6]],yo=["t3","i4","m4","r4","p4"],fo=["i4","m4","r4","p4"];var mo=(A=>(A.left="left",A.right="right",A))(mo||{});const wo=Object.keys(mo);class Do{constructor(){this.hands={},this.last={},this.values={},this.tests={},this.lastTests={},this.updated=!1}update({xr:A,xrFrame:n}){const t=A.getSession();if(!t)return;const s=A.getReferenceSpace();if(s&&n.getJointPose){this.last=this.hands,this.lastTests=this.tests,this.hands={},this.values={},this.tests={};for(const A of t.inputSources){if(!A.hand)continue;const t=A.handedness;this.hands[t]={};for(const a of Qo){const i=A.hand.get(Bo[a]);if(i){const A=n.getJointPose(i,s);if(A){const{position:n,orientation:s}=A.transform;this.hands[t][a]={position:new e.Vector3(n.x,n.y,n.z),quaternion:new e.Quaternion(s.x,s.y,s.z,s.w),radius:A.radius||.001}}}}}for(const A of wo)for(const{key:n,value:t}of[{key:`${A}AllTips`,value:this.allTipsTouching(A)},{key:`${A}IndexThumb`,value:this.touching(A,"i4",A,"t3")},{key:`${A}MiddleThumb`,value:this.touching(A,"m4",A,"t3")},{key:`${A}RingThumb`,value:this.touching(A,"r4",A,"t3")},{key:`${A}PinkyThumb`,value:this.touching(A,"p4",A,"t3")},{key:`${A}TriTips`,value:this.triTipsTouching(A)}])this.values[n]=t,this.tests[n]=1===t||0!==t&&(this.lastTests[n]??!1)}}makeGhostMesh(){const A=new e.Vector3,n=new e.Vector3(.01,.01,.01),t=new e.Quaternion(0,0,0,1),s=new e.Color(1,1,1),a=3*Math.PI;new e.Color(1,1,1);let i=1;const r=new qi({onFrame:()=>{let e=0;for(const o of wo){const g=this.hands[o];for(const[c,I]of ho.entries())for(let l=1;l<I.length;++l){const B=2*po[c][l-1],Q=l+1===I.length,u=null==g?void 0:g[I[l-1]],C=null==g?void 0:g[I[l]];for(let g=0;g<B;++g){const c=(g+.5)/B;if(i=0,u&&C){A.copy(u.position).lerp(C.position,c),t.copy(u.quaternion).slerp(C.quaternion,c);let e=(1-c)*Eo[I[l-1]]+c*Eo[I[l]];Q&&c>.8&&(e*=Math.sqrt(1-((c-.8)/.2)**2)),n.set(.65*e,.5*e,.003),s.set(.55+.45*Math.sin(A.x*a),.55+.45*Math.sin(A.y*a),.55+.45*Math.sin(A.z*a)),"right"===o&&s.set(1-s.r,1-s.g,1-s.b),i=.75}r.packedSplats.setSplat(e,A,n,t,i,s),e+=1}}}r.packedSplats.numSplats=e,r.packedSplats.needsUpdate=!0,r.numSplats=e,r.updateVersion()}});return r}distance(A,n,t,e,s=!1){const a=s?this.last[A]:this.hands[A],i=s?this.last[t]:this.hands[t],r=null==a?void 0:a[n],o=null==i?void 0:i[e];return r&&o?r.position.distanceTo(o.position):Number.POSITIVE_INFINITY}separation(A,n,t,e,s=!1){const a=this.distance(A,n,t,e,s);return a===Number.POSITIVE_INFINITY?Number.POSITIVE_INFINITY:a-Eo[n]-Eo[e]}touching(A,n,t,e,s=!1){const a=this.separation(A,n,t,e,s);return a===Number.POSITIVE_INFINITY?Number.POSITIVE_INFINITY:1-Math.max(0,Math.min(1,a/.01-0))}allTipsTouching(A,n=!1){return Math.min(this.touching(A,"t3",A,"i4",n),this.touching(A,"i4",A,"m4",n),this.touching(A,"m4",A,"r4",n),this.touching(A,"r4",A,"p4",n))}triTipsTouching(A,n=!1){return Math.min(this.touching(A,"t3",A,"i4",n),this.touching(A,"i4",A,"m4",n),this.touching(A,"m4",A,"t3",n))}}class xo{constructor({xrHands:A,control:n,moveInertia:t,rotateInertia:s}){this.lastGrip={},this.lastPivot=new e.Vector3,this.rotateVelocity=0,this.velocity=new e.Vector3,this.xrHands=A,this.control=n,this.moveInertia=t??.5,this.rotateInertia=s??.5}update(A){var n,t,s,a,i;const r={};for(const A of wo){const o=this.xrHands.hands[A];o&&this.xrHands.tests[`${A}MiddleThumb`]&&(r[A]=(new e.Vector3).add((null==(n=o.t3)?void 0:n.position)??new e.Vector3).add((null==(t=o.i4)?void 0:t.position)??new e.Vector3).add((null==(s=o.m4)?void 0:s.position)??new e.Vector3).add((null==(a=o.r4)?void 0:a.position)??new e.Vector3).add((null==(i=o.p4)?void 0:i.position)??new e.Vector3).multiplyScalar(.2))}if(r.left&&r.right&&this.lastGrip.left&&this.lastGrip.right){const n=r.left.clone().add(r.right).multiplyScalar(.5),t=this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(.5);this.lastPivot=n;const e=n.clone().applyMatrix4(this.control.matrix);e.sub(t.clone().applyMatrix4(this.control.matrix)),e.multiplyScalar(1/A),this.velocity.lerp(e,1-Math.exp(-20*A));let s=Math.atan2(r.left.z-n.z,r.left.x-n.x)-Math.atan2(this.lastGrip.left.z-t.z,this.lastGrip.left.x-t.x);s>Math.PI?s-=2*Math.PI:s<-Math.PI&&(s+=2*Math.PI);const a=s/A,i=Math.exp(-20*A);this.rotateVelocity=this.rotateVelocity*i+a*(1-i)}else if(this.rotateVelocity*=Math.exp(-A/this.rotateInertia),r.left&&this.lastGrip.left){const n=r.left.clone().applyMatrix4(this.control.matrix);n.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix)),n.multiplyScalar(1/A),this.velocity.lerp(n,1-Math.exp(-20*A))}else if(r.right&&this.lastGrip.right){const n=r.right.clone().applyMatrix4(this.control.matrix);n.sub(this.lastGrip.right.clone().applyMatrix4(this.control.matrix)),n.multiplyScalar(1/A),this.velocity.lerp(n,1-Math.exp(-20*A))}else this.velocity.multiplyScalar(Math.exp(-A/this.moveInertia));const o=this.lastPivot.clone().negate(),g=(new e.Matrix4).makeTranslation(o).premultiply((new e.Matrix4).makeRotationY(this.rotateVelocity*A)).premultiply((new e.Matrix4).makeTranslation(this.lastPivot));this.control.matrix.multiply(g),this.control.matrix.decompose(this.control.position,this.control.quaternion,this.control.scale),this.control.updateMatrixWorld(!0),this.control.position.sub(this.velocity.clone().multiplyScalar(A)),this.lastGrip=r}}const So={KeyW:new e.Vector3(0,0,-1),KeyS:new e.Vector3(0,0,1),KeyA:new e.Vector3(-1,0,0),KeyD:new e.Vector3(1,0,0),KeyR:new e.Vector3(0,1,0),KeyF:new e.Vector3(0,-1,0)},bo={ArrowUp:new e.Vector3(0,0,-1),ArrowDown:new e.Vector3(0,0,1),ArrowLeft:new e.Vector3(-1,0,0),ArrowRight:new e.Vector3(1,0,0),PageUp:new e.Vector3(0,1,0),PageDown:new e.Vector3(0,-1,0)},ko={KeyQ:new e.Vector3(0,0,1),KeyE:new e.Vector3(0,0,-1)},Mo={Home:new e.Vector3(0,-1,0),End:new e.Vector3(0,1,0),Insert:new e.Vector3(-1,0,0),Delete:new e.Vector3(1,0,0)};class vo{constructor({canvas:A}){this.lastTime=0,this.fpsMovement=new Fo({}),this.pointerControls=new No({canvas:A})}update(A){const n=performance.now(),t=(n-(this.lastTime||n))/1e3;this.lastTime=n,this.fpsMovement.update(t,A),this.pointerControls.update(t,A)}}class Fo{constructor({moveSpeed:A,rollSpeed:n,stickThreshold:t,rotateSpeed:e,keycodeMoveMapping:s,keycodeRotateMapping:a,gamepadMapping:i,capsMultiplier:r,shiftMultiplier:o,ctrlMultiplier:g,xr:c}={}){this.enable=!0,this.moveSpeed=A??1,this.rollSpeed=n??2,this.stickThreshold=t??.1,this.rotateSpeed=e??2,this.keycodeMoveMapping=s??{...So,...bo},this.keycodeRotateMapping=a??{...ko,...Mo},this.gamepadMapping=i??{4:"rollLeft",5:"rollRight",6:"ctrl",7:"shift"},this.capsMultiplier=r??10,this.shiftMultiplier=o??5,this.ctrlMultiplier=g??.2,this.xr=c,this.keydown={},this.keycode={},document.addEventListener("keydown",(A=>{this.keydown[A.key]=!0,this.keycode[A.code]=!0})),document.addEventListener("keyup",(A=>{this.keydown[A.key]=!1,this.keycode[A.code]=!1})),window.addEventListener("blur",(()=>{this.keydown={},this.keycode={}}))}update(A,n){var t,s;if(!this.enable)return;const a=[new e.Vector2,new e.Vector2],i=navigator.getGamepads()[0];i&&(a[0].set(i.axes[0],i.axes[1]),a[1].set(i.axes[2],i.axes[3]));const r=(null==i?void 0:i.buttons.map((A=>A.pressed)))||[],o=Array.from((null==(s=null==(t=this.xr)?void 0:t.getSession())?void 0:s.inputSources)??[]);for(const A of o){const n=A.gamepad;if(n)switch(A.handedness){case"none":a[0].x+=n.axes[0],a[0].y+=n.axes[1],a[1].x+=n.axes[2],a[1].y+=n.axes[3];break;case"left":a[0].x+=n.axes[2],a[0].y+=n.axes[3];break;case"right":a[1].x+=n.axes[2],a[1].y+=n.axes[3]}}for(const A of a)A.x=Math.abs(A.x)>=this.stickThreshold?A.x:0,A.y=Math.abs(A.y)>=this.stickThreshold?A.y:0;const g=new e.Vector3(a[1].x,a[1].y,0).multiplyScalar(this.rotateSpeed);for(const[A,n]of Object.entries(this.keycodeRotateMapping))this.keycode[A]&&g.add(n);for(const A in this.gamepadMapping)if(r[Number.parseInt(A)])switch(this.gamepadMapping[A]){case"rollLeft":g.z+=1;break;case"rollRight":g.z-=1}if(g.multiply(new e.Vector3(this.rotateSpeed,this.rotateSpeed,this.rollSpeed)),g.manhattanLength()>0){g.multiplyScalar(A);const t=(new e.Euler).setFromQuaternion(n.quaternion,"YXZ");t.y-=g.x,t.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,t.x-g.y)),t.z=Math.max(-Math.PI,Math.min(Math.PI,t.z+g.z)),n.quaternion.setFromEuler(t)}const c=new e.Vector3(a[0].x,0,a[0].y);for(const[A,n]of Object.entries(this.keycodeMoveMapping))this.keycode[A]&&c.add(n);let I=1;this.keydown.CapsLock&&(I*=this.capsMultiplier),(this.keycode.ShiftLeft||this.keycode.ShiftRight)&&(I*=this.shiftMultiplier),(this.keycode.ControlLeft||this.keycode.ControlRight)&&(I*=this.ctrlMultiplier);for(const A in this.gamepadMapping)if(r[Number.parseInt(A)])switch(this.gamepadMapping[A]){case"shift":I*=this.shiftMultiplier;break;case"ctrl":I*=this.ctrlMultiplier}c.applyQuaternion(n.quaternion),n.position.add(c.multiplyScalar(this.moveSpeed*I*A))}}class No{constructor({canvas:A,rotateSpeed:n,slideSpeed:t,scrollSpeed:s,swapRotateSlide:a,reverseRotate:i,reverseSlide:r,reverseSwipe:o,reverseScroll:g,moveInertia:c,rotateInertia:I,pointerRollScale:l,doublePress:B}){this.enable=!0,this.canvas=A,this.rotateSpeed=n??.002,this.slideSpeed=t??.006,this.scrollSpeed=s??.0015,this.swapRotateSlide=a??!1,this.reverseRotate=i??!1,this.reverseSlide=r??!1,this.reverseSwipe=o??!1,this.reverseScroll=g??!1,this.moveInertia=c??.15,this.rotateInertia=I??.15,this.pointerRollScale=l??1,this.doublePress=B??(()=>{}),this.doublePressLimitMs=400,this.doublePressDistance=50,this.lastUp=null,this.rotating=null,this.sliding=null,this.dualPress=!1,this.scroll=new e.Vector3,this.rotateVelocity=new e.Vector3,this.moveVelocity=new e.Vector3,A.addEventListener("pointerdown",(n=>{const t=this.getPointerPosition(n),e=t.clone(),s=t.clone(),a=!this.swapRotateSlide&&!this.rotating&&("mouse"!==n.pointerType||0===n.button)||this.swapRotateSlide&&this.sliding&&!this.rotating&&("mouse"!==n.pointerType||1===n.button),{pointerId:i,timeStamp:r}=n;if(a)this.rotating={initial:e,last:s,position:t,pointerId:i,timeStamp:r},A.setPointerCapture(n.pointerId),this.dualPress=!1;else if(!this.sliding){const a="mouse"===n.pointerType?n.button:void 0;this.sliding={initial:e,last:s,position:t,pointerId:i,button:a,timeStamp:r},A.setPointerCapture(n.pointerId),this.dualPress=null!=this.rotating&&r-this.rotating.timeStamp<200}}));const Q=n=>{var t,e;(null==(t=this.rotating)?void 0:t.pointerId)===n.pointerId?(this.rotating=null,A.releasePointerCapture(n.pointerId),this.dualPress&&this.sliding&&(A.releasePointerCapture(this.sliding.pointerId),this.sliding=null)):(null==(e=this.sliding)?void 0:e.pointerId)===n.pointerId&&(this.sliding=null,A.releasePointerCapture(n.pointerId),this.dualPress&&this.rotating&&(A.releasePointerCapture(this.rotating.pointerId),this.rotating=null));const s=this.getPointerPosition(n),a=this.lastUp;if(this.lastUp={position:s,time:n.timeStamp},a){if(a.position.distanceTo(s)<this.doublePressDistance){const A=n.timeStamp-a.time;A<this.doublePressLimitMs&&(this.lastUp=null,this.doublePress({position:s,intervalMs:A}))}}};document.addEventListener("pointerup",Q),document.addEventListener("pointercancel",Q),document.addEventListener("pointermove",(A=>{var n,t;(null==(n=this.rotating)?void 0:n.pointerId)===A.pointerId?this.rotating.position=this.getPointerPosition(A):(null==(t=this.sliding)?void 0:t.pointerId)===A.pointerId&&(this.sliding.position=this.getPointerPosition(A))})),A.addEventListener("contextmenu",(A=>{A.preventDefault()})),A.addEventListener("wheel",(A=>{this.scroll.add(new e.Vector3(A.deltaX,A.deltaY,A.deltaZ)),A.preventDefault()}))}getPointerPosition(A){const n=this.canvas.getBoundingClientRect();return new e.Vector2(A.clientX-n.left,A.clientY-n.top)}update(A,n){if(!this.enable)return;if(this.dualPress&&this.rotating&&this.sliding){const t=[this.rotating.position.clone().sub(this.rotating.last),this.sliding.position.clone().sub(this.sliding.last)],s=t[0].dot(t[1]);if(s>=.2){const s=t[0].clone().add(t[1]),a=new e.Vector3(s.x,-s.y,0);a.multiplyScalar(this.slideSpeed*(this.reverseSwipe?1:-1)),a.applyQuaternion(n.quaternion),n.position.add(a),this.moveVelocity=a.clone().multiplyScalar(1/A)}else if(s<=-.2){const s=this.sliding.last.clone().sub(this.rotating.last),a=s.length();s.multiplyScalar(1/a).normalize();const i=new e.Vector2(-s.y,s.x),r=[t[0].dot(s),t[1].dot(s)],o=[t[0].dot(i),t[1].dot(i)],g=this.rotating.last.clone().add(this.sliding.last).multiplyScalar(.5);let c=new e.Vector3;if(n instanceof e.Camera){const A=new e.Vector2(g.x/this.canvas.clientWidth*2-1,-g.y/this.canvas.clientHeight*2+1),t=new e.Raycaster;t.setFromCamera(A,n),c=t.ray.direction}const I=r[1]-r[0],l=c.multiplyScalar(I*this.slideSpeed);n.position.add(l),this.moveVelocity=l.clone().multiplyScalar(1/A);const B=[Math.atan(o[0]/(-.5*a)),Math.atan(o[1]/(.5*a))],Q=.5*(B[0]+B[1])*this.pointerRollScale,u=(new e.Euler).setFromQuaternion(n.quaternion,"YXZ");u.z=Math.max(-Math.PI,Math.min(Math.PI,u.z+.5*Q)),n.quaternion.setFromEuler(u)}this.rotating.last.copy(this.rotating.position),this.sliding.last.copy(this.sliding.position)}else{const t=new e.Vector3;if(this.rotating&&!this.dualPress){const n=this.rotating.position.clone().sub(this.rotating.last);this.rotating.last.copy(this.rotating.position),t.set(n.x,n.y,0),t.multiplyScalar(this.rotateSpeed*(this.reverseRotate?-1:1)),this.rotateVelocity=t.clone().multiplyScalar(1/A)}else this.rotateVelocity.multiplyScalar(Math.exp(-A/this.rotateInertia)),t.addScaledVector(this.rotateVelocity,A);const s=(new e.Euler).setFromQuaternion(n.quaternion,"YXZ");if(s.y-=t.x,s.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,s.x-t.y)),s.z*=Math.exp(-0*A),n.quaternion.setFromEuler(s),this.sliding&&!this.dualPress){const t=this.sliding.position.clone().sub(this.sliding.last);this.sliding.last.copy(this.sliding.position);const s=2!==this.sliding.button?new e.Vector3(t.x,0,t.y):new e.Vector3(t.x,-t.y,0);s.multiplyScalar(this.slideSpeed*(this.reverseSlide?-1:1)),s.applyQuaternion(n.quaternion),n.position.add(s),this.moveVelocity=s.clone().multiplyScalar(1/A)}else this.moveVelocity.multiplyScalar(Math.exp(-A/this.moveInertia)),n.position.addScaledVector(this.moveVelocity,A)}const t=this.scroll.multiplyScalar(this.scrollSpeed);t.set(t.x,t.z,t.y),this.reverseScroll&&t.multiplyScalar(-1),t.applyQuaternion(n.quaternion),n.position.add(t),this.scroll.set(0,0,0)}}}}]);