"use strict";(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[3543],{43543:(e,t,s)=>{s.d(t,{v:()=>S,X:()=>x});var r=s(52947),o=s(68909);class i{constructor(){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[],[]],this.boundingBox=null,this.boundingSphere=null}}class n{constructor(e,t,s,r,i,n=0){this.a=e,this.b=t,this.c=s,this.materialIndex=n,this.a=e,this.b=t,this.c=s,this.normal=r&&!Array.isArray(r)&&r.isVector3?r:new o.Vector3,this.vertexNormals=Array.isArray(r)?r:[],this.color=i&&!Array.isArray(i)&&i.isColor?i:new o.Color,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=n}clone(){return new n(this.a,this.b,this.c,this.normal,this.color).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,s=e.vertexNormals.length;t<s;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,s=e.vertexColors.length;t<s;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}var a=s(10843),c=s(53172);const h=new a.Ay("surface-edge-finder"),l=new o.Triangle,u=["a","b","c"];class f extends n{constructor(e,t,s,r){super(e.a,e.b,e.c,e.normal),this.va=t,this.vb=s,this.vc=r,this.area=l.set(this.va.vector,this.vb.vector,this.vc.vector).getArea(),this.midpoint=l.getMidpoint(new o.Vector3),this.vertices=[this.va,this.vb,this.vc],t.faces.push(this),s.faces.push(this),r.faces.push(this)}}class m{constructor(e){this.vector=e,this.faces=[]}}class d{constructor(){this.area=0,this.normal=new o.Vector3,this.midpoint=new o.Vector3,this.faces=[],this.normalSum=new o.Vector3,this.midpointSum=new o.Vector3}add(e){e.surface&&e.surface.remove(e),this.faces.push(e),this.area+=e.area,this.midpointSum.add(e.midpoint),this.normalSum.add(e.normal),this.recalcFromSums(),e.surface=this}remove(e){e.surface&&(this.faces.splice(this.faces.indexOf(e),1),this.area-=e.area,this.midpointSum.sub(e.midpoint),this.normalSum.sub(e.normal),this.recalcFromSums()),e.surface=null}recalcFromSums(){this.normal.copy(this.normalSum).normalize(),this.midpoint.copy(this.midpointSum).divideScalar(this.faces.length)}mergeSurfaces(e){for(const t of e.faces)t.surface=this,this.faces.push(t);this.area+=e.area,this.normalSum.add(e.normalSum),this.midpointSum.add(e.midpointSum),this.recalcFromSums(),e.faces=[],e.area=0,e.normal.set(0,0,0),e.normalSum.set(0,0,0),e.midpointSum.set(0,0,0),e.midpoint.set(0,0,0)}getEdges(){const e={},t={};for(const t of this.faces)for(let s=0;s<3;s++){const r=t[u[s]],o=t[u[(s+1)%3]],i=Math.min(r,o)+","+Math.max(r,o);if(void 0===e[i]){const t={edge1:r,edge2:o,isEdge:!0};e[i]=t}else e[i].isEdge=!1}for(const{edge1:s,edge2:r,isEdge:o}of Object.values(e))o&&(t[s]||(t[s]=[]),t[s].push(r),t[r]||(t[r]=[]),t[r].push(s));return t}getCircularPaths(e){const t=this.getEdges(),s=new Set,r=[],o=Object.keys(t).map((e=>parseInt(e,10)));let i;for(;i=o.pop();){const o=[];for(;i;){let r;o.push(e[i]);let n=0;for(const o of t[i]){const t=Math.min(i,o)+","+Math.max(i,o);if(s.has(t))continue;const a=e[i].vector.distanceToSquared(this.midpoint);(void 0===r||a>n)&&(r=o,n=a)}if(!r)break;{const e=Math.min(i,r)+","+Math.max(i,r);s.add(e),i=r}}o.length>2&&r.push(o)}return r}}class p{constructor(){this.surfaces=new Set,this.lines=[],this.points=[]}*run(e,t=[1,5,10],s=.2,a=.01,l=20){const u=function(e){const t=new i,s=null!==e.index?e.index:void 0,r=e.attributes;if(void 0===r.position)throw Error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");const a=r.position,c=r.normal,h=r.color,l=r.uv,u=r.uv2;void 0!==u&&(t.faceVertexUvs[1]=[]);for(let e=0;e<a.count;e++)t.vertices.push((new o.Vector3).fromBufferAttribute(a,e)),void 0!==h&&t.colors.push((new o.Color).fromBufferAttribute(h,e));function f(e,s,r,i=0){const a=void 0===h?[]:[t.colors[e].clone(),t.colors[s].clone(),t.colors[r].clone()],f=void 0===c?[]:[(new o.Vector3).fromBufferAttribute(c,e),(new o.Vector3).fromBufferAttribute(c,s),(new o.Vector3).fromBufferAttribute(c,r)],m=new n(e,s,r,f,a,i);t.faces.push(m),void 0!==l&&t.faceVertexUvs[0].push((new o.Vector2).fromBufferAttribute(l,e),(new o.Vector2).fromBufferAttribute(l,s),(new o.Vector2).fromBufferAttribute(l,r)),void 0!==u&&t.faceVertexUvs[1].push((new o.Vector2).fromBufferAttribute(u,e),(new o.Vector2).fromBufferAttribute(u,s),(new o.Vector2).fromBufferAttribute(u,r))}const m=e.groups;if(m.length>0)for(let e=0;e<m.length;e++){const t=m[e],r=t.start;for(let e=r,o=r+t.count;e<o;e+=3)void 0!==s?f(s.getX(e),s.getX(e+1),s.getX(e+2),t.materialIndex):f(e,e+1,e+2,t.materialIndex)}else if(void 0!==s)for(let e=0;e<s.count;e+=3)f(s.getX(e),s.getX(e+1),s.getX(e+2));else for(let e=0;e<a.count;e+=3)f(e,e+1,e+2);return t}(e),p=u.vertices.map((e=>new m(e))),g=[];for(const e of u.faces)g.push(new f(e,p[e.a],p[e.b],p[e.c])),yield;for(let e=0,t=g.length;e<t;e++){const t=g[e];(new d).add(t)}for(const e of t)yield*this.mergeSurfacesByNormal(g,e);for(const e of g)this.surfaces.add(e.surface);let v=0;const w=[];for(const e of this.surfaces){if(e.area<=s)continue;const t=e.getCircularPaths(p);for(const e of t)this.cullPath(e,((e,t)=>{if(e.length()<a||t.length()<a)return v++,!1;const s=e.angleTo(t)*c.tm;return!(s<l||s>180-l)||(v++,!1)})),e.length>2&&w.push(e);yield}h.debug(`Culled ${v} path points`);const y=new Set,b=new Set,S=e=>`${e.x.toFixed(3)},${e.y.toFixed(3)},${e.z.toFixed(3)}`,x=e=>`${S(e.start)}:${S(e.end)}`,A=e=>`${S(e.end)}:${S(e.start)}`;for(const e of w)for(let t=0;t<e.length;t++){const s=e[t].vector,o=e[(t+1)%e.length].vector,i=new r.cF(s,o),n=x(i),a=A(i),c=S(s);b.has(n)||b.has(a)||(b.add(n),b.add(a),this.lines.push(i)),y.has(c)||(y.add(c),this.points.push(new r.F7(s)))}yield}cullPath(e,t){const s=new o.Vector3,r=new o.Vector3;let i=!0;for(;i;){i=!1;for(let o=0;o<e.length&&e.length>2;o++){const n=e[0===o?e.length-1:o-1].vector,a=e[o].vector,c=e[(o+1)%e.length].vector;s.copy(n).sub(a),r.copy(c).sub(a),t(s,r)||(e.splice(o,1),i=!0,o--)}}}*mergeSurfacesByNormal(e,t,s=5){let r=-1,o=0;for(;0!==r&&o++<s;){h.debug(`Merging surfaces by normal angle threshold: ${t}`);const s=Math.cos(c.fy*t);r=0;let o=0;for(const t of e){o++%1e3==0&&(yield);for(const e of t.vertices)for(const o of e.faces){const e=o.surface;t.surface!==e&&t.surface.normal.dot(e.normal)>=s&&(t.surface.faces.length>e.faces.length?t.surface.mergeSurfaces(e):e.mergeSurfaces(t.surface),r++)}}r&&h.debug(`Merged ${r} surfaces by normal...`)}}}var g=s(27526),v=s(30443),w=s(89103);const y=new a.Ay("snapcaster");var b;!function(e){e[e.UNINITIALIZED=0]="UNINITIALIZED",e[e.WORKING=1]="WORKING",e[e.READY=2]="READY"}(b||(b={}));class S{constructor(e,t){this.cameraData=e,this.engine=t,this.meshes=new Map,this.newMeshes=new Set,this.raycaster=new o.Raycaster,this.filterSnapFeature=e=>{var t,s;const{meshName:r}=e;return!r||!1!==(null===(s=null===(t=this.meshes.get(r))||void 0===t?void 0:t.filter)||void 0===s?void 0:s.call(t,e))},this.cast=(e,t,s,i)=>{let n;s&&i&&(n=(new o.Plane).setFromNormalAndCoplanarPoint(i,s)),this.raycaster.set(e.origin,e.direction);const a=this.snappingOctree.raycast(this.raycaster,t,this.filterSnapFeature)||[],c=e=>{let t=(1+e.distance)*(1+e.distanceToRay)**2;return e.object instanceof r.F7&&(t/=10),n&&n.distanceToPoint(e.point)<-.2&&(t+=10),t};return a.sort(((e,t)=>c(e)-c(t))),a},this.add=(...e)=>{for(const t of e)this.snappingOctree.add(t)},this.remove=(...e)=>{for(const t of e)this.snappingOctree.remove(t)}}dispose(){this.meshes.clear(),this.newMeshes.clear(),this._snappingOctree.clear()}get snappingOctree(){return this.preloadMeshSnapping(),this._snappingOctree}setupOctree(e){this._snappingOctree=new r.Ay(e)}async preloadMeshSnapping(){var e;!this.populateProcess&&this.newMeshes.size&&(this.populateProcess=await this.engine.commandBinder.issueCommand(new g.i("snapping",this.buildSnappingForMeshes(),6e4)),await(null===(e=this.populateProcess)||void 0===e?void 0:e.promise),this.populateProcess=null)}*buildSnappingForMeshes(){const e=new o.Vector3;for(;;){let t=null;for(const s of this.newMeshes){const r=this.meshes.get(s);if(r){const{geometry:o}=r;if(!o){y.error("No mesh to generate snapping information from!"),r.status=b.READY;continue}const i=(0,v.UX)(o).getCenter(e).distanceTo(this.cameraData.pose.position);(!t||i<t.distance)&&(t={meshName:s,geometry:o,distance:i,info:r})}}if(!t)break;this.newMeshes.delete(t.meshName),t.info.status=b.WORKING,yield*this.buildSnappingForGeometry(t.geometry,t.info),t.info.status=b.READY,t.info.geometry=null,yield}y.info(`Snapping found ${this._snappingOctree.pointCount} points and ${this._snappingOctree.lineCount} lines`)}*buildSnappingForGeometry(e,t){e.computeVertexNormals(),yield;const s=new p;yield*s.run(e),y.debug(`Mesh done, added ${s.points.length} points and ${s.lines.length} lines`);for(const e of s.points)e.meshName=t.meshName,e.meta=t.meta,this._snappingOctree.add(e);for(const e of s.lines)e.meshName=t.meshName,e.meta=t.meta,this._snappingOctree.add(e);this.engine.broadcast(new x(s))}forEachSnapFeature(e,t=!1){this.snappingOctree.traverse((s=>{t&&!this.filterSnapFeature(s)||e(s)}))}addMeshGeometry(e,t,s,r){this.meshes.has(e)||(this.meshes.set(e,{meshName:e,geometry:t,status:b.UNINITIALIZED,meta:s,filter:r}),this.newMeshes.add(e))}removeMeshGeometry(e){const t=this.meshes.get(e);t&&t.status===b.UNINITIALIZED&&(this.meshes.delete(e),this.newMeshes.delete(e))}}class x extends w.QB{constructor(e){super(),this.edgeFinder=e}}},27526:(e,t,s)=>{s.d(t,{i:()=>o});var r=s(55141);class o extends r.u{constructor(e,t,s,r=1){super(),this.payload={type:e,func:t,maxDelay:s,steps:r}}}o.id="SCHEDULE_PROCESS_COMMAND"}}]);